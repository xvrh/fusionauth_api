// Generated code - Do not edit manually

import 'api_utils.dart';

// ignore_for_file: deprecated_member_use_from_same_package

/// This is a FusionAuth server. Find out more at [https://fusionauth.io](https://fusionauth.io). You need to [set up an API key](https://fusionauth.io/docs/v1/tech/apis/authentication#managing-api-keys) in the FusionAuth instance you are using to test out the API calls.

class FusionauthApi {
  final ApiClient _client;

  FusionauthApi(this._client);

  /// Retrieves all the members of a family by the unique Family Id.
  Future<FamilyResponse> retrieveFamilyMembersByFamilyIdWithId(
      {required String familyId, String? tenantIdScope}) async {
    return FamilyResponse.fromJson(await _client.send(
      'get',
      'api/user/family/{familyId}',
      pathParameters: {
        'familyId': familyId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Adds a user to an existing family. The family Id must be specified.
  Future<FamilyResponse> addUserToFamilyWithId(
      {required String familyId,
      String? tenantIdScope,
      required FamilyRequest body}) async {
    return FamilyResponse.fromJson(await _client.send(
      'put',
      'api/user/family/{familyId}',
      pathParameters: {
        'familyId': familyId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Creates a family with the user Id in the request as the owner and sole
  /// member of the family. You can optionally specify an Id for the family, if
  /// not provided one will be generated.
  Future<FamilyResponse> createFamilyWithId(
      {required String familyId,
      String? tenantIdScope,
      required FamilyRequest body}) async {
    return FamilyResponse.fromJson(await _client.send(
      'post',
      'api/user/family/{familyId}',
      pathParameters: {
        'familyId': familyId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Re-sends the verification email to the user. OR Re-sends the verification
  /// email to the user. If the Application has configured a specific email
  /// template this will be used instead of the tenant configuration. OR
  /// Generate a new Email Verification Id to be used with the Verify Email API.
  /// This API will not attempt to send an email to the User. This API may be
  /// used to collect the verificationId for use with a third party system.
  Future<VerifyEmailResponse> updateUserVerifyEmail(
      {String? email, String? applicationId, String? sendVerifyEmail}) async {
    return VerifyEmailResponse.fromJson(await _client.send(
      'put',
      'api/user/verify-email',
      queryParameters: {
        if (email != null) 'email': email,
        if (applicationId != null) 'applicationId': applicationId,
        if (sendVerifyEmail != null) 'sendVerifyEmail': sendVerifyEmail,
      },
    ));
  }

  /// Administratively verify a user's email address. Use this method to bypass
  /// email verification for the user.  The request body will contain the userId
  /// to be verified. An API key is required when sending the userId in the
  /// request body. OR Confirms a user's email address.   The request body will
  /// contain the verificationId. You may also be required to send a one-time
  /// use code based upon your configuration. When  the tenant is configured to
  /// gate a user until their email address is verified, this procedures
  /// requires two values instead of one.  The verificationId is a high entropy
  /// value and the one-time use code is a low entropy value that is easily
  /// entered in a user interactive form. The  two values together are able to
  /// confirm a user's email address and mark the user's email address as
  /// verified.
  Future<void> createUserVerifyEmail({required VerifyEmailRequest body}) async {
    await _client.send(
      'post',
      'api/user/verify-email',
      body: body.toJson(),
    );
  }

  /// Handles login via third-parties including Social login, external OAuth and
  /// OpenID Connect, and other login systems.
  Future<LoginResponse> identityProviderLoginWithId(
      {String? tenantIdScope,
      required IdentityProviderLoginRequest body}) async {
    return LoginResponse.fromJson(await _client.send(
      'post',
      'api/identity-provider/login',
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Confirms a user's registration.   The request body will contain the
  /// verificationId. You may also be required to send a one-time use code based
  /// upon your configuration. When  the application is configured to gate a
  /// user until their registration is verified, this procedures requires two
  /// values instead of one.  The verificationId is a high entropy value and the
  /// one-time use code is a low entropy value that is easily entered in a user
  /// interactive form. The  two values together are able to confirm a user's
  /// registration and mark the user's registration as verified.
  Future<void> verifyUserRegistrationWithId(
      {required VerifyRegistrationRequest body}) async {
    await _client.send(
      'post',
      'api/user/verify-registration',
      body: body.toJson(),
    );
  }

  /// Generate a new Application Registration Verification Id to be used with
  /// the Verify Registration API. This API will not attempt to send an email to
  /// the User. This API may be used to collect the verificationId for use with
  /// a third party system. OR Re-sends the application registration
  /// verification email to the user.
  Future<VerifyRegistrationResponse> updateUserVerifyRegistration(
      {String? email,
      String? sendVerifyPasswordEmail,
      String? applicationId}) async {
    return VerifyRegistrationResponse.fromJson(await _client.send(
      'put',
      'api/user/verify-registration',
      queryParameters: {
        if (email != null) 'email': email,
        if (sendVerifyPasswordEmail != null)
          'sendVerifyPasswordEmail': sendVerifyPasswordEmail,
        if (applicationId != null) 'applicationId': applicationId,
      },
    ));
  }

  /// Send a passwordless authentication code in an email to complete login.
  Future<void> sendPasswordlessCodeWithId(
      {required PasswordlessSendRequest body}) async {
    await _client.send(
      'post',
      'api/passwordless/send',
      body: body.toJson(),
    );
  }

  /// Creates a connector.  You can optionally specify an Id for the connector,
  /// if not provided one will be generated.
  Future<ConnectorResponse> createConnectorWithId(
      {required String connectorId, required ConnectorRequest body}) async {
    return ConnectorResponse.fromJson(await _client.send(
      'post',
      'api/connector/{connectorId}',
      pathParameters: {
        'connectorId': connectorId,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves the connector with the given Id.
  Future<ConnectorResponse> retrieveConnectorWithId(String connectorId) async {
    return ConnectorResponse.fromJson(await _client.send(
      'get',
      'api/connector/{connectorId}',
      pathParameters: {
        'connectorId': connectorId,
      },
    ));
  }

  /// Deletes the connector for the given Id.
  Future<void> deleteConnectorWithId(String connectorId) async {
    await _client.send(
      'delete',
      'api/connector/{connectorId}',
      pathParameters: {
        'connectorId': connectorId,
      },
    );
  }

  /// Updates the connector with the given Id.
  Future<ConnectorResponse> updateConnectorWithId(
      {required String connectorId, required ConnectorRequest body}) async {
    return ConnectorResponse.fromJson(await _client.send(
      'put',
      'api/connector/{connectorId}',
      pathParameters: {
        'connectorId': connectorId,
      },
      body: body.toJson(),
    ));
  }

  /// Creates a connector.  You can optionally specify an Id for the connector,
  /// if not provided one will be generated.
  Future<ConnectorResponse> createConnector(
      {required ConnectorRequest body}) async {
    return ConnectorResponse.fromJson(await _client.send(
      'post',
      'api/connector',
      body: body.toJson(),
    ));
  }

  /// Reactivates the user action with the given Id. OR Updates the user action
  /// with the given Id.
  Future<UserActionResponse> updateUserActionWithId(
      {String? reactivate,
      required String userActionId,
      String? tenantIdScope,
      required UserActionRequest body}) async {
    return UserActionResponse.fromJson(await _client.send(
      'put',
      'api/user-action/{userActionId}',
      pathParameters: {
        'userActionId': userActionId,
      },
      queryParameters: {
        if (reactivate != null) 'reactivate': reactivate,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Deactivates the user action with the given Id. OR Deletes the user action
  /// for the given Id. This permanently deletes the user action and also any
  /// history and logs of the action being applied to any users.
  Future<void> deleteUserActionWithId(
      {required String userActionId,
      String? tenantIdScope,
      String? hardDelete}) async {
    await _client.send(
      'delete',
      'api/user-action/{userActionId}',
      pathParameters: {
        'userActionId': userActionId,
      },
      queryParameters: {
        if (hardDelete != null) 'hardDelete': hardDelete,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    );
  }

  /// Retrieves the user action for the given Id. If you pass in null for the
  /// id, this will return all the user actions.
  Future<UserActionResponse> retrieveUserActionWithId(
      {required String userActionId, String? tenantIdScope}) async {
    return UserActionResponse.fromJson(await _client.send(
      'get',
      'api/user-action/{userActionId}',
      pathParameters: {
        'userActionId': userActionId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Creates a user action. This action cannot be taken on a user until this
  /// call successfully returns. Anytime after that the user action can be
  /// applied to any user.
  Future<UserActionResponse> createUserActionWithId(
      {required String userActionId,
      String? tenantIdScope,
      required UserActionRequest body}) async {
    return UserActionResponse.fromJson(await _client.send(
      'post',
      'api/user-action/{userActionId}',
      pathParameters: {
        'userActionId': userActionId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieve a user_code that is part of an in-progress Device Authorization
  /// Grant.  This API is useful if you want to build your own login workflow to
  /// complete a device grant.  This request will require an API key. OR
  /// Retrieve a user_code that is part of an in-progress Device Authorization
  /// Grant.  This API is useful if you want to build your own login workflow to
  /// complete a device grant.
  Future<void> retrieveDeviceUserCode() async {
    await _client.send(
      'get',
      'oauth2/device/user-code',
    );
  }

  /// Creates an IP Access Control List. You can optionally specify an Id on
  /// this create request, if one is not provided one will be generated.
  Future<IPAccessControlListResponse> createIPAccessControlListWithId(
      {required String accessControlListId,
      required IPAccessControlListRequest body}) async {
    return IPAccessControlListResponse.fromJson(await _client.send(
      'post',
      'api/ip-acl/{accessControlListId}',
      pathParameters: {
        'accessControlListId': accessControlListId,
      },
      body: body.toJson(),
    ));
  }

  /// Updates the IP Access Control List with the given Id.
  Future<IPAccessControlListResponse> updateIPAccessControlListWithId(
      {required String accessControlListId,
      required IPAccessControlListRequest body}) async {
    return IPAccessControlListResponse.fromJson(await _client.send(
      'put',
      'api/ip-acl/{accessControlListId}',
      pathParameters: {
        'accessControlListId': accessControlListId,
      },
      body: body.toJson(),
    ));
  }

  /// Creates an IP Access Control List. You can optionally specify an Id on
  /// this create request, if one is not provided one will be generated.
  Future<IPAccessControlListResponse> createIPAccessControlList(
      {required IPAccessControlListRequest body}) async {
    return IPAccessControlListResponse.fromJson(await _client.send(
      'post',
      'api/ip-acl',
      body: body.toJson(),
    ));
  }

  /// Sends out an email to a parent that they need to register and create a
  /// family or need to log in and add a child to their existing family.
  Future<void> sendFamilyRequestEmailWithId(
      {required FamilyEmailRequest body}) async {
    await _client.send(
      'post',
      'api/user/family/request',
      body: body.toJson(),
    );
  }

  /// Retrieves all the actions for the user with the given Id that are
  /// currently preventing the User from logging in. OR Retrieves all the
  /// actions for the user with the given Id. This will return all time based
  /// actions that are active, and inactive as well as non-time based actions.
  /// OR Retrieves all the actions for the user with the given Id that are
  /// currently active. An active action means one that is time based and has
  /// not been canceled, and has not ended. OR Retrieves all the actions for the
  /// user with the given Id that are currently inactive. An inactive action
  /// means one that is time based and has been canceled or has expired, or is
  /// not time based.
  Future<ActionResponse> retrieveUserActioning(
      {String? userId, String? preventingLogin, String? active}) async {
    return ActionResponse.fromJson(await _client.send(
      'get',
      'api/user/action',
      queryParameters: {
        if (userId != null) 'userId': userId,
        if (preventingLogin != null) 'preventingLogin': preventingLogin,
        if (active != null) 'active': active,
      },
    ));
  }

  /// Takes an action on a user. The user being actioned is called the
  /// "actionee" and the user taking the action is called the "actioner". Both
  /// user ids are required in the request object.
  Future<ActionResponse> actionUserWithId({required ActionRequest body}) async {
    return ActionResponse.fromJson(await _client.send(
      'post',
      'api/user/action',
      body: body.toJson(),
    ));
  }

  /// Creates a webhook. You can optionally specify an Id for the webhook, if
  /// not provided one will be generated.
  Future<WebhookResponse> createWebhookWithId(
      {required String webhookId, required WebhookRequest body}) async {
    return WebhookResponse.fromJson(await _client.send(
      'post',
      'api/webhook/{webhookId}',
      pathParameters: {
        'webhookId': webhookId,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the webhook for the given Id.
  Future<void> deleteWebhookWithId(String webhookId) async {
    await _client.send(
      'delete',
      'api/webhook/{webhookId}',
      pathParameters: {
        'webhookId': webhookId,
      },
    );
  }

  /// Updates the webhook with the given Id.
  Future<WebhookResponse> updateWebhookWithId(
      {required String webhookId, required WebhookRequest body}) async {
    return WebhookResponse.fromJson(await _client.send(
      'put',
      'api/webhook/{webhookId}',
      pathParameters: {
        'webhookId': webhookId,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves the webhook for the given Id. If you pass in null for the id,
  /// this will return all the webhooks.
  Future<WebhookResponse> retrieveWebhookWithId(String webhookId) async {
    return WebhookResponse.fromJson(await _client.send(
      'get',
      'api/webhook/{webhookId}',
      pathParameters: {
        'webhookId': webhookId,
      },
    ));
  }

  /// Creates a webhook. You can optionally specify an Id for the webhook, if
  /// not provided one will be generated.
  Future<WebhookResponse> createWebhook({required WebhookRequest body}) async {
    return WebhookResponse.fromJson(await _client.send(
      'post',
      'api/webhook',
      body: body.toJson(),
    ));
  }

  /// Retrieves the webhook for the given Id. If you pass in null for the id,
  /// this will return all the webhooks.
  Future<WebhookResponse> retrieveWebhook() async {
    return WebhookResponse.fromJson(await _client.send(
      'get',
      'api/webhook',
    ));
  }

  /// Deletes the lambda for the given Id.
  Future<void> deleteLambdaWithId(String lambdaId) async {
    await _client.send(
      'delete',
      'api/lambda/{lambdaId}',
      pathParameters: {
        'lambdaId': lambdaId,
      },
    );
  }

  /// Creates a Lambda. You can optionally specify an Id for the lambda, if not
  /// provided one will be generated.
  Future<LambdaResponse> createLambdaWithId(
      {required String lambdaId, required LambdaRequest body}) async {
    return LambdaResponse.fromJson(await _client.send(
      'post',
      'api/lambda/{lambdaId}',
      pathParameters: {
        'lambdaId': lambdaId,
      },
      body: body.toJson(),
    ));
  }

  /// Updates the lambda with the given Id.
  Future<LambdaResponse> updateLambdaWithId(
      {required String lambdaId, required LambdaRequest body}) async {
    return LambdaResponse.fromJson(await _client.send(
      'put',
      'api/lambda/{lambdaId}',
      pathParameters: {
        'lambdaId': lambdaId,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves the lambda for the given Id.
  Future<LambdaResponse> retrieveLambdaWithId(String lambdaId) async {
    return LambdaResponse.fromJson(await _client.send(
      'get',
      'api/lambda/{lambdaId}',
      pathParameters: {
        'lambdaId': lambdaId,
      },
    ));
  }

  /// Retrieves the user for the given username. OR Retrieves the user by a
  /// verificationId. The intended use of this API is to retrieve a user after
  /// the forgot password workflow has been initiated and you may not know the
  /// user's email or username. OR Retrieves the user by a change password Id.
  /// The intended use of this API is to retrieve a user after the forgot
  /// password workflow has been initiated and you may not know the user's email
  /// or username. OR Retrieves the user for the given Id. This method does not
  /// use an API key, instead it uses a JSON Web Token (JWT) for authentication.
  /// OR Retrieves the user for the given email. OR Retrieves the user for the
  /// loginId. The loginId can be either the username or the email.
  Future<UserResponse> retrieveUser(
      {String? username,
      String? tenantIdScope,
      String? verificationId,
      String? changePasswordId,
      String? email,
      String? loginId}) async {
    return UserResponse.fromJson(await _client.send(
      'get',
      'api/user',
      queryParameters: {
        if (username != null) 'username': username,
        if (verificationId != null) 'verificationId': verificationId,
        if (changePasswordId != null) 'changePasswordId': changePasswordId,
        if (email != null) 'email': email,
        if (loginId != null) 'loginId': loginId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Creates a user. You can optionally specify an Id for the user, if not
  /// provided one will be generated.
  Future<UserResponse> createUser(
      {String? tenantIdScope, required UserRequest body}) async {
    return UserResponse.fromJson(await _client.send(
      'post',
      'api/user',
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Start a passwordless login request by generating a passwordless code. This
  /// code can be sent to the User using the Send Passwordless Code API or using
  /// a mechanism outside of FusionAuth. The passwordless login is completed by
  /// using the Passwordless Login API with this code.
  Future<PasswordlessStartResponse> startPasswordlessLoginWithId(
      {required PasswordlessStartRequest body}) async {
    return PasswordlessStartResponse.fromJson(await _client.send(
      'post',
      'api/passwordless/start',
      body: body.toJson(),
    ));
  }

  /// Creates a new role for an application. You must specify the Id of the
  /// application you are creating the role for. You can optionally specify an
  /// Id for the role inside the ApplicationRole object itself, if not provided
  /// one will be generated.
  Future<ApplicationResponse> createApplicationRoleWithId(
      {required String applicationId,
      required String roleId,
      String? tenantIdScope,
      required ApplicationRequest body}) async {
    return ApplicationResponse.fromJson(await _client.send(
      'post',
      'api/application/{applicationId}/role/{roleId}',
      pathParameters: {
        'applicationId': applicationId,
        'roleId': roleId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Hard deletes an application role. This is a dangerous operation and should
  /// not be used in most circumstances. This permanently removes the given role
  /// from all users that had it.
  Future<void> deleteApplicationRoleWithId(
      {required String applicationId,
      required String roleId,
      String? tenantIdScope}) async {
    await _client.send(
      'delete',
      'api/application/{applicationId}/role/{roleId}',
      pathParameters: {
        'applicationId': applicationId,
        'roleId': roleId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    );
  }

  /// Updates the application role with the given Id for the application.
  Future<ApplicationResponse> updateApplicationRoleWithId(
      {required String applicationId,
      required String roleId,
      String? tenantIdScope,
      required ApplicationRequest body}) async {
    return ApplicationResponse.fromJson(await _client.send(
      'put',
      'api/application/{applicationId}/role/{roleId}',
      pathParameters: {
        'applicationId': applicationId,
        'roleId': roleId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Creates a new role for an application. You must specify the Id of the
  /// application you are creating the role for. You can optionally specify an
  /// Id for the role inside the ApplicationRole object itself, if not provided
  /// one will be generated.
  Future<ApplicationResponse> createApplicationRole(
      {required String applicationId,
      String? tenantIdScope,
      required ApplicationRequest body}) async {
    return ApplicationResponse.fromJson(await _client.send(
      'post',
      'api/application/{applicationId}/role',
      pathParameters: {
        'applicationId': applicationId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves a custom OAuth scope.
  Future<ApplicationOAuthScopeResponse> retrieveoAuthScopeWithId(
      {required String applicationId,
      required String scopeId,
      String? tenantIdScope}) async {
    return ApplicationOAuthScopeResponse.fromJson(await _client.send(
      'get',
      'api/application/{applicationId}/scope/{scopeId}',
      pathParameters: {
        'applicationId': applicationId,
        'scopeId': scopeId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Hard deletes a custom OAuth scope. OAuth workflows that are still
  /// requesting the deleted OAuth scope may fail depending on the application's
  /// unknown scope policy.
  Future<void> deleteoAuthScopeWithId(
      {required String applicationId,
      required String scopeId,
      String? tenantIdScope}) async {
    await _client.send(
      'delete',
      'api/application/{applicationId}/scope/{scopeId}',
      pathParameters: {
        'applicationId': applicationId,
        'scopeId': scopeId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    );
  }

  /// Updates the OAuth scope with the given Id for the application.
  Future<ApplicationOAuthScopeResponse> updateOAuthScopeWithId(
      {required String applicationId,
      required String scopeId,
      String? tenantIdScope,
      required ApplicationOAuthScopeRequest body}) async {
    return ApplicationOAuthScopeResponse.fromJson(await _client.send(
      'put',
      'api/application/{applicationId}/scope/{scopeId}',
      pathParameters: {
        'applicationId': applicationId,
        'scopeId': scopeId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Creates a new custom OAuth scope for an application. You must specify the
  /// Id of the application you are creating the scope for. You can optionally
  /// specify an Id for the OAuth scope on the URL, if not provided one will be
  /// generated.
  Future<ApplicationOAuthScopeResponse> createoAuthScopeWithId(
      {required String applicationId,
      required String scopeId,
      String? tenantIdScope,
      required ApplicationOAuthScopeRequest body}) async {
    return ApplicationOAuthScopeResponse.fromJson(await _client.send(
      'post',
      'api/application/{applicationId}/scope/{scopeId}',
      pathParameters: {
        'applicationId': applicationId,
        'scopeId': scopeId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// The Logout API is intended to be used to remove the refresh token and
  /// access token cookies if they exist on the client and revoke the refresh
  /// token stored. This API does nothing if the request does not contain an
  /// access token or refresh token cookies. OR The Logout API is intended to be
  /// used to remove the refresh token and access token cookies if they exist on
  /// the client and revoke the refresh token stored. This API takes the refresh
  /// token in the JSON body.
  Future<void> createLogout(
      {String? global,
      String? refreshToken,
      required LogoutRequest body}) async {
    await _client.send(
      'post',
      'api/logout',
      queryParameters: {
        if (global != null) 'global': global,
        if (refreshToken != null) 'refreshToken': refreshToken,
      },
      body: body.toJson(),
    );
  }

  /// Creates an API key. You can optionally specify a unique Id for the key, if
  /// not provided one will be generated. an API key can only be created with
  /// equal or lesser authority. An API key cannot create another API key unless
  /// it is granted  to that API key.  If an API key is locked to a tenant, it
  /// can only create API Keys for that same tenant. OR Updates an
  /// authentication API key by given id
  Future<APIKeyResponse> createApiKeyWithId(
      {required String keyId, required APIKeyRequest body}) async {
    return APIKeyResponse.fromJson(await _client.send(
      'post',
      'api/api-key/{keyId}',
      pathParameters: {
        'keyId': keyId,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the API key for the given Id.
  Future<void> deleteAPIKeyWithId(String keyId) async {
    await _client.send(
      'delete',
      'api/api-key/{keyId}',
      pathParameters: {
        'keyId': keyId,
      },
    );
  }

  /// Retrieves an authentication API key for the given id
  Future<APIKeyResponse> retrieveAPIKeyWithId(String keyId) async {
    return APIKeyResponse.fromJson(await _client.send(
      'get',
      'api/api-key/{keyId}',
      pathParameters: {
        'keyId': keyId,
      },
    ));
  }

  /// Creates a Lambda. You can optionally specify an Id for the lambda, if not
  /// provided one will be generated.
  Future<LambdaResponse> createLambda({required LambdaRequest body}) async {
    return LambdaResponse.fromJson(await _client.send(
      'post',
      'api/lambda',
      body: body.toJson(),
    ));
  }

  /// Retrieves all the lambdas for the provided type.
  Future<LambdaResponse> retrieveLambdasByTypeWithId({String? type}) async {
    return LambdaResponse.fromJson(await _client.send(
      'get',
      'api/lambda',
      queryParameters: {
        if (type != null) 'type': type,
      },
    ));
  }

  /// Creates a messenger.  You can optionally specify an Id for the messenger,
  /// if not provided one will be generated.
  Future<MessengerResponse> createMessengerWithId(
      {required String messengerId, required MessengerRequest body}) async {
    return MessengerResponse.fromJson(await _client.send(
      'post',
      'api/messenger/{messengerId}',
      pathParameters: {
        'messengerId': messengerId,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the messenger for the given Id.
  Future<void> deleteMessengerWithId(String messengerId) async {
    await _client.send(
      'delete',
      'api/messenger/{messengerId}',
      pathParameters: {
        'messengerId': messengerId,
      },
    );
  }

  /// Retrieves the messenger with the given Id.
  Future<MessengerResponse> retrieveMessengerWithId(String messengerId) async {
    return MessengerResponse.fromJson(await _client.send(
      'get',
      'api/messenger/{messengerId}',
      pathParameters: {
        'messengerId': messengerId,
      },
    ));
  }

  /// Updates the messenger with the given Id.
  Future<MessengerResponse> updateMessengerWithId(
      {required String messengerId, required MessengerRequest body}) async {
    return MessengerResponse.fromJson(await _client.send(
      'put',
      'api/messenger/{messengerId}',
      pathParameters: {
        'messengerId': messengerId,
      },
      body: body.toJson(),
    ));
  }

  /// Creates a messenger.  You can optionally specify an Id for the messenger,
  /// if not provided one will be generated.
  Future<MessengerResponse> createMessenger(
      {required MessengerRequest body}) async {
    return MessengerResponse.fromJson(await _client.send(
      'post',
      'api/messenger',
      body: body.toJson(),
    ));
  }

  /// Deletes the Entity Type for the given Id.
  Future<void> deleteEntityTypeWithId(String entityTypeId) async {
    await _client.send(
      'delete',
      'api/entity/type/{entityTypeId}',
      pathParameters: {
        'entityTypeId': entityTypeId,
      },
    );
  }

  /// Updates the Entity Type with the given Id.
  Future<EntityTypeResponse> updateEntityTypeWithId(
      {required String entityTypeId, required EntityTypeRequest body}) async {
    return EntityTypeResponse.fromJson(await _client.send(
      'put',
      'api/entity/type/{entityTypeId}',
      pathParameters: {
        'entityTypeId': entityTypeId,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves the Entity Type for the given Id.
  Future<EntityTypeResponse> retrieveEntityTypeWithId(
      String entityTypeId) async {
    return EntityTypeResponse.fromJson(await _client.send(
      'get',
      'api/entity/type/{entityTypeId}',
      pathParameters: {
        'entityTypeId': entityTypeId,
      },
    ));
  }

  /// Creates a Entity Type. You can optionally specify an Id for the Entity
  /// Type, if not provided one will be generated.
  Future<EntityTypeResponse> createEntityTypeWithId(
      {required String entityTypeId, required EntityTypeRequest body}) async {
    return EntityTypeResponse.fromJson(await _client.send(
      'post',
      'api/entity/type/{entityTypeId}',
      pathParameters: {
        'entityTypeId': entityTypeId,
      },
      body: body.toJson(),
    ));
  }

  /// Link an external user from a 3rd party identity provider to a FusionAuth
  /// user.
  Future<IdentityProviderLinkResponse> createUserLinkWithId(
      {required IdentityProviderLinkRequest body}) async {
    return IdentityProviderLinkResponse.fromJson(await _client.send(
      'post',
      'api/identity-provider/link',
      body: body.toJson(),
    ));
  }

  /// Remove an existing link that has been made from a 3rd party identity
  /// provider to a FusionAuth user.
  Future<IdentityProviderLinkResponse> deleteUserLinkWithId(
      {String? identityProviderId,
      String? identityProviderUserId,
      String? userId}) async {
    return IdentityProviderLinkResponse.fromJson(await _client.send(
      'delete',
      'api/identity-provider/link',
      queryParameters: {
        if (identityProviderId != null)
          'identityProviderId': identityProviderId,
        if (identityProviderUserId != null)
          'identityProviderUserId': identityProviderUserId,
        if (userId != null) 'userId': userId,
      },
    ));
  }

  /// Retrieve a single Identity Provider user (link). OR Retrieve all Identity
  /// Provider users (links) for the user. Specify the optional
  /// identityProviderId to retrieve links for a particular IdP.
  Future<IdentityProviderLinkResponse> retrieveIdentityProviderLink(
      {String? identityProviderId,
      String? identityProviderUserId,
      String? userId}) async {
    return IdentityProviderLinkResponse.fromJson(await _client.send(
      'get',
      'api/identity-provider/link',
      queryParameters: {
        if (identityProviderId != null)
          'identityProviderId': identityProviderId,
        if (identityProviderUserId != null)
          'identityProviderUserId': identityProviderUserId,
        if (userId != null) 'userId': userId,
      },
    ));
  }

  /// Creates a user consent type. You can optionally specify an Id for the
  /// consent type, if not provided one will be generated.
  Future<ConsentResponse> createConsentWithId(
      {required String consentId,
      String? tenantIdScope,
      required ConsentRequest body}) async {
    return ConsentResponse.fromJson(await _client.send(
      'post',
      'api/consent/{consentId}',
      pathParameters: {
        'consentId': consentId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the consent for the given Id.
  Future<void> deleteConsentWithId(
      {required String consentId, String? tenantIdScope}) async {
    await _client.send(
      'delete',
      'api/consent/{consentId}',
      pathParameters: {
        'consentId': consentId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    );
  }

  /// Updates the consent with the given Id.
  Future<ConsentResponse> updateConsentWithId(
      {required String consentId,
      String? tenantIdScope,
      required ConsentRequest body}) async {
    return ConsentResponse.fromJson(await _client.send(
      'put',
      'api/consent/{consentId}',
      pathParameters: {
        'consentId': consentId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves the Consent for the given Id.
  Future<ConsentResponse> retrieveConsentWithId(
      {required String consentId, String? tenantIdScope}) async {
    return ConsentResponse.fromJson(await _client.send(
      'get',
      'api/consent/{consentId}',
      pathParameters: {
        'consentId': consentId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Creates a form.  You can optionally specify an Id for the form, if not
  /// provided one will be generated.
  Future<FormResponse> createFormWithId(
      {required String formId, required FormRequest body}) async {
    return FormResponse.fromJson(await _client.send(
      'post',
      'api/form/{formId}',
      pathParameters: {
        'formId': formId,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the form for the given Id.
  Future<void> deleteFormWithId(String formId) async {
    await _client.send(
      'delete',
      'api/form/{formId}',
      pathParameters: {
        'formId': formId,
      },
    );
  }

  /// Updates the form with the given Id.
  Future<FormResponse> updateFormWithId(
      {required String formId, required FormRequest body}) async {
    return FormResponse.fromJson(await _client.send(
      'put',
      'api/form/{formId}',
      pathParameters: {
        'formId': formId,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves the form with the given Id.
  Future<FormResponse> retrieveFormWithId(String formId) async {
    return FormResponse.fromJson(await _client.send(
      'get',
      'api/form/{formId}',
      pathParameters: {
        'formId': formId,
      },
    ));
  }

  /// Creates a form.  You can optionally specify an Id for the form, if not
  /// provided one will be generated.
  Future<FormResponse> createForm({required FormRequest body}) async {
    return FormResponse.fromJson(await _client.send(
      'post',
      'api/form',
      body: body.toJson(),
    ));
  }

  /// Cancels the user action.
  Future<ActionResponse> cancelActionWithId(
      {required String actionId, required ActionRequest body}) async {
    return ActionResponse.fromJson(await _client.send(
      'delete',
      'api/user/action/{actionId}',
      pathParameters: {
        'actionId': actionId,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves a single action log (the log of a user action that was taken on
  /// a user previously) for the given Id.
  Future<ActionResponse> retrieveActionWithId(String actionId) async {
    return ActionResponse.fromJson(await _client.send(
      'get',
      'api/user/action/{actionId}',
      pathParameters: {
        'actionId': actionId,
      },
    ));
  }

  /// Modifies a temporal user action by changing the expiration of the action
  /// and optionally adding a comment to the action.
  Future<ActionResponse> modifyActionWithId(
      {required String actionId, required ActionRequest body}) async {
    return ActionResponse.fromJson(await _client.send(
      'put',
      'api/user/action/{actionId}',
      pathParameters: {
        'actionId': actionId,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves all WebAuthn credentials for the given user.
  Future<WebAuthnCredentialResponse> retrieveWebAuthnCredentialsForUserWithId(
      {String? userId}) async {
    return WebAuthnCredentialResponse.fromJson(await _client.send(
      'get',
      'api/webauthn',
      queryParameters: {
        if (userId != null) 'userId': userId,
      },
    ));
  }

  /// Revoke all refresh tokens that belong to a user by user Id. OR Revoke all
  /// refresh tokens that belong to a user by user Id for a specific application
  /// by applicationId. OR Revoke all refresh tokens that belong to an
  /// application by applicationId. OR Revokes refresh tokens using the
  /// information in the JSON body. The handling for this method is the same as
  /// the revokeRefreshToken method and is based on the information you provide
  /// in the RefreshDeleteRequest object. See that method for additional
  /// information. OR Revokes a single refresh token by using the actual refresh
  /// token value. This refresh token value is sensitive, so  be careful with
  /// this API request. OR Revokes refresh tokens.  Usage examples:   - Delete a
  /// single refresh token, pass in only the token.
  /// revokeRefreshToken(token)    - Delete all refresh tokens for a user, pass
  /// in only the userId.       revokeRefreshToken(null, userId)    - Delete all
  /// refresh tokens for a user for a specific application, pass in both the
  /// userId and the applicationId.       revokeRefreshToken(null, userId,
  /// applicationId)    - Delete all refresh tokens for an application
  /// revokeRefreshToken(null, null, applicationId)  Note: `null` may be handled
  /// differently depending upon the programming language.  See also: (method
  /// names may vary by language... but you'll figure it out)   -
  /// revokeRefreshTokenById  - revokeRefreshTokenByToken  -
  /// revokeRefreshTokensByUserId  - revokeRefreshTokensByApplicationId  -
  /// revokeRefreshTokensByUserIdForApplication
  Future<void> deleteJwtRefresh(
      {String? userId,
      String? applicationId,
      String? token,
      required RefreshTokenRevokeRequest body}) async {
    await _client.send(
      'delete',
      'api/jwt/refresh',
      queryParameters: {
        if (userId != null) 'userId': userId,
        if (applicationId != null) 'applicationId': applicationId,
        if (token != null) 'token': token,
      },
      body: body.toJson(),
    );
  }

  /// Exchange a refresh token for a new JWT.
  Future<JWTRefreshResponse> exchangeRefreshTokenForJWTWithId(
      {required RefreshRequest body}) async {
    return JWTRefreshResponse.fromJson(await _client.send(
      'post',
      'api/jwt/refresh',
      body: body.toJson(),
    ));
  }

  /// Retrieves the refresh tokens that belong to the user with the given Id.
  Future<RefreshTokenResponse> retrieveRefreshTokensWithId(
      {String? userId}) async {
    return RefreshTokenResponse.fromJson(await _client.send(
      'get',
      'api/jwt/refresh',
      queryParameters: {
        if (userId != null) 'userId': userId,
      },
    ));
  }

  /// Searches group members with the specified criteria and pagination.
  Future<GroupMemberSearchResponse> searchGroupMembersWithId(
      {required GroupMemberSearchRequest body}) async {
    return GroupMemberSearchResponse.fromJson(await _client.send(
      'post',
      'api/group/member/search',
      body: body.toJson(),
    ));
  }

  /// Retrieves the monthly active user report between the two instants. If you
  /// specify an application id, it will only return the monthly active counts
  /// for that application.
  Future<MonthlyActiveUserReportResponse> retrieveMonthlyActiveReportWithId(
      {String? applicationId, String? start, String? end}) async {
    return MonthlyActiveUserReportResponse.fromJson(await _client.send(
      'get',
      'api/report/monthly-active-user',
      queryParameters: {
        if (applicationId != null) 'applicationId': applicationId,
        if (start != null) 'start': start,
        if (end != null) 'end': end,
      },
    ));
  }

  /// Inspect an access token issued as the result of the User based grant such
  /// as the Authorization Code Grant, Implicit Grant, the User Credentials
  /// Grant or the Refresh Grant. OR Inspect an access token issued as the
  /// result of the Client Credentials Grant.
  Future<IntrospectResponse> createIntrospect() async {
    return IntrospectResponse.fromJson(await _client.send(
      'post',
      'oauth2/introspect',
    ));
  }

  /// Retrieves the users for the given search criteria and pagination.
  Future<SearchResponse> searchUsersByQueryWithId(
      {required SearchRequest body}) async {
    return SearchResponse.fromJson(await _client.send(
      'post',
      'api/user/search',
      body: body.toJson(),
    ));
  }

  /// Retrieves the users for the given ids. If any Id is invalid, it is
  /// ignored.
  Future<SearchResponse> searchUsersByIdsWithId({String? ids}) async {
    return SearchResponse.fromJson(await _client.send(
      'get',
      'api/user/search',
      queryParameters: {
        if (ids != null) 'ids': ids,
      },
    ));
  }

  /// Retrieves the IP Access Control List with the given Id.
  Future<IPAccessControlListResponse> retrieveIPAccessControlListWithId(
      String ipAccessControlListId) async {
    return IPAccessControlListResponse.fromJson(await _client.send(
      'get',
      'api/ip-acl/{ipAccessControlListId}',
      pathParameters: {
        'ipAccessControlListId': ipAccessControlListId,
      },
    ));
  }

  /// Deletes the IP Access Control List for the given Id.
  Future<void> deleteIPAccessControlListWithId(
      String ipAccessControlListId) async {
    await _client.send(
      'delete',
      'api/ip-acl/{ipAccessControlListId}',
      pathParameters: {
        'ipAccessControlListId': ipAccessControlListId,
      },
    );
  }

  /// Reactivates the user with the given Id. OR Updates the user with the given
  /// Id.
  Future<UserResponse> updateUserWithId(
      {String? reactivate,
      required String userId,
      String? tenantIdScope,
      required UserRequest body}) async {
    return UserResponse.fromJson(await _client.send(
      'put',
      'api/user/{userId}',
      pathParameters: {
        'userId': userId,
      },
      queryParameters: {
        if (reactivate != null) 'reactivate': reactivate,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the user based on the given request (sent to the API as JSON).
  /// This permanently deletes all information, metrics, reports and data
  /// associated with the user. OR Deletes the user for the given Id. This
  /// permanently deletes all information, metrics, reports and data associated
  /// with the user. OR Deactivates the user with the given Id.
  Future<void> deleteUserWithId(
      {required String userId,
      String? tenantIdScope,
      String? hardDelete,
      required UserDeleteSingleRequest body}) async {
    await _client.send(
      'delete',
      'api/user/{userId}',
      pathParameters: {
        'userId': userId,
      },
      queryParameters: {
        if (hardDelete != null) 'hardDelete': hardDelete,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    );
  }

  /// Creates a user. You can optionally specify an Id for the user, if not
  /// provided one will be generated.
  Future<UserResponse> createUserWithId(
      {required String userId,
      String? tenantIdScope,
      required UserRequest body}) async {
    return UserResponse.fromJson(await _client.send(
      'post',
      'api/user/{userId}',
      pathParameters: {
        'userId': userId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves the user for the given Id.
  Future<UserResponse> retrieveUserWithId(
      {required String userId, String? tenantIdScope}) async {
    return UserResponse.fromJson(await _client.send(
      'get',
      'api/user/{userId}',
      pathParameters: {
        'userId': userId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Validates the end-user provided user_code from the user-interaction of the
  /// Device Authorization Grant. If you build your own activation form you
  /// should validate the user provided code prior to beginning the
  /// Authorization grant.
  Future<void> validateDeviceWithId(
      {String? userCode, String? clientId}) async {
    await _client.send(
      'get',
      'oauth2/device/validate',
      queryParameters: {
        if (userCode != null) 'user_code': userCode,
        if (clientId != null) 'client_id': clientId,
      },
    );
  }

  /// Enable two-factor authentication for a user.
  Future<TwoFactorResponse> enableTwoFactorWithId(
      {required String userId, required TwoFactorRequest body}) async {
    return TwoFactorResponse.fromJson(await _client.send(
      'post',
      'api/user/two-factor/{userId}',
      pathParameters: {
        'userId': userId,
      },
      body: body.toJson(),
    ));
  }

  /// Disable two-factor authentication for a user using a JSON body rather than
  /// URL parameters. OR Disable two-factor authentication for a user.
  Future<void> deleteUserTwoFactorWithId(
      {required String userId,
      String? methodId,
      String? code,
      required TwoFactorDisableRequest body}) async {
    await _client.send(
      'delete',
      'api/user/two-factor/{userId}',
      pathParameters: {
        'userId': userId,
      },
      queryParameters: {
        if (methodId != null) 'methodId': methodId,
        if (code != null) 'code': code,
      },
      body: body.toJson(),
    );
  }

  /// Send a Two Factor authentication code to allow the completion of Two
  /// Factor authentication.
  Future<void> sendTwoFactorCodeForLoginUsingMethodWithId(
      {required String twoFactorId, required TwoFactorSendRequest body}) async {
    await _client.send(
      'post',
      'api/two-factor/send/{twoFactorId}',
      pathParameters: {
        'twoFactorId': twoFactorId,
      },
      body: body.toJson(),
    );
  }

  /// Searches applications with the specified criteria and pagination.
  Future<ApplicationSearchResponse> searchApplicationsWithId(
      {required ApplicationSearchRequest body}) async {
    return ApplicationSearchResponse.fromJson(await _client.send(
      'post',
      'api/application/search',
      body: body.toJson(),
    ));
  }

  /// Hard deletes an application. This is a dangerous operation and should not
  /// be used in most circumstances. This will delete the application, any
  /// registrations for that application, metrics and reports for the
  /// application, all the roles for the application, and any other data
  /// associated with the application. This operation could take a very long
  /// time, depending on the amount of data in your database. OR Deactivates the
  /// application with the given Id.
  Future<void> deleteApplicationWithId(
      {String? hardDelete,
      required String applicationId,
      String? tenantIdScope}) async {
    await _client.send(
      'delete',
      'api/application/{applicationId}',
      pathParameters: {
        'applicationId': applicationId,
      },
      queryParameters: {
        if (hardDelete != null) 'hardDelete': hardDelete,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    );
  }

  /// Creates an application. You can optionally specify an Id for the
  /// application, if not provided one will be generated.
  Future<ApplicationResponse> createApplicationWithId(
      {required String applicationId,
      String? tenantIdScope,
      required ApplicationRequest body}) async {
    return ApplicationResponse.fromJson(await _client.send(
      'post',
      'api/application/{applicationId}',
      pathParameters: {
        'applicationId': applicationId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Updates the application with the given Id. OR Reactivates the application
  /// with the given Id.
  Future<ApplicationResponse> updateApplicationWithId(
      {required String applicationId,
      String? tenantIdScope,
      String? reactivate,
      required ApplicationRequest body}) async {
    return ApplicationResponse.fromJson(await _client.send(
      'put',
      'api/application/{applicationId}',
      pathParameters: {
        'applicationId': applicationId,
      },
      queryParameters: {
        if (reactivate != null) 'reactivate': reactivate,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves the application for the given Id or all the applications if the
  /// Id is null.
  Future<ApplicationResponse> retrieveApplicationWithId(
      {required String applicationId, String? tenantIdScope}) async {
    return ApplicationResponse.fromJson(await _client.send(
      'get',
      'api/application/{applicationId}',
      pathParameters: {
        'applicationId': applicationId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Retrieves the Entity for the given Id.
  Future<EntityResponse> retrieveEntityWithId(
      {required String entityId, String? tenantIdScope}) async {
    return EntityResponse.fromJson(await _client.send(
      'get',
      'api/entity/{entityId}',
      pathParameters: {
        'entityId': entityId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Updates the Entity with the given Id.
  Future<EntityResponse> updateEntityWithId(
      {required String entityId,
      String? tenantIdScope,
      required EntityRequest body}) async {
    return EntityResponse.fromJson(await _client.send(
      'put',
      'api/entity/{entityId}',
      pathParameters: {
        'entityId': entityId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Creates an Entity. You can optionally specify an Id for the Entity. If not
  /// provided one will be generated.
  Future<EntityResponse> createEntityWithId(
      {required String entityId,
      String? tenantIdScope,
      required EntityRequest body}) async {
    return EntityResponse.fromJson(await _client.send(
      'post',
      'api/entity/{entityId}',
      pathParameters: {
        'entityId': entityId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the Entity for the given Id.
  Future<void> deleteEntityWithId(
      {required String entityId, String? tenantIdScope}) async {
    await _client.send(
      'delete',
      'api/entity/{entityId}',
      pathParameters: {
        'entityId': entityId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    );
  }

  /// Updates the theme with the given Id.
  Future<ThemeResponse> updateThemeWithId(
      {required String themeId, required ThemeRequest body}) async {
    return ThemeResponse.fromJson(await _client.send(
      'put',
      'api/theme/{themeId}',
      pathParameters: {
        'themeId': themeId,
      },
      body: body.toJson(),
    ));
  }

  /// Creates a Theme. You can optionally specify an Id for the theme, if not
  /// provided one will be generated.
  Future<ThemeResponse> createThemeWithId(
      {required String themeId, required ThemeRequest body}) async {
    return ThemeResponse.fromJson(await _client.send(
      'post',
      'api/theme/{themeId}',
      pathParameters: {
        'themeId': themeId,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves the theme for the given Id.
  Future<ThemeResponse> retrieveThemeWithId(String themeId) async {
    return ThemeResponse.fromJson(await _client.send(
      'get',
      'api/theme/{themeId}',
      pathParameters: {
        'themeId': themeId,
      },
    ));
  }

  /// Deletes the theme for the given Id.
  Future<void> deleteThemeWithId(String themeId) async {
    await _client.send(
      'delete',
      'api/theme/{themeId}',
      pathParameters: {
        'themeId': themeId,
      },
    );
  }

  /// Searches the login records with the specified criteria and pagination.
  Future<LoginRecordSearchResponse> searchLoginRecordsWithId(
      {required LoginRecordSearchRequest body}) async {
    return LoginRecordSearchResponse.fromJson(await _client.send(
      'post',
      'api/system/login-record/search',
      body: body.toJson(),
    ));
  }

  /// Updates the user action reason with the given Id.
  Future<UserActionReasonResponse> updateUserActionReasonWithId(
      {required String userActionReasonId,
      required UserActionReasonRequest body}) async {
    return UserActionReasonResponse.fromJson(await _client.send(
      'put',
      'api/user-action-reason/{userActionReasonId}',
      pathParameters: {
        'userActionReasonId': userActionReasonId,
      },
      body: body.toJson(),
    ));
  }

  /// Creates a user reason. This user action reason cannot be used when
  /// actioning a user until this call completes successfully. Anytime after
  /// that the user action reason can be used.
  Future<UserActionReasonResponse> createUserActionReasonWithId(
      {required String userActionReasonId,
      required UserActionReasonRequest body}) async {
    return UserActionReasonResponse.fromJson(await _client.send(
      'post',
      'api/user-action-reason/{userActionReasonId}',
      pathParameters: {
        'userActionReasonId': userActionReasonId,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the user action reason for the given Id.
  Future<void> deleteUserActionReasonWithId(String userActionReasonId) async {
    await _client.send(
      'delete',
      'api/user-action-reason/{userActionReasonId}',
      pathParameters: {
        'userActionReasonId': userActionReasonId,
      },
    );
  }

  /// Retrieves the user action reason for the given Id. If you pass in null for
  /// the id, this will return all the user action reasons.
  Future<UserActionReasonResponse> retrieveUserActionReasonWithId(
      String userActionReasonId) async {
    return UserActionReasonResponse.fromJson(await _client.send(
      'get',
      'api/user-action-reason/{userActionReasonId}',
      pathParameters: {
        'userActionReasonId': userActionReasonId,
      },
    ));
  }

  /// Import a WebAuthn credential
  Future<void> importWebAuthnCredentialWithId(
      {required WebAuthnCredentialImportRequest body}) async {
    await _client.send(
      'post',
      'api/webauthn/import',
      body: body.toJson(),
    );
  }

  /// Retrieves the email template for the given Id. If you don't specify the
  /// id, this will return all the email templates.
  Future<EmailTemplateResponse> retrieveEmailTemplateWithId(
      {required String emailTemplateId, String? tenantIdScope}) async {
    return EmailTemplateResponse.fromJson(await _client.send(
      'get',
      'api/email/template/{emailTemplateId}',
      pathParameters: {
        'emailTemplateId': emailTemplateId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Deletes the email template for the given Id.
  Future<void> deleteEmailTemplateWithId(
      {required String emailTemplateId, String? tenantIdScope}) async {
    await _client.send(
      'delete',
      'api/email/template/{emailTemplateId}',
      pathParameters: {
        'emailTemplateId': emailTemplateId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    );
  }

  /// Updates the email template with the given Id.
  Future<EmailTemplateResponse> updateEmailTemplateWithId(
      {required String emailTemplateId,
      String? tenantIdScope,
      required EmailTemplateRequest body}) async {
    return EmailTemplateResponse.fromJson(await _client.send(
      'put',
      'api/email/template/{emailTemplateId}',
      pathParameters: {
        'emailTemplateId': emailTemplateId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Creates an email template. You can optionally specify an Id for the
  /// template, if not provided one will be generated.
  Future<EmailTemplateResponse> createEmailTemplateWithId(
      {required String emailTemplateId,
      String? tenantIdScope,
      required EmailTemplateRequest body}) async {
    return EmailTemplateResponse.fromJson(await _client.send(
      'post',
      'api/email/template/{emailTemplateId}',
      pathParameters: {
        'emailTemplateId': emailTemplateId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves the email template for the given Id. If you don't specify the
  /// id, this will return all the email templates.
  Future<EmailTemplateResponse> retrieveEmailTemplate(
      {String? tenantIdScope}) async {
    return EmailTemplateResponse.fromJson(await _client.send(
      'get',
      'api/email/template',
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Creates an email template. You can optionally specify an Id for the
  /// template, if not provided one will be generated.
  Future<EmailTemplateResponse> createEmailTemplate(
      {String? tenantIdScope, required EmailTemplateRequest body}) async {
    return EmailTemplateResponse.fromJson(await _client.send(
      'post',
      'api/email/template',
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves the tenant for the given Id.
  Future<TenantResponse> retrieveTenantWithId(
      {required String tenantId, String? tenantIdScope}) async {
    return TenantResponse.fromJson(await _client.send(
      'get',
      'api/tenant/{tenantId}',
      pathParameters: {
        'tenantId': tenantId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Deletes the tenant based on the given Id on the URL. This permanently
  /// deletes all information, metrics, reports and data associated with the
  /// tenant and everything under the tenant (applications, users, etc). OR
  /// Deletes the tenant for the given Id asynchronously. This method is helpful
  /// if you do not want to wait for the delete operation to complete. OR
  /// Deletes the tenant based on the given request (sent to the API as JSON).
  /// This permanently deletes all information, metrics, reports and data
  /// associated with the tenant and everything under the tenant (applications,
  /// users, etc).
  Future<void> deleteTenantWithId(
      {required String tenantId,
      String? tenantIdScope,
      String? async$,
      required TenantDeleteRequest body}) async {
    await _client.send(
      'delete',
      'api/tenant/{tenantId}',
      pathParameters: {
        'tenantId': tenantId,
      },
      queryParameters: {
        if (async$ != null) 'async': async$,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    );
  }

  /// Updates the tenant with the given Id.
  Future<TenantResponse> updateTenantWithId(
      {required String tenantId,
      String? tenantIdScope,
      required TenantRequest body}) async {
    return TenantResponse.fromJson(await _client.send(
      'put',
      'api/tenant/{tenantId}',
      pathParameters: {
        'tenantId': tenantId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Creates a tenant. You can optionally specify an Id for the tenant, if not
  /// provided one will be generated.
  Future<TenantResponse> createTenantWithId(
      {required String tenantId,
      String? tenantIdScope,
      required TenantRequest body}) async {
    return TenantResponse.fromJson(await _client.send(
      'post',
      'api/tenant/{tenantId}',
      pathParameters: {
        'tenantId': tenantId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Check to see if the user must obtain a Trust Request Id in order to
  /// complete a change password request. When a user has enabled Two-Factor
  /// authentication, before you are allowed to use the Change Password API to
  /// change your password, you must obtain a Trust Request Id by completing a
  /// Two-Factor Step-Up authentication.  An HTTP status code of 400 with a
  /// general error code of [TrustTokenRequired] indicates that a Trust Token is
  /// required to make a POST request to this API. OR Check to see if the user
  /// must obtain a Trust Token Id in order to complete a change password
  /// request. When a user has enabled Two-Factor authentication, before you are
  /// allowed to use the Change Password API to change your password, you must
  /// obtain a Trust Token by completing a Two-Factor Step-Up authentication.
  /// An HTTP status code of 400 with a general error code of
  /// [TrustTokenRequired] indicates that a Trust Token is required to make a
  /// POST request to this API.
  Future<void> retrieveUserChangePassword({String? loginId}) async {
    await _client.send(
      'get',
      'api/user/change-password',
      queryParameters: {
        if (loginId != null) 'loginId': loginId,
      },
    );
  }

  /// Changes a user's password using their identity (loginId and password).
  /// Using a loginId instead of the changePasswordId bypasses the email
  /// verification and allows a password to be changed directly without first
  /// calling the #forgotPassword method.
  Future<void> changePasswordByIdentityWithId(
      {required ChangePasswordRequest body}) async {
    await _client.send(
      'post',
      'api/user/change-password',
      body: body.toJson(),
    );
  }

  /// Deletes the key for the given Id.
  Future<void> deleteKeyWithId(String keyId) async {
    await _client.send(
      'delete',
      'api/key/{keyId}',
      pathParameters: {
        'keyId': keyId,
      },
    );
  }

  /// Retrieves the key for the given Id.
  Future<KeyResponse> retrieveKeyWithId(String keyId) async {
    return KeyResponse.fromJson(await _client.send(
      'get',
      'api/key/{keyId}',
      pathParameters: {
        'keyId': keyId,
      },
    ));
  }

  /// Updates the key with the given Id.
  Future<KeyResponse> updateKeyWithId(
      {required String keyId, required KeyRequest body}) async {
    return KeyResponse.fromJson(await _client.send(
      'put',
      'api/key/{keyId}',
      pathParameters: {
        'keyId': keyId,
      },
      body: body.toJson(),
    ));
  }

  /// Revokes a single User consent by Id.
  Future<void> revokeUserConsentWithId(String userConsentId) async {
    await _client.send(
      'delete',
      'api/user/consent/{userConsentId}',
      pathParameters: {
        'userConsentId': userConsentId,
      },
    );
  }

  /// Creates a single User consent.
  Future<UserConsentResponse> createUserConsentWithId(
      {required String userConsentId, required UserConsentRequest body}) async {
    return UserConsentResponse.fromJson(await _client.send(
      'post',
      'api/user/consent/{userConsentId}',
      pathParameters: {
        'userConsentId': userConsentId,
      },
      body: body.toJson(),
    ));
  }

  /// Updates a single User consent by Id.
  Future<UserConsentResponse> updateUserConsentWithId(
      {required String userConsentId, required UserConsentRequest body}) async {
    return UserConsentResponse.fromJson(await _client.send(
      'put',
      'api/user/consent/{userConsentId}',
      pathParameters: {
        'userConsentId': userConsentId,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieve a single User consent by Id.
  Future<UserConsentResponse> retrieveUserConsentWithId(
      String userConsentId) async {
    return UserConsentResponse.fromJson(await _client.send(
      'get',
      'api/user/consent/{userConsentId}',
      pathParameters: {
        'userConsentId': userConsentId,
      },
    ));
  }

  /// Retrieves all the families that a user belongs to.
  Future<FamilyResponse> retrieveFamiliesWithId(
      {String? userId, String? tenantIdScope}) async {
    return FamilyResponse.fromJson(await _client.send(
      'get',
      'api/user/family',
      queryParameters: {
        if (userId != null) 'userId': userId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Creates a family with the user Id in the request as the owner and sole
  /// member of the family. You can optionally specify an Id for the family, if
  /// not provided one will be generated.
  Future<FamilyResponse> createFamily(
      {String? tenantIdScope, required FamilyRequest body}) async {
    return FamilyResponse.fromJson(await _client.send(
      'post',
      'api/user/family',
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Updates the available integrations.
  Future<IntegrationResponse> updateIntegrationsWithId(
      {required IntegrationRequest body}) async {
    return IntegrationResponse.fromJson(await _client.send(
      'put',
      'api/integration',
      body: body.toJson(),
    ));
  }

  /// Creates a single User consent.
  Future<UserConsentResponse> createUserConsent(
      {required UserConsentRequest body}) async {
    return UserConsentResponse.fromJson(await _client.send(
      'post',
      'api/user/consent',
      body: body.toJson(),
    ));
  }

  /// Retrieves all the consents for a User.
  Future<UserConsentResponse> retrieveUserConsentsWithId(
      {String? userId}) async {
    return UserConsentResponse.fromJson(await _client.send(
      'get',
      'api/user/consent',
      queryParameters: {
        if (userId != null) 'userId': userId,
      },
    ));
  }

  /// Removes a user from the family with the given id.
  Future<void> removeUserFromFamilyWithId(
      {required String familyId,
      required String userId,
      String? tenantIdScope}) async {
    await _client.send(
      'delete',
      'api/user/family/{familyId}/{userId}',
      pathParameters: {
        'familyId': familyId,
        'userId': userId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    );
  }

  /// Retrieves the login report between the two instants. If you specify an
  /// application id, it will only return the login counts for that application.
  /// OR Retrieves the login report between the two instants for a particular
  /// user by Id. If you specify an application id, it will only return the
  /// login counts for that application. OR Retrieves the login report between
  /// the two instants for a particular user by login Id. If you specify an
  /// application id, it will only return the login counts for that application.
  Future<LoginReportResponse> retrieveReportLogin(
      {String? applicationId,
      String? start,
      String? end,
      String? userId,
      String? loginId}) async {
    return LoginReportResponse.fromJson(await _client.send(
      'get',
      'api/report/login',
      queryParameters: {
        if (applicationId != null) 'applicationId': applicationId,
        if (start != null) 'start': start,
        if (end != null) 'end': end,
        if (userId != null) 'userId': userId,
        if (loginId != null) 'loginId': loginId,
      },
    ));
  }

  /// Searches tenants with the specified criteria and pagination.
  Future<TenantSearchResponse> searchTenantsWithId(
      {required TenantSearchRequest body}) async {
    return TenantSearchResponse.fromJson(await _client.send(
      'post',
      'api/tenant/search',
      body: body.toJson(),
    ));
  }

  /// Updates the registration for the user with the given Id and the
  /// application defined in the request.
  Future<RegistrationResponse> updateRegistrationWithId(
      {required String userId,
      String? tenantIdScope,
      required RegistrationRequest body}) async {
    return RegistrationResponse.fromJson(await _client.send(
      'put',
      'api/user/registration/{userId}',
      pathParameters: {
        'userId': userId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Registers a user for an application. If you provide the User and the
  /// UserRegistration object on this request, it will create the user as well
  /// as register them for the application. This is called a Full Registration.
  /// However, if you only provide the UserRegistration object, then the user
  /// must already exist and they will be registered for the application. The
  /// user Id can also be provided and it will either be used to look up an
  /// existing user or it will be used for the newly created User.
  Future<RegistrationResponse> registerWithId(
      {required String userId,
      String? tenantIdScope,
      required RegistrationRequest body}) async {
    return RegistrationResponse.fromJson(await _client.send(
      'post',
      'api/user/registration/{userId}',
      pathParameters: {
        'userId': userId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Exchanges an OAuth authorization code and code_verifier for an access
  /// token. Makes a request to the Token endpoint to exchange the authorization
  /// code returned from the Authorize endpoint and a code_verifier for an
  /// access token. OR Make a Client Credentials grant request to obtain an
  /// access token. OR Exchange a Refresh Token for an Access Token. If you will
  /// be using the Refresh Token Grant, you will make a request to the Token
  /// endpoint to exchange the users refresh token for an access token. OR
  /// Exchange User Credentials for a Token. If you will be using the Resource
  /// Owner Password Credential Grant, you will make a request to the Token
  /// endpoint to exchange the users email and password for an access token. OR
  /// Exchanges an OAuth authorization code for an access token. Makes a request
  /// to the Token endpoint to exchange the authorization code returned from the
  /// Authorize endpoint for an access token.
  Future<AccessToken> createToken() async {
    return AccessToken.fromJson(await _client.send(
      'post',
      'oauth2/token',
    ));
  }

  /// Searches the IP Access Control Lists with the specified criteria and
  /// pagination.
  Future<IPAccessControlListSearchResponse> searchIPAccessControlListsWithId(
      {required IPAccessControlListSearchRequest body}) async {
    return IPAccessControlListSearchResponse.fromJson(await _client.send(
      'post',
      'api/ip-acl/search',
      body: body.toJson(),
    ));
  }

  /// Start a WebAuthn authentication ceremony by generating a new challenge for
  /// the user
  Future<WebAuthnStartResponse> startWebAuthnLoginWithId(
      {required WebAuthnStartRequest body}) async {
    return WebAuthnStartResponse.fromJson(await _client.send(
      'post',
      'api/webauthn/start',
      body: body.toJson(),
    ));
  }

  /// Retrieves the group for the given Id.
  Future<GroupResponse> retrieveGroupWithId(
      {required String groupId, String? tenantIdScope}) async {
    return GroupResponse.fromJson(await _client.send(
      'get',
      'api/group/{groupId}',
      pathParameters: {
        'groupId': groupId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Deletes the group for the given Id.
  Future<void> deleteGroupWithId(
      {required String groupId, String? tenantIdScope}) async {
    await _client.send(
      'delete',
      'api/group/{groupId}',
      pathParameters: {
        'groupId': groupId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    );
  }

  /// Creates a group. You can optionally specify an Id for the group, if not
  /// provided one will be generated.
  Future<GroupResponse> createGroupWithId(
      {required String groupId,
      String? tenantIdScope,
      required GroupRequest body}) async {
    return GroupResponse.fromJson(await _client.send(
      'post',
      'api/group/{groupId}',
      pathParameters: {
        'groupId': groupId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Updates the group with the given Id.
  Future<GroupResponse> updateGroupWithId(
      {required String groupId,
      String? tenantIdScope,
      required GroupRequest body}) async {
    return GroupResponse.fromJson(await _client.send(
      'put',
      'api/group/{groupId}',
      pathParameters: {
        'groupId': groupId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Begins the forgot password sequence, which kicks off an email to the user
  /// so that they can reset their password.
  Future<ForgotPasswordResponse> forgotPasswordWithId(
      {required ForgotPasswordRequest body}) async {
    return ForgotPasswordResponse.fromJson(await _client.send(
      'post',
      'api/user/forgot-password',
      body: body.toJson(),
    ));
  }

  /// Deletes the user registration for the given user and application. OR
  /// Deletes the user registration for the given user and application along
  /// with the given JSON body that contains the event information.
  Future<void> deleteUserRegistrationWithId(
      {required String userId,
      required String applicationId,
      String? tenantIdScope,
      required RegistrationDeleteRequest body}) async {
    await _client.send(
      'delete',
      'api/user/registration/{userId}/{applicationId}',
      pathParameters: {
        'userId': userId,
        'applicationId': applicationId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    );
  }

  /// Retrieves the user registration for the user with the given Id and the
  /// given application id.
  Future<RegistrationResponse> retrieveRegistrationWithId(
      {required String userId,
      required String applicationId,
      String? tenantIdScope}) async {
    return RegistrationResponse.fromJson(await _client.send(
      'get',
      'api/user/registration/{userId}/{applicationId}',
      pathParameters: {
        'userId': userId,
        'applicationId': applicationId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Creates an audit log with the message and user name (usually an email).
  /// Audit logs should be written anytime you make changes to the FusionAuth
  /// database. When using the FusionAuth App web interface, any changes are
  /// automatically written to the audit log. However, if you are accessing the
  /// API, you must write the audit logs yourself.
  Future<AuditLogResponse> createAuditLogWithId(
      {required AuditLogRequest body}) async {
    return AuditLogResponse.fromJson(await _client.send(
      'post',
      'api/system/audit-log',
      body: body.toJson(),
    ));
  }

  /// Creates a preview of the message template provided in the request,
  /// normalized to a given locale.
  Future<PreviewMessageTemplateResponse> retrieveMessageTemplatePreviewWithId(
      {required PreviewMessageTemplateRequest body}) async {
    return PreviewMessageTemplateResponse.fromJson(await _client.send(
      'post',
      'api/message/template/preview',
      body: body.toJson(),
    ));
  }

  /// Retrieves the last number of login records. OR Retrieves the last number
  /// of login records for a user.
  Future<RecentLoginResponse> retrieveUserRecentLogin(
      {String? offset, String? limit, String? userId}) async {
    return RecentLoginResponse.fromJson(await _client.send(
      'get',
      'api/user/recent-login',
      queryParameters: {
        if (offset != null) 'offset': offset,
        if (limit != null) 'limit': limit,
        if (userId != null) 'userId': userId,
      },
    ));
  }

  /// Retrieves the message template for the given Id. If you don't specify the
  /// id, this will return all the message templates.
  Future<MessageTemplateResponse> retrieveMessageTemplateWithId(
      String messageTemplateId) async {
    return MessageTemplateResponse.fromJson(await _client.send(
      'get',
      'api/message/template/{messageTemplateId}',
      pathParameters: {
        'messageTemplateId': messageTemplateId,
      },
    ));
  }

  /// Updates the message template with the given Id.
  Future<MessageTemplateResponse> updateMessageTemplateWithId(
      {required String messageTemplateId,
      required MessageTemplateRequest body}) async {
    return MessageTemplateResponse.fromJson(await _client.send(
      'put',
      'api/message/template/{messageTemplateId}',
      pathParameters: {
        'messageTemplateId': messageTemplateId,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the message template for the given Id.
  Future<void> deleteMessageTemplateWithId(String messageTemplateId) async {
    await _client.send(
      'delete',
      'api/message/template/{messageTemplateId}',
      pathParameters: {
        'messageTemplateId': messageTemplateId,
      },
    );
  }

  /// Creates an message template. You can optionally specify an Id for the
  /// template, if not provided one will be generated.
  Future<MessageTemplateResponse> createMessageTemplateWithId(
      {required String messageTemplateId,
      required MessageTemplateRequest body}) async {
    return MessageTemplateResponse.fromJson(await _client.send(
      'post',
      'api/message/template/{messageTemplateId}',
      pathParameters: {
        'messageTemplateId': messageTemplateId,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves the message template for the given Id. If you don't specify the
  /// id, this will return all the message templates.
  Future<MessageTemplateResponse> retrieveMessageTemplate() async {
    return MessageTemplateResponse.fromJson(await _client.send(
      'get',
      'api/message/template',
    ));
  }

  /// Creates an message template. You can optionally specify an Id for the
  /// template, if not provided one will be generated.
  Future<MessageTemplateResponse> createMessageTemplate(
      {required MessageTemplateRequest body}) async {
    return MessageTemplateResponse.fromJson(await _client.send(
      'post',
      'api/message/template',
      body: body.toJson(),
    ));
  }

  /// Creates a Theme. You can optionally specify an Id for the theme, if not
  /// provided one will be generated.
  Future<ThemeResponse> createTheme({required ThemeRequest body}) async {
    return ThemeResponse.fromJson(await _client.send(
      'post',
      'api/theme',
      body: body.toJson(),
    ));
  }

  /// Removes users as members of a group.
  Future<void> deleteGroupMembersWithId(
      {required MemberDeleteRequest body}) async {
    await _client.send(
      'delete',
      'api/group/member',
      body: body.toJson(),
    );
  }

  /// Creates a member in a group.
  Future<MemberResponse> createGroupMembersWithId(
      {required MemberRequest body}) async {
    return MemberResponse.fromJson(await _client.send(
      'post',
      'api/group/member',
      body: body.toJson(),
    ));
  }

  /// Creates a member in a group.
  Future<MemberResponse> updateGroupMembersWithId(
      {required MemberRequest body}) async {
    return MemberResponse.fromJson(await _client.send(
      'put',
      'api/group/member',
      body: body.toJson(),
    ));
  }

  /// Generate a Two Factor secret that can be used to enable Two Factor
  /// authentication for a User. The response will contain both the secret and a
  /// Base32 encoded form of the secret which can be shown to a User when using
  /// a 2 Step Authentication application such as Google Authenticator.
  Future<SecretResponse> generateTwoFactorSecretUsingJWTWithId() async {
    return SecretResponse.fromJson(await _client.send(
      'get',
      'api/two-factor/secret',
    ));
  }

  /// Sends a ping to FusionAuth indicating that the user was automatically
  /// logged into an application. When using FusionAuth's SSO or your own, you
  /// should call this if the user is already logged in centrally, but accesses
  /// an application where they no longer have a session. This helps correctly
  /// track login counts, times and helps with reporting.
  Future<LoginResponse> loginPingWithRequestWithId(
      {String? tenantIdScope, required LoginPingRequest body}) async {
    return LoginResponse.fromJson(await _client.send(
      'put',
      'api/login',
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Authenticates a user to FusionAuth.   This API optionally requires an API
  /// key. See `Application.loginConfiguration.requireAuthentication`.
  Future<LoginResponse> loginWithId(
      {String? tenantIdScope, required LoginRequest body}) async {
    return LoginResponse.fromJson(await _client.send(
      'post',
      'api/login',
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves the identity provider for the given Id or all the identity
  /// providers if the Id is null.
  Future<IdentityProviderResponse> retrieveIdentityProviderWithId(
      String identityProviderId) async {
    return IdentityProviderResponse.fromJson(await _client.send(
      'get',
      'api/identity-provider/{identityProviderId}',
      pathParameters: {
        'identityProviderId': identityProviderId,
      },
    ));
  }

  /// Deletes the identity provider for the given Id.
  Future<void> deleteIdentityProviderWithId(String identityProviderId) async {
    await _client.send(
      'delete',
      'api/identity-provider/{identityProviderId}',
      pathParameters: {
        'identityProviderId': identityProviderId,
      },
    );
  }

  /// Creates an identity provider. You can optionally specify an Id for the
  /// identity provider, if not provided one will be generated.
  Future<IdentityProviderResponse> createIdentityProviderWithId(
      {required String identityProviderId,
      required IdentityProviderRequest body}) async {
    return IdentityProviderResponse.fromJson(await _client.send(
      'post',
      'api/identity-provider/{identityProviderId}',
      pathParameters: {
        'identityProviderId': identityProviderId,
      },
      body: body.toJson(),
    ));
  }

  /// Updates the identity provider with the given Id.
  Future<IdentityProviderResponse> updateIdentityProviderWithId(
      {required String identityProviderId,
      required IdentityProviderRequest body}) async {
    return IdentityProviderResponse.fromJson(await _client.send(
      'put',
      'api/identity-provider/{identityProviderId}',
      pathParameters: {
        'identityProviderId': identityProviderId,
      },
      body: body.toJson(),
    ));
  }

  /// Complete a login request using a passwordless code
  Future<LoginResponse> passwordlessLoginWithId(
      {required PasswordlessLoginRequest body}) async {
    return LoginResponse.fromJson(await _client.send(
      'post',
      'api/passwordless/login',
      body: body.toJson(),
    ));
  }

  /// Updates an API key by given id
  Future<APIKeyResponse> updateAPIKeyWithId(
      {required String apiKeyId, required APIKeyRequest body}) async {
    return APIKeyResponse.fromJson(await _client.send(
      'put',
      'api/api-key/{apiKeyId}',
      pathParameters: {
        'apiKeyId': apiKeyId,
      },
      body: body.toJson(),
    ));
  }

  /// Updates the system configuration.
  Future<SystemConfigurationResponse> updateSystemConfigurationWithId(
      {required SystemConfigurationRequest body}) async {
    return SystemConfigurationResponse.fromJson(await _client.send(
      'put',
      'api/system-configuration',
      body: body.toJson(),
    ));
  }

  /// Retrieve a pending identity provider link. This is useful to validate a
  /// pending link and retrieve meta-data about the identity provider link.
  Future<IdentityProviderPendingLinkResponse> retrievePendingLinkWithId(
      {String? userId, required String pendingLinkId}) async {
    return IdentityProviderPendingLinkResponse.fromJson(await _client.send(
      'get',
      'api/identity-provider/link/pending/{pendingLinkId}',
      pathParameters: {
        'pendingLinkId': pendingLinkId,
      },
      queryParameters: {
        if (userId != null) 'userId': userId,
      },
    ));
  }

  /// Check to see if the user must obtain a Trust Token Id in order to complete
  /// a change password request. When a user has enabled Two-Factor
  /// authentication, before you are allowed to use the Change Password API to
  /// change your password, you must obtain a Trust Token by completing a
  /// Two-Factor Step-Up authentication.  An HTTP status code of 400 with a
  /// general error code of [TrustTokenRequired] indicates that a Trust Token is
  /// required to make a POST request to this API.
  Future<void> checkChangePasswordUsingIdWithId(String changePasswordId) async {
    await _client.send(
      'get',
      'api/user/change-password/{changePasswordId}',
      pathParameters: {
        'changePasswordId': changePasswordId,
      },
    );
  }

  /// Changes a user's password using the change password Id. This usually
  /// occurs after an email has been sent to the user and they clicked on a link
  /// to reset their password.  As of version 1.32.2, prefer sending the
  /// changePasswordId in the request body. To do this, omit the first
  /// parameter, and set the value in the request body.
  Future<ChangePasswordResponse> changePasswordWithId(
      {required String changePasswordId,
      required ChangePasswordRequest body}) async {
    return ChangePasswordResponse.fromJson(await _client.send(
      'post',
      'api/user/change-password/{changePasswordId}',
      pathParameters: {
        'changePasswordId': changePasswordId,
      },
      body: body.toJson(),
    ));
  }

  /// Deactivates the users with the given ids. OR Deletes the users with the
  /// given ids, or users matching the provided JSON query or queryString. The
  /// order of preference is ids, query and then queryString, it is recommended
  /// to only provide one of the three for the request.  This method can be used
  /// to deactivate or permanently delete (hard-delete) users based upon the
  /// hardDelete boolean in the request body. Using the dryRun parameter you may
  /// also request the result of the action without actually deleting or
  /// deactivating any users.
  Future<UserDeleteResponse> deleteUserBulk(
      {String? userIds,
      String? dryRun,
      String? hardDelete,
      required UserDeleteRequest body}) async {
    return UserDeleteResponse.fromJson(await _client.send(
      'delete',
      'api/user/bulk',
      queryParameters: {
        if (userIds != null) 'userIds': userIds,
        if (dryRun != null) 'dryRun': dryRun,
        if (hardDelete != null) 'hardDelete': hardDelete,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves the Public Key configured for verifying JSON Web Tokens (JWT) by
  /// the key Id (kid). OR Retrieves the Public Key configured for verifying the
  /// JSON Web Tokens (JWT) issued by the Login API by the Application Id.
  Future<PublicKeyResponse> retrieveJwtPublicKey(
      {String? keyId, String? applicationId}) async {
    return PublicKeyResponse.fromJson(await _client.send(
      'get',
      'api/jwt/public-key',
      queryParameters: {
        if (keyId != null) 'keyId': keyId,
        if (applicationId != null) 'applicationId': applicationId,
      },
    ));
  }

  /// Creates an API key. You can optionally specify a unique Id for the key, if
  /// not provided one will be generated. an API key can only be created with
  /// equal or lesser authority. An API key cannot create another API key unless
  /// it is granted  to that API key.  If an API key is locked to a tenant, it
  /// can only create API Keys for that same tenant.
  Future<APIKeyResponse> createAPIKey({required APIKeyRequest body}) async {
    return APIKeyResponse.fromJson(await _client.send(
      'post',
      'api/api-key',
      body: body.toJson(),
    ));
  }

  /// Retrieves the application for the given Id or all the applications if the
  /// Id is null. OR Retrieves all the applications that are currently inactive.
  Future<ApplicationResponse> retrieveApplication(
      {String? tenantIdScope, String? inactive}) async {
    return ApplicationResponse.fromJson(await _client.send(
      'get',
      'api/application',
      queryParameters: {
        if (inactive != null) 'inactive': inactive,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Creates an application. You can optionally specify an Id for the
  /// application, if not provided one will be generated.
  Future<ApplicationResponse> createApplication(
      {String? tenantIdScope, required ApplicationRequest body}) async {
    return ApplicationResponse.fromJson(await _client.send(
      'post',
      'api/application',
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Searches email templates with the specified criteria and pagination.
  Future<EmailTemplateSearchResponse> searchEmailTemplatesWithId(
      {required EmailTemplateSearchRequest body}) async {
    return EmailTemplateSearchResponse.fromJson(await _client.send(
      'post',
      'api/email/template/search',
      body: body.toJson(),
    ));
  }

  /// Searches webhooks with the specified criteria and pagination.
  Future<WebhookSearchResponse> searchWebhooksWithId(
      {required WebhookSearchRequest body}) async {
    return WebhookSearchResponse.fromJson(await _client.send(
      'post',
      'api/webhook/search',
      body: body.toJson(),
    ));
  }

  /// Complete a WebAuthn authentication ceremony by validating the signature
  /// against the previously generated challenge without logging the user in
  Future<WebAuthnAssertResponse> completeWebAuthnAssertionWithId(
      {required WebAuthnLoginRequest body}) async {
    return WebAuthnAssertResponse.fromJson(await _client.send(
      'post',
      'api/webauthn/assert',
      body: body.toJson(),
    ));
  }

  /// Validates the provided JWT (encoded JWT string) to ensure the token is
  /// valid. A valid access token is properly signed and not expired. <p> This
  /// API may be used to verify the JWT as well as decode the encoded JWT into
  /// human readable identity claims.
  Future<ValidateResponse> validateJWTWithId() async {
    return ValidateResponse.fromJson(await _client.send(
      'get',
      'api/jwt/validate',
    ));
  }

  /// Complete a WebAuthn registration ceremony by validating the client request
  /// and saving the new credential
  Future<WebAuthnRegisterCompleteResponse> completeWebAuthnRegistrationWithId(
      {required WebAuthnRegisterCompleteRequest body}) async {
    return WebAuthnRegisterCompleteResponse.fromJson(await _client.send(
      'post',
      'api/webauthn/register/complete',
      body: body.toJson(),
    ));
  }

  /// Searches lambdas with the specified criteria and pagination.
  Future<LambdaSearchResponse> searchLambdasWithId(
      {required LambdaSearchRequest body}) async {
    return LambdaSearchResponse.fromJson(await _client.send(
      'post',
      'api/lambda/search',
      body: body.toJson(),
    ));
  }

  /// Retrieves all the user actions that are currently inactive. OR Retrieves
  /// the user action for the given Id. If you pass in null for the id, this
  /// will return all the user actions.
  Future<UserActionResponse> retrieveUserAction(
      {String? inactive, String? tenantIdScope}) async {
    return UserActionResponse.fromJson(await _client.send(
      'get',
      'api/user-action',
      queryParameters: {
        if (inactive != null) 'inactive': inactive,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Creates a user action. This action cannot be taken on a user until this
  /// call successfully returns. Anytime after that the user action can be
  /// applied to any user.
  Future<UserActionResponse> createUserAction(
      {String? tenantIdScope, required UserActionRequest body}) async {
    return UserActionResponse.fromJson(await _client.send(
      'post',
      'api/user-action',
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves all the comments for the user with the given Id.
  Future<UserCommentResponse> retrieveUserCommentsWithId(
      {required String userId, String? tenantIdScope}) async {
    return UserCommentResponse.fromJson(await _client.send(
      'get',
      'api/user/comment/{userId}',
      pathParameters: {
        'userId': userId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Retrieves the WebAuthn credential for the given Id.
  Future<WebAuthnCredentialResponse> retrieveWebAuthnCredentialWithId(
      String id) async {
    return WebAuthnCredentialResponse.fromJson(await _client.send(
      'get',
      'api/webauthn/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Deletes the WebAuthn credential for the given Id.
  Future<void> deleteWebAuthnCredentialWithId(String id) async {
    await _client.send(
      'delete',
      'api/webauthn/{id}',
      pathParameters: {
        'id': id,
      },
    );
  }

  /// Start a WebAuthn registration ceremony by generating a new challenge for
  /// the user
  Future<WebAuthnRegisterStartResponse> startWebAuthnRegistrationWithId(
      {required WebAuthnRegisterStartRequest body}) async {
    return WebAuthnRegisterStartResponse.fromJson(await _client.send(
      'post',
      'api/webauthn/register/start',
      body: body.toJson(),
    ));
  }

  /// Searches user comments with the specified criteria and pagination.
  Future<UserCommentSearchResponse> searchUserCommentsWithId(
      {required UserCommentSearchRequest body}) async {
    return UserCommentSearchResponse.fromJson(await _client.send(
      'post',
      'api/user/comment/search',
      body: body.toJson(),
    ));
  }

  /// It's a JWT vending machine!  Issue a new access token (JWT) with the
  /// provided claims in the request. This JWT is not scoped to a tenant or
  /// user, it is a free form  token that will contain what claims you provide.
  /// <p> The iat, exp and jti claims will be added by FusionAuth, all other
  /// claims must be provided by the caller.  If a TTL is not provided in the
  /// request, the TTL will be retrieved from the default Tenant or the Tenant
  /// specified on the request either  by way of the X-FusionAuth-TenantId
  /// request header, or a tenant scoped API key.
  Future<JWTVendResponse> vendJWTWithId({required JWTVendRequest body}) async {
    return JWTVendResponse.fromJson(await _client.send(
      'post',
      'api/jwt/vend',
      body: body.toJson(),
    ));
  }

  /// Searches keys with the specified criteria and pagination.
  Future<KeySearchResponse> searchKeysWithId(
      {required KeySearchRequest body}) async {
    return KeySearchResponse.fromJson(await _client.send(
      'post',
      'api/key/search',
      body: body.toJson(),
    ));
  }

  /// Updates the form field with the given Id.
  Future<FormFieldResponse> updateFormFieldWithId(
      {required String fieldId, required FormFieldRequest body}) async {
    return FormFieldResponse.fromJson(await _client.send(
      'put',
      'api/form/field/{fieldId}',
      pathParameters: {
        'fieldId': fieldId,
      },
      body: body.toJson(),
    ));
  }

  /// Creates a form field.  You can optionally specify an Id for the form, if
  /// not provided one will be generated.
  Future<FormFieldResponse> createFormFieldWithId(
      {required String fieldId, required FormFieldRequest body}) async {
    return FormFieldResponse.fromJson(await _client.send(
      'post',
      'api/form/field/{fieldId}',
      pathParameters: {
        'fieldId': fieldId,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the form field for the given Id.
  Future<void> deleteFormFieldWithId(String fieldId) async {
    await _client.send(
      'delete',
      'api/form/field/{fieldId}',
      pathParameters: {
        'fieldId': fieldId,
      },
    );
  }

  /// Retrieves the form field with the given Id.
  Future<FormFieldResponse> retrieveFormFieldWithId(String fieldId) async {
    return FormFieldResponse.fromJson(await _client.send(
      'get',
      'api/form/field/{fieldId}',
      pathParameters: {
        'fieldId': fieldId,
      },
    ));
  }

  /// Import an existing RSA or EC key pair or an HMAC secret.
  Future<KeyResponse> importKeyWithId(
      {required String keyId, required KeyRequest body}) async {
    return KeyResponse.fromJson(await _client.send(
      'post',
      'api/key/import/{keyId}',
      pathParameters: {
        'keyId': keyId,
      },
      body: body.toJson(),
    ));
  }

  /// Import an existing RSA or EC key pair or an HMAC secret.
  Future<KeyResponse> importKey({required KeyRequest body}) async {
    return KeyResponse.fromJson(await _client.send(
      'post',
      'api/key/import',
      body: body.toJson(),
    ));
  }

  /// Retrieves one or more identity provider for the given type. For types such
  /// as Google, Facebook, Twitter and LinkedIn, only a single  identity
  /// provider can exist. For types such as OpenID Connect and SAMLv2 more than
  /// one identity provider can be configured so this request  may return
  /// multiple identity providers.
  Future<IdentityProviderResponse> retrieveIdentityProviderByTypeWithId(
      {String? type}) async {
    return IdentityProviderResponse.fromJson(await _client.send(
      'get',
      'api/identity-provider',
      queryParameters: {
        if (type != null) 'type': type,
      },
    ));
  }

  /// Creates an identity provider. You can optionally specify an Id for the
  /// identity provider, if not provided one will be generated.
  Future<IdentityProviderResponse> createIdentityProvider(
      {required IdentityProviderRequest body}) async {
    return IdentityProviderResponse.fromJson(await _client.send(
      'post',
      'api/identity-provider',
      body: body.toJson(),
    ));
  }

  /// Searches consents with the specified criteria and pagination.
  Future<ConsentSearchResponse> searchConsentsWithId(
      {required ConsentSearchRequest body}) async {
    return ConsentSearchResponse.fromJson(await _client.send(
      'post',
      'api/consent/search',
      body: body.toJson(),
    ));
  }

  /// Begins a login request for a 3rd party login that requires user
  /// interaction such as HYPR.
  Future<IdentityProviderStartLoginResponse> startIdentityProviderLoginWithId(
      {required IdentityProviderStartLoginRequest body}) async {
    return IdentityProviderStartLoginResponse.fromJson(await _client.send(
      'post',
      'api/identity-provider/start',
      body: body.toJson(),
    ));
  }

  /// Updates the permission with the given Id for the entity type.
  Future<EntityTypeResponse> updateEntityTypePermissionWithId(
      {required String entityTypeId,
      required String permissionId,
      required EntityTypeRequest body}) async {
    return EntityTypeResponse.fromJson(await _client.send(
      'put',
      'api/entity/type/{entityTypeId}/permission/{permissionId}',
      pathParameters: {
        'entityTypeId': entityTypeId,
        'permissionId': permissionId,
      },
      body: body.toJson(),
    ));
  }

  /// Hard deletes a permission. This is a dangerous operation and should not be
  /// used in most circumstances. This permanently removes the given permission
  /// from all grants that had it.
  Future<void> deleteEntityTypePermissionWithId(
      {required String entityTypeId, required String permissionId}) async {
    await _client.send(
      'delete',
      'api/entity/type/{entityTypeId}/permission/{permissionId}',
      pathParameters: {
        'entityTypeId': entityTypeId,
        'permissionId': permissionId,
      },
    );
  }

  /// Creates a new permission for an entity type. You must specify the Id of
  /// the entity type you are creating the permission for. You can optionally
  /// specify an Id for the permission inside the EntityTypePermission object
  /// itself, if not provided one will be generated.
  Future<EntityTypeResponse> createEntityTypePermissionWithId(
      {required String entityTypeId,
      required String permissionId,
      required EntityTypeRequest body}) async {
    return EntityTypeResponse.fromJson(await _client.send(
      'post',
      'api/entity/type/{entityTypeId}/permission/{permissionId}',
      pathParameters: {
        'entityTypeId': entityTypeId,
        'permissionId': permissionId,
      },
      body: body.toJson(),
    ));
  }

  /// Generate two-factor recovery codes for a user. Generating two-factor
  /// recovery codes will invalidate any existing recovery codes.
  Future<TwoFactorRecoveryCodeResponse> generateTwoFactorRecoveryCodesWithId(
      String userId) async {
    return TwoFactorRecoveryCodeResponse.fromJson(await _client.send(
      'post',
      'api/user/two-factor/recovery-code/{userId}',
      pathParameters: {
        'userId': userId,
      },
    ));
  }

  /// Retrieve two-factor recovery codes for a user.
  Future<TwoFactorRecoveryCodeResponse> retrieveTwoFactorRecoveryCodesWithId(
      String userId) async {
    return TwoFactorRecoveryCodeResponse.fromJson(await _client.send(
      'get',
      'api/user/two-factor/recovery-code/{userId}',
      pathParameters: {
        'userId': userId,
      },
    ));
  }

  /// Retrieves a single webhook attempt log for the given Id.
  Future<WebhookAttemptLogResponse> retrieveWebhookAttemptLogWithId(
      String webhookAttemptLogId) async {
    return WebhookAttemptLogResponse.fromJson(await _client.send(
      'get',
      'api/system/webhook-attempt-log/{webhookAttemptLogId}',
      pathParameters: {
        'webhookAttemptLogId': webhookAttemptLogId,
      },
    ));
  }

  /// Send a Two Factor authentication code to assist in setting up Two Factor
  /// authentication or disabling.
  Future<void> sendTwoFactorCodeForEnableDisableWithId(
      {required TwoFactorSendRequest body}) async {
    await _client.send(
      'post',
      'api/two-factor/send',
      body: body.toJson(),
    );
  }

  /// Retrieves the password validation rules for a specific tenant.  This API
  /// does not require an API key.
  Future<PasswordValidationRulesResponse>
      retrievePasswordValidationRulesWithTenantIdWithId(String tenantId) async {
    return PasswordValidationRulesResponse.fromJson(await _client.send(
      'get',
      'api/tenant/password-validation-rules/{tenantId}',
      pathParameters: {
        'tenantId': tenantId,
      },
    ));
  }

  /// Registers a user for an application. If you provide the User and the
  /// UserRegistration object on this request, it will create the user as well
  /// as register them for the application. This is called a Full Registration.
  /// However, if you only provide the UserRegistration object, then the user
  /// must already exist and they will be registered for the application. The
  /// user Id can also be provided and it will either be used to look up an
  /// existing user or it will be used for the newly created User.
  Future<RegistrationResponse> register(
      {String? tenantIdScope, required RegistrationRequest body}) async {
    return RegistrationResponse.fromJson(await _client.send(
      'post',
      'api/user/registration',
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Creates a form field.  You can optionally specify an Id for the form, if
  /// not provided one will be generated.
  Future<FormFieldResponse> createFormField(
      {required FormFieldRequest body}) async {
    return FormFieldResponse.fromJson(await _client.send(
      'post',
      'api/form/field',
      body: body.toJson(),
    ));
  }

  /// Searches the entity types with the specified criteria and pagination.
  Future<EntityTypeSearchResponse> searchEntityTypesWithId(
      {required EntityTypeSearchRequest body}) async {
    return EntityTypeSearchResponse.fromJson(await _client.send(
      'post',
      'api/entity/type/search',
      body: body.toJson(),
    ));
  }

  /// Retrieves a single audit log for the given Id.
  Future<AuditLogResponse> retrieveAuditLogWithId(String auditLogId) async {
    return AuditLogResponse.fromJson(await _client.send(
      'get',
      'api/system/audit-log/{auditLogId}',
      pathParameters: {
        'auditLogId': auditLogId,
      },
    ));
  }

  /// Creates a new permission for an entity type. You must specify the Id of
  /// the entity type you are creating the permission for. You can optionally
  /// specify an Id for the permission inside the EntityTypePermission object
  /// itself, if not provided one will be generated.
  Future<EntityTypeResponse> createEntityTypePermission(
      {required String entityTypeId, required EntityTypeRequest body}) async {
    return EntityTypeResponse.fromJson(await _client.send(
      'post',
      'api/entity/type/{entityTypeId}/permission',
      pathParameters: {
        'entityTypeId': entityTypeId,
      },
      body: body.toJson(),
    ));
  }

  /// Creates a new custom OAuth scope for an application. You must specify the
  /// Id of the application you are creating the scope for. You can optionally
  /// specify an Id for the OAuth scope on the URL, if not provided one will be
  /// generated.
  Future<ApplicationOAuthScopeResponse> createoAuthScope(
      {required String applicationId,
      String? tenantIdScope,
      required ApplicationOAuthScopeRequest body}) async {
    return ApplicationOAuthScopeResponse.fromJson(await _client.send(
      'post',
      'api/application/{applicationId}/scope',
      pathParameters: {
        'applicationId': applicationId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes an Entity Grant for the given User or Entity.
  Future<void> deleteEntityGrantWithId(
      {String? recipientEntityId,
      String? userId,
      required String entityId,
      String? tenantIdScope}) async {
    await _client.send(
      'delete',
      'api/entity/{entityId}/grant',
      pathParameters: {
        'entityId': entityId,
      },
      queryParameters: {
        if (recipientEntityId != null) 'recipientEntityId': recipientEntityId,
        if (userId != null) 'userId': userId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    );
  }

  /// Creates or updates an Entity Grant. This is when a User/Entity is granted
  /// permissions to an Entity.
  Future<void> upsertEntityGrantWithId(
      {required String entityId,
      String? tenantIdScope,
      required EntityGrantRequest body}) async {
    await _client.send(
      'post',
      'api/entity/{entityId}/grant',
      pathParameters: {
        'entityId': entityId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    );
  }

  /// Retrieves an Entity Grant for the given Entity and User/Entity.
  Future<EntityGrantResponse> retrieveEntityGrantWithId(
      {String? recipientEntityId,
      String? userId,
      required String entityId,
      String? tenantIdScope}) async {
    return EntityGrantResponse.fromJson(await _client.send(
      'get',
      'api/entity/{entityId}/grant',
      pathParameters: {
        'entityId': entityId,
      },
      queryParameters: {
        if (recipientEntityId != null) 'recipientEntityId': recipientEntityId,
        if (userId != null) 'userId': userId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Retrieves a single webhook event log for the given Id.
  Future<WebhookEventLogResponse> retrieveWebhookEventLogWithId(
      String webhookEventLogId) async {
    return WebhookEventLogResponse.fromJson(await _client.send(
      'get',
      'api/system/webhook-event-log/{webhookEventLogId}',
      pathParameters: {
        'webhookEventLogId': webhookEventLogId,
      },
    ));
  }

  /// Creates a user consent type. You can optionally specify an Id for the
  /// consent type, if not provided one will be generated.
  Future<ConsentResponse> createConsent(
      {String? tenantIdScope, required ConsentRequest body}) async {
    return ConsentResponse.fromJson(await _client.send(
      'post',
      'api/consent',
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Retrieves the Oauth2 configuration for the application for the given
  /// Application Id.
  Future<OAuthConfigurationResponse> retrieveOauthConfigurationWithId(
      {required String applicationId, String? tenantIdScope}) async {
    return OAuthConfigurationResponse.fromJson(await _client.send(
      'get',
      'api/application/{applicationId}/oauth-configuration',
      pathParameters: {
        'applicationId': applicationId,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Searches identity providers with the specified criteria and pagination.
  Future<IdentityProviderSearchResponse> searchIdentityProvidersWithId(
      {required IdentityProviderSearchRequest body}) async {
    return IdentityProviderSearchResponse.fromJson(await _client.send(
      'post',
      'api/identity-provider/search',
      body: body.toJson(),
    ));
  }

  /// Creates a user reason. This user action reason cannot be used when
  /// actioning a user until this call completes successfully. Anytime after
  /// that the user action reason can be used.
  Future<UserActionReasonResponse> createUserActionReason(
      {required UserActionReasonRequest body}) async {
    return UserActionReasonResponse.fromJson(await _client.send(
      'post',
      'api/user-action-reason',
      body: body.toJson(),
    ));
  }

  /// Retrieves the user action reason for the given Id. If you pass in null for
  /// the id, this will return all the user action reasons.
  Future<UserActionReasonResponse> retrieveUserActionReason() async {
    return UserActionReasonResponse.fromJson(await _client.send(
      'get',
      'api/user-action-reason',
    ));
  }

  /// Searches the event logs with the specified criteria and pagination.
  Future<EventLogSearchResponse> searchEventLogsWithId(
      {required EventLogSearchRequest body}) async {
    return EventLogSearchResponse.fromJson(await _client.send(
      'post',
      'api/system/event-log/search',
      body: body.toJson(),
    ));
  }

  /// Searches themes with the specified criteria and pagination.
  Future<ThemeSearchResponse> searchThemesWithId(
      {required ThemeSearchRequest body}) async {
    return ThemeSearchResponse.fromJson(await _client.send(
      'post',
      'api/theme/search',
      body: body.toJson(),
    ));
  }

  /// Call the UserInfo endpoint to retrieve User Claims from the access token
  /// issued by FusionAuth.
  Future<UserinfoResponse> retrieveUserInfoFromAccessTokenWithId() async {
    return UserinfoResponse.fromJson(await _client.send(
      'get',
      'oauth2/userinfo',
    ));
  }

  /// Issue a new access token (JWT) for the requested Application after
  /// ensuring the provided JWT is valid. A valid access token is properly
  /// signed and not expired. <p> This API may be used in an SSO configuration
  /// to issue new tokens for another application after the user has obtained a
  /// valid token from authentication.
  Future<IssueResponse> issueJWTWithId(
      {String? applicationId, String? refreshToken}) async {
    return IssueResponse.fromJson(await _client.send(
      'get',
      'api/jwt/issue',
      queryParameters: {
        if (applicationId != null) 'applicationId': applicationId,
        if (refreshToken != null) 'refreshToken': refreshToken,
      },
    ));
  }

  /// Creates a group. You can optionally specify an Id for the group, if not
  /// provided one will be generated.
  Future<GroupResponse> createGroup(
      {String? tenantIdScope, required GroupRequest body}) async {
    return GroupResponse.fromJson(await _client.send(
      'post',
      'api/group',
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Approve a device grant.
  Future<DeviceApprovalResponse> approveDeviceWithId() async {
    return DeviceApprovalResponse.fromJson(await _client.send(
      'post',
      'oauth2/device/approve',
    ));
  }

  /// Searches entities with the specified criteria and pagination.
  Future<EntitySearchResponse> searchEntitiesWithId(
      {required EntitySearchRequest body}) async {
    return EntitySearchResponse.fromJson(await _client.send(
      'post',
      'api/entity/search',
      body: body.toJson(),
    ));
  }

  /// Retrieves the entities for the given ids. If any Id is invalid, it is
  /// ignored.
  Future<EntitySearchResponse> searchEntitiesByIdsWithId({String? ids}) async {
    return EntitySearchResponse.fromJson(await _client.send(
      'get',
      'api/entity/search',
      queryParameters: {
        if (ids != null) 'ids': ids,
      },
    ));
  }

  /// Activates the FusionAuth Reactor using a license Id and optionally a
  /// license text (for air-gapped deployments)
  Future<void> activateReactorWithId({required ReactorRequest body}) async {
    await _client.send(
      'post',
      'api/reactor',
      body: body.toJson(),
    );
  }

  /// Generate a new RSA or EC key pair or an HMAC secret.
  Future<KeyResponse> generateKeyWithId(
      {required String keyId, required KeyRequest body}) async {
    return KeyResponse.fromJson(await _client.send(
      'post',
      'api/key/generate/{keyId}',
      pathParameters: {
        'keyId': keyId,
      },
      body: body.toJson(),
    ));
  }

  /// Generate a new RSA or EC key pair or an HMAC secret.
  Future<KeyResponse> generateKey({required KeyRequest body}) async {
    return KeyResponse.fromJson(await _client.send(
      'post',
      'api/key/generate',
      body: body.toJson(),
    ));
  }

  /// Retrieves a single refresh token by unique Id. This is not the same thing
  /// as the string value of the refresh token. If you have that, you already
  /// have what you need.
  Future<RefreshTokenResponse> retrieveRefreshTokenByIdWithId(
      String tokenId) async {
    return RefreshTokenResponse.fromJson(await _client.send(
      'get',
      'api/jwt/refresh/{tokenId}',
      pathParameters: {
        'tokenId': tokenId,
      },
    ));
  }

  /// Revokes a single refresh token by the unique Id. The unique Id is not
  /// sensitive as it cannot be used to obtain another JWT.
  Future<void> revokeRefreshTokenByIdWithId(String tokenId) async {
    await _client.send(
      'delete',
      'api/jwt/refresh/{tokenId}',
      pathParameters: {
        'tokenId': tokenId,
      },
    );
  }

  /// Searches the audit logs with the specified criteria and pagination.
  Future<AuditLogSearchResponse> searchAuditLogsWithId(
      {required AuditLogSearchRequest body}) async {
    return AuditLogSearchResponse.fromJson(await _client.send(
      'post',
      'api/system/audit-log/search',
      body: body.toJson(),
    ));
  }

  /// Retrieves the identity provider for the given domain. A 200 response code
  /// indicates the domain is managed by a registered identity provider. A 404
  /// indicates the domain is not managed.
  Future<LookupResponse> lookupIdentityProviderWithId({String? domain}) async {
    return LookupResponse.fromJson(await _client.send(
      'get',
      'api/identity-provider/lookup',
      queryParameters: {
        if (domain != null) 'domain': domain,
      },
    ));
  }

  /// Start a Two-Factor login request by generating a two-factor identifier.
  /// This code can then be sent to the Two Factor Send  API
  /// (/api/two-factor/send)in order to send a one-time use code to a user. You
  /// can also use one-time use code returned  to send the code out-of-band. The
  /// Two-Factor login is completed by making a request to the Two-Factor Login
  /// API (/api/two-factor/login). with the two-factor identifier and the
  /// one-time use code.  This API is intended to allow you to begin a
  /// Two-Factor login outside a normal login that originated from the Login API
  /// (/api/login).
  Future<TwoFactorStartResponse> startTwoFactorLoginWithId(
      {required TwoFactorStartRequest body}) async {
    return TwoFactorStartResponse.fromJson(await _client.send(
      'post',
      'api/two-factor/start',
      body: body.toJson(),
    ));
  }

  /// Searches groups with the specified criteria and pagination.
  Future<GroupSearchResponse> searchGroupsWithId(
      {required GroupSearchRequest body}) async {
    return GroupSearchResponse.fromJson(await _client.send(
      'post',
      'api/group/search',
      body: body.toJson(),
    ));
  }

  /// Retrieve a user's two-factor status.  This can be used to see if a user
  /// will need to complete a two-factor challenge to complete a login, and
  /// optionally identify the state of the two-factor trust across various
  /// applications.
  Future<TwoFactorStatusResponse> retrieveTwoFactorStatusWithId(
      {String? userId,
      String? applicationId,
      required String twoFactorTrustId}) async {
    return TwoFactorStatusResponse.fromJson(await _client.send(
      'get',
      'api/two-factor/status/{twoFactorTrustId}',
      pathParameters: {
        'twoFactorTrustId': twoFactorTrustId,
      },
      queryParameters: {
        if (userId != null) 'userId': userId,
        if (applicationId != null) 'applicationId': applicationId,
      },
    ));
  }

  /// Creates a preview of the email template provided in the request. This
  /// allows you to preview an email template that hasn't been saved to the
  /// database yet. The entire email template does not need to be provided on
  /// the request. This will create the preview based on whatever is given.
  Future<PreviewResponse> retrieveEmailTemplatePreviewWithId(
      {required PreviewRequest body}) async {
    return PreviewResponse.fromJson(await _client.send(
      'post',
      'api/email/template/preview',
      body: body.toJson(),
    ));
  }

  /// Retrieves a single event log for the given Id.
  Future<EventLogResponse> retrieveEventLogWithId(String eventLogId) async {
    return EventLogResponse.fromJson(await _client.send(
      'get',
      'api/system/event-log/{eventLogId}',
      pathParameters: {
        'eventLogId': eventLogId,
      },
    ));
  }

  /// Creates a tenant. You can optionally specify an Id for the tenant, if not
  /// provided one will be generated.
  Future<TenantResponse> createTenant(
      {String? tenantIdScope, required TenantRequest body}) async {
    return TenantResponse.fromJson(await _client.send(
      'post',
      'api/tenant',
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Adds a comment to the user's account.
  Future<UserCommentResponse> commentOnUserWithId(
      {String? tenantIdScope, required UserCommentRequest body}) async {
    return UserCommentResponse.fromJson(await _client.send(
      'post',
      'api/user/comment',
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Searches the webhook event logs with the specified criteria and
  /// pagination.
  Future<WebhookEventLogSearchResponse> searchWebhookEventLogsWithId(
      {required WebhookEventLogSearchRequest body}) async {
    return WebhookEventLogSearchResponse.fromJson(await _client.send(
      'post',
      'api/system/webhook-event-log/search',
      body: body.toJson(),
    ));
  }

  /// Reconcile a User to FusionAuth using JWT issued from another Identity
  /// Provider.
  Future<LoginResponse> reconcileJWTWithId(
      {required IdentityProviderLoginRequest body}) async {
    return LoginResponse.fromJson(await _client.send(
      'post',
      'api/jwt/reconcile',
      body: body.toJson(),
    ));
  }

  /// Complete login using a 2FA challenge
  Future<LoginResponse> twoFactorLoginWithId(
      {required TwoFactorLoginRequest body}) async {
    return LoginResponse.fromJson(await _client.send(
      'post',
      'api/two-factor/login',
      body: body.toJson(),
    ));
  }

  /// Requests Elasticsearch to delete and rebuild the index for FusionAuth
  /// users or entities. Be very careful when running this request as it will
  /// increase the CPU and I/O load on your database until the operation
  /// completes. Generally speaking you do not ever need to run this operation
  /// unless  instructed by FusionAuth support, or if you are migrating a
  /// database another system and you are not brining along the Elasticsearch
  /// index.   You have been warned.
  Future<void> reindexWithId({required ReindexRequest body}) async {
    await _client.send(
      'post',
      'api/system/reindex',
      body: body.toJson(),
    );
  }

  /// Retrieves all the children for the given parent email address.
  Future<PendingResponse> retrievePendingChildrenWithId(
      {String? parentEmail}) async {
    return PendingResponse.fromJson(await _client.send(
      'get',
      'api/user/family/pending',
      queryParameters: {
        if (parentEmail != null) 'parentEmail': parentEmail,
      },
    ));
  }

  /// Retrieves the daily active user report between the two instants. If you
  /// specify an application id, it will only return the daily active counts for
  /// that application.
  Future<DailyActiveUserReportResponse> retrieveDailyActiveReportWithId(
      {String? applicationId, String? start, String? end}) async {
    return DailyActiveUserReportResponse.fromJson(await _client.send(
      'get',
      'api/report/daily-active-user',
      queryParameters: {
        if (applicationId != null) 'applicationId': applicationId,
        if (start != null) 'start': start,
        if (end != null) 'end': end,
      },
    ));
  }

  /// Sends a ping to FusionAuth indicating that the user was automatically
  /// logged into an application. When using FusionAuth's SSO or your own, you
  /// should call this if the user is already logged in centrally, but accesses
  /// an application where they no longer have a session. This helps correctly
  /// track login counts, times and helps with reporting.
  Future<LoginResponse> loginPingWithId(
      {String? callerIpAddress,
      required String userId,
      required String applicationId,
      String? tenantIdScope}) async {
    return LoginResponse.fromJson(await _client.send(
      'put',
      'api/login/{userId}/{applicationId}',
      pathParameters: {
        'userId': userId,
        'applicationId': applicationId,
      },
      queryParameters: {
        if (callerIpAddress != null) 'callerIPAddress': callerIpAddress,
      },
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
    ));
  }

  /// Creates a Entity Type. You can optionally specify an Id for the Entity
  /// Type, if not provided one will be generated.
  Future<EntityTypeResponse> createEntityType(
      {required EntityTypeRequest body}) async {
    return EntityTypeResponse.fromJson(await _client.send(
      'post',
      'api/entity/type',
      body: body.toJson(),
    ));
  }

  /// Creates an Entity. You can optionally specify an Id for the Entity. If not
  /// provided one will be generated.
  Future<EntityResponse> createEntity(
      {String? tenantIdScope, required EntityRequest body}) async {
    return EntityResponse.fromJson(await _client.send(
      'post',
      'api/entity',
      headers: {
        if (tenantIdScope != null) 'X-FusionAuth-TenantId': tenantIdScope,
      },
      body: body.toJson(),
    ));
  }

  /// Bulk imports refresh tokens. This request performs minimal validation and
  /// runs batch inserts of refresh tokens with the expectation that each token
  /// represents a user that already exists and is registered for the
  /// corresponding FusionAuth Application. This is done to increases the insert
  /// performance.  Therefore, if you encounter an error due to a database key
  /// violation, the response will likely offer a generic explanation. If you
  /// encounter an error, you may optionally enable additional validation to
  /// receive a JSON response body with specific validation errors. This will
  /// slow the request down but will allow you to identify the cause of the
  /// failure. See the validateDbConstraints request parameter.
  Future<void> importRefreshTokensWithId(
      {required RefreshTokenImportRequest body}) async {
    await _client.send(
      'post',
      'api/user/refresh-token/import',
      body: body.toJson(),
    );
  }

  /// Searches Entity Grants with the specified criteria and pagination.
  Future<EntityGrantSearchResponse> searchEntityGrantsWithId(
      {required EntityGrantSearchRequest body}) async {
    return EntityGrantSearchResponse.fromJson(await _client.send(
      'post',
      'api/entity/grant/search',
      body: body.toJson(),
    ));
  }

  /// Bulk imports users. This request performs minimal validation and runs
  /// batch inserts of users with the expectation that each user does not yet
  /// exist and each registration corresponds to an existing FusionAuth
  /// Application. This is done to increases the insert performance.  Therefore,
  /// if you encounter an error due to a database key violation, the response
  /// will likely offer a generic explanation. If you encounter an error, you
  /// may optionally enable additional validation to receive a JSON response
  /// body with specific validation errors. This will slow the request down but
  /// will allow you to identify the cause of the failure. See the
  /// validateDbConstraints request parameter.
  Future<void> importUsersWithId({required ImportRequest body}) async {
    await _client.send(
      'post',
      'api/user/import',
      body: body.toJson(),
    );
  }

  /// Complete a WebAuthn authentication ceremony by validating the signature
  /// against the previously generated challenge and then login the user in
  Future<LoginResponse> completeWebAuthnLoginWithId(
      {required WebAuthnLoginRequest body}) async {
    return LoginResponse.fromJson(await _client.send(
      'post',
      'api/webauthn/login',
      body: body.toJson(),
    ));
  }

  /// Retrieves the registration report between the two instants. If you specify
  /// an application id, it will only return the registration counts for that
  /// application.
  Future<RegistrationReportResponse> retrieveRegistrationReportWithId(
      {String? applicationId, String? start, String? end}) async {
    return RegistrationReportResponse.fromJson(await _client.send(
      'get',
      'api/report/registration',
      queryParameters: {
        if (applicationId != null) 'applicationId': applicationId,
        if (start != null) 'start': start,
        if (end != null) 'end': end,
      },
    ));
  }

  /// Send an email using an email template id. You can optionally provide
  /// `requestData` to access key value pairs in the email template.
  Future<SendResponse> sendEmailWithId(
      {required String emailTemplateId, required SendRequest body}) async {
    return SendResponse.fromJson(await _client.send(
      'post',
      'api/email/send/{emailTemplateId}',
      pathParameters: {
        'emailTemplateId': emailTemplateId,
      },
      body: body.toJson(),
    ));
  }

  /// Returns the well known OpenID Configuration JSON document
  Future<OpenIdConfiguration> retrieveOpenIdConfigurationWithId() async {
    return OpenIdConfiguration.fromJson(await _client.send(
      'get',
      '.well-known/openid-configuration',
    ));
  }

  /// Retrieves the FusionAuth system status. This request is anonymous and does
  /// not require an API key. When an API key is not provided the response will
  /// contain a single value in the JSON response indicating the current health
  /// check. OR Retrieves the FusionAuth system status using an API key. Using
  /// an API key will cause the response to include the product version, health
  /// checks and various runtime metrics.
  Future<StatusResponse> retrieveStatus() async {
    return StatusResponse.fromJson(await _client.send(
      'get',
      'api/status',
    ));
  }

  /// Retrieves the FusionAuth system health. This API will return 200 if the
  /// system is healthy, and 500 if the system is un-healthy.
  Future<void> retrieveSystemHealthWithId() async {
    await _client.send(
      'get',
      'api/health',
    );
  }

  /// Retrieves the FusionAuth Reactor metrics.
  Future<ReactorMetricsResponse> retrieveReactorMetricsWithId() async {
    return ReactorMetricsResponse.fromJson(await _client.send(
      'get',
      'api/reactor/metrics',
    ));
  }

  /// Retrieves the FusionAuth version string.
  Future<VersionResponse> retrieveVersionWithId() async {
    return VersionResponse.fromJson(await _client.send(
      'get',
      'api/system/version',
    ));
  }

  /// Returns public keys used by FusionAuth to cryptographically verify JWTs
  /// using the JSON Web Key format.
  Future<JWKSResponse> retrieveJsonWebKeySetWithId() async {
    return JWKSResponse.fromJson(await _client.send(
      'get',
      '.well-known/jwks.json',
    ));
  }

  /// Retrieves the totals report. This contains all the total counts for each
  /// application and the global registration count.
  Future<TotalsReportResponse> retrieveTotalReportWithId() async {
    return TotalsReportResponse.fromJson(await _client.send(
      'get',
      'api/report/totals',
    ));
  }

  /// Retrieves the password validation rules for a specific tenant. This method
  /// requires a tenantId to be provided  through the use of a Tenant scoped API
  /// key or an HTTP header X-FusionAuth-TenantId to specify the Tenant Id.
  /// This API does not require an API key.
  Future<PasswordValidationRulesResponse>
      retrievePasswordValidationRulesWithId() async {
    return PasswordValidationRulesResponse.fromJson(await _client.send(
      'get',
      'api/tenant/password-validation-rules',
    ));
  }

  /// Retrieves all the keys.
  Future<KeyResponse> retrieveKeysWithId() async {
    return KeyResponse.fromJson(await _client.send(
      'get',
      'api/key',
    ));
  }
}

class Algorithm {
  static const es256 = Algorithm._('ES256');
  static const es384 = Algorithm._('ES384');
  static const es512 = Algorithm._('ES512');
  static const hs256 = Algorithm._('HS256');
  static const hs384 = Algorithm._('HS384');
  static const hs512 = Algorithm._('HS512');
  static const ps256 = Algorithm._('PS256');
  static const ps384 = Algorithm._('PS384');
  static const ps512 = Algorithm._('PS512');
  static const rs256 = Algorithm._('RS256');
  static const rs384 = Algorithm._('RS384');
  static const rs512 = Algorithm._('RS512');
  static const none = Algorithm._('none');

  static const values = [
    es256,
    es384,
    es512,
    hs256,
    hs384,
    hs512,
    ps256,
    ps384,
    ps512,
    rs256,
    rs384,
    rs512,
    none,
  ];
  final String value;

  const Algorithm._(this.value);

  static Algorithm fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => Algorithm._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ApplicationMultiFactorTrustPolicy {
  static const any = ApplicationMultiFactorTrustPolicy._('Any');
  static const this$ = ApplicationMultiFactorTrustPolicy._('This');
  static const none = ApplicationMultiFactorTrustPolicy._('None');

  static const values = [
    any,
    this$,
    none,
  ];
  final String value;

  const ApplicationMultiFactorTrustPolicy._(this.value);

  static ApplicationMultiFactorTrustPolicy fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ApplicationMultiFactorTrustPolicy._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class AttestationConveyancePreference {
  static const none = AttestationConveyancePreference._('none');
  static const indirect = AttestationConveyancePreference._('indirect');
  static const direct = AttestationConveyancePreference._('direct');
  static const enterprise = AttestationConveyancePreference._('enterprise');

  static const values = [
    none,
    indirect,
    direct,
    enterprise,
  ];
  final String value;

  const AttestationConveyancePreference._(this.value);

  static AttestationConveyancePreference fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => AttestationConveyancePreference._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class AttestationType {
  static const basic = AttestationType._('basic');
  static const self = AttestationType._('self');
  static const attestationCa = AttestationType._('attestationCa');
  static const anonymizationCa = AttestationType._('anonymizationCa');
  static const none = AttestationType._('none');

  static const values = [
    basic,
    self,
    attestationCa,
    anonymizationCa,
    none,
  ];
  final String value;

  const AttestationType._(this.value);

  static AttestationType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => AttestationType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class AuthenticationThreats {
  static const impossibleTravel = AuthenticationThreats._('ImpossibleTravel');

  static const values = [
    impossibleTravel,
  ];
  final String value;

  const AuthenticationThreats._(this.value);

  static AuthenticationThreats fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => AuthenticationThreats._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class AuthenticatorAttachment {
  static const platform = AuthenticatorAttachment._('platform');
  static const crossPlatform = AuthenticatorAttachment._('crossPlatform');

  static const values = [
    platform,
    crossPlatform,
  ];
  final String value;

  const AuthenticatorAttachment._(this.value);

  static AuthenticatorAttachment fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => AuthenticatorAttachment._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class AuthenticatorAttachmentPreference {
  static const any = AuthenticatorAttachmentPreference._('any');
  static const platform = AuthenticatorAttachmentPreference._('platform');
  static const crossPlatform =
      AuthenticatorAttachmentPreference._('crossPlatform');

  static const values = [
    any,
    platform,
    crossPlatform,
  ];
  final String value;

  const AuthenticatorAttachmentPreference._(this.value);

  static AuthenticatorAttachmentPreference fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => AuthenticatorAttachmentPreference._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class BreachAction {
  static const off = BreachAction._('Off');
  static const recordOnly = BreachAction._('RecordOnly');
  static const notifyUser = BreachAction._('NotifyUser');
  static const requireChange = BreachAction._('RequireChange');

  static const values = [
    off,
    recordOnly,
    notifyUser,
    requireChange,
  ];
  final String value;

  const BreachAction._(this.value);

  static BreachAction fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => BreachAction._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class BreachMatchMode {
  static const low = BreachMatchMode._('Low');
  static const medium = BreachMatchMode._('Medium');
  static const high = BreachMatchMode._('High');

  static const values = [
    low,
    medium,
    high,
  ];
  final String value;

  const BreachMatchMode._(this.value);

  static BreachMatchMode fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => BreachMatchMode._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class BreachedPasswordStatus {
  static const none = BreachedPasswordStatus._('None');
  static const exactMatch = BreachedPasswordStatus._('ExactMatch');
  static const subAddressMatch = BreachedPasswordStatus._('SubAddressMatch');
  static const passwordOnly = BreachedPasswordStatus._('PasswordOnly');
  static const commonPassword = BreachedPasswordStatus._('CommonPassword');

  static const values = [
    none,
    exactMatch,
    subAddressMatch,
    passwordOnly,
    commonPassword,
  ];
  final String value;

  const BreachedPasswordStatus._(this.value);

  static BreachedPasswordStatus fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => BreachedPasswordStatus._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class CanonicalizationMethod {
  static const exclusive = CanonicalizationMethod._('exclusive');
  static const exclusiveWithComments =
      CanonicalizationMethod._('exclusive_with_comments');
  static const inclusive = CanonicalizationMethod._('inclusive');
  static const inclusiveWithComments =
      CanonicalizationMethod._('inclusive_with_comments');

  static const values = [
    exclusive,
    exclusiveWithComments,
    inclusive,
    inclusiveWithComments,
  ];
  final String value;

  const CanonicalizationMethod._(this.value);

  static CanonicalizationMethod fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => CanonicalizationMethod._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class CaptchaMethod {
  static const googleRecaptchaV2 = CaptchaMethod._('GoogleRecaptchaV2');
  static const googleRecaptchaV3 = CaptchaMethod._('GoogleRecaptchaV3');
  static const hCaptcha = CaptchaMethod._('HCaptcha');
  static const hCaptchaEnterprise = CaptchaMethod._('HCaptchaEnterprise');

  static const values = [
    googleRecaptchaV2,
    googleRecaptchaV3,
    hCaptcha,
    hCaptchaEnterprise,
  ];
  final String value;

  const CaptchaMethod._(this.value);

  static CaptchaMethod fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => CaptchaMethod._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ChangePasswordReason {
  static const administrative = ChangePasswordReason._('Administrative');
  static const breached = ChangePasswordReason._('Breached');
  static const expired = ChangePasswordReason._('Expired');
  static const validation = ChangePasswordReason._('Validation');

  static const values = [
    administrative,
    breached,
    expired,
    validation,
  ];
  final String value;

  const ChangePasswordReason._(this.value);

  static ChangePasswordReason fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ChangePasswordReason._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ClientAuthenticationMethod {
  static const none = ClientAuthenticationMethod._('none');
  static const clientSecretBasic =
      ClientAuthenticationMethod._('client_secret_basic');
  static const clientSecretPost =
      ClientAuthenticationMethod._('client_secret_post');

  static const values = [
    none,
    clientSecretBasic,
    clientSecretPost,
  ];
  final String value;

  const ClientAuthenticationMethod._(this.value);

  static ClientAuthenticationMethod fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ClientAuthenticationMethod._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ClientAuthenticationPolicy {
  static const required = ClientAuthenticationPolicy._('Required');
  static const notRequired = ClientAuthenticationPolicy._('NotRequired');
  static const notRequiredWhenUsingPkce =
      ClientAuthenticationPolicy._('NotRequiredWhenUsingPKCE');

  static const values = [
    required,
    notRequired,
    notRequiredWhenUsingPkce,
  ];
  final String value;

  const ClientAuthenticationPolicy._(this.value);

  static ClientAuthenticationPolicy fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ClientAuthenticationPolicy._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ConnectorType {
  static const fusionAuth = ConnectorType._('FusionAuth');
  static const generic = ConnectorType._('Generic');
  static const ldap = ConnectorType._('LDAP');

  static const values = [
    fusionAuth,
    generic,
    ldap,
  ];
  final String value;

  const ConnectorType._(this.value);

  static ConnectorType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ConnectorType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ConsentStatus {
  static const active = ConsentStatus._('Active');
  static const revoked = ConsentStatus._('Revoked');

  static const values = [
    active,
    revoked,
  ];
  final String value;

  const ConsentStatus._(this.value);

  static ConsentStatus fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ConsentStatus._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ContentStatus {
  static const active = ContentStatus._('ACTIVE');
  static const pending = ContentStatus._('PENDING');
  static const rejected = ContentStatus._('REJECTED');

  static const values = [
    active,
    pending,
    rejected,
  ];
  final String value;

  const ContentStatus._(this.value);

  static ContentStatus fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ContentStatus._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class CoseAlgorithmIdentifier {
  static const es256 = CoseAlgorithmIdentifier._('ES256');
  static const es384 = CoseAlgorithmIdentifier._('ES384');
  static const es512 = CoseAlgorithmIdentifier._('ES512');
  static const rs256 = CoseAlgorithmIdentifier._('RS256');
  static const rs384 = CoseAlgorithmIdentifier._('RS384');
  static const rs512 = CoseAlgorithmIdentifier._('RS512');
  static const ps256 = CoseAlgorithmIdentifier._('PS256');
  static const ps384 = CoseAlgorithmIdentifier._('PS384');
  static const ps512 = CoseAlgorithmIdentifier._('PS512');

  static const values = [
    es256,
    es384,
    es512,
    rs256,
    rs384,
    rs512,
    ps256,
    ps384,
    ps512,
  ];
  final String value;

  const CoseAlgorithmIdentifier._(this.value);

  static CoseAlgorithmIdentifier fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => CoseAlgorithmIdentifier._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class CoseEllipticCurve {
  static const reserved = CoseEllipticCurve._('Reserved');
  static const p256 = CoseEllipticCurve._('P256');
  static const p384 = CoseEllipticCurve._('P384');
  static const p521 = CoseEllipticCurve._('P521');
  static const x25519 = CoseEllipticCurve._('X25519');
  static const x448 = CoseEllipticCurve._('X448');
  static const ed25519 = CoseEllipticCurve._('Ed25519');
  static const ed448 = CoseEllipticCurve._('Ed448');
  static const secp256K1 = CoseEllipticCurve._('Secp256k1');

  static const values = [
    reserved,
    p256,
    p384,
    p521,
    x25519,
    x448,
    ed25519,
    ed448,
    secp256K1,
  ];
  final String value;

  const CoseEllipticCurve._(this.value);

  static CoseEllipticCurve fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => CoseEllipticCurve._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class CoseKeyType {
  static const reserved = CoseKeyType._('Reserved');
  static const okp = CoseKeyType._('OKP');
  static const ec2 = CoseKeyType._('EC2');
  static const rsa = CoseKeyType._('RSA');
  static const symmetric = CoseKeyType._('Symmetric');

  static const values = [
    reserved,
    okp,
    ec2,
    rsa,
    symmetric,
  ];
  final String value;

  const CoseKeyType._(this.value);

  static CoseKeyType fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => CoseKeyType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class DeviceType {
  static const browser = DeviceType._('BROWSER');
  static const desktop = DeviceType._('DESKTOP');
  static const laptop = DeviceType._('LAPTOP');
  static const mobile = DeviceType._('MOBILE');
  static const other = DeviceType._('OTHER');
  static const server = DeviceType._('SERVER');
  static const tablet = DeviceType._('TABLET');
  static const tv = DeviceType._('TV');
  static const unknown = DeviceType._('UNKNOWN');

  static const values = [
    browser,
    desktop,
    laptop,
    mobile,
    other,
    server,
    tablet,
    tv,
    unknown,
  ];
  final String value;

  const DeviceType._(this.value);

  static DeviceType fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => DeviceType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class EmailSecurityType {
  static const none = EmailSecurityType._('NONE');
  static const ssl = EmailSecurityType._('SSL');
  static const tls = EmailSecurityType._('TLS');

  static const values = [
    none,
    ssl,
    tls,
  ];
  final String value;

  const EmailSecurityType._(this.value);

  static EmailSecurityType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => EmailSecurityType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class EventLogType {
  static const information = EventLogType._('Information');
  static const debug = EventLogType._('Debug');
  static const error = EventLogType._('Error');

  static const values = [
    information,
    debug,
    error,
  ];
  final String value;

  const EventLogType._(this.value);

  static EventLogType fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => EventLogType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class EventType {
  static const jwtPublicKeyUpdate = EventType._('JWTPublicKeyUpdate');
  static const jwtRefreshTokenRevoke = EventType._('JWTRefreshTokenRevoke');
  static const jwtRefresh = EventType._('JWTRefresh');
  static const auditLogCreate = EventType._('AuditLogCreate');
  static const eventLogCreate = EventType._('EventLogCreate');
  static const kickstartSuccess = EventType._('KickstartSuccess');
  static const groupCreate = EventType._('GroupCreate');
  static const groupCreateComplete = EventType._('GroupCreateComplete');
  static const groupDelete = EventType._('GroupDelete');
  static const groupDeleteComplete = EventType._('GroupDeleteComplete');
  static const groupMemberAdd = EventType._('GroupMemberAdd');
  static const groupMemberAddComplete = EventType._('GroupMemberAddComplete');
  static const groupMemberRemove = EventType._('GroupMemberRemove');
  static const groupMemberRemoveComplete =
      EventType._('GroupMemberRemoveComplete');
  static const groupMemberUpdate = EventType._('GroupMemberUpdate');
  static const groupMemberUpdateComplete =
      EventType._('GroupMemberUpdateComplete');
  static const groupUpdate = EventType._('GroupUpdate');
  static const groupUpdateComplete = EventType._('GroupUpdateComplete');
  static const userAction = EventType._('UserAction');
  static const userBulkCreate = EventType._('UserBulkCreate');
  static const userCreate = EventType._('UserCreate');
  static const userCreateComplete = EventType._('UserCreateComplete');
  static const userDeactivate = EventType._('UserDeactivate');
  static const userDelete = EventType._('UserDelete');
  static const userDeleteComplete = EventType._('UserDeleteComplete');
  static const userEmailUpdate = EventType._('UserEmailUpdate');
  static const userEmailVerified = EventType._('UserEmailVerified');
  static const userIdentityProviderLink =
      EventType._('UserIdentityProviderLink');
  static const userIdentityProviderUnlink =
      EventType._('UserIdentityProviderUnlink');
  static const userLoginIdDuplicateOnCreate =
      EventType._('UserLoginIdDuplicateOnCreate');
  static const userLoginIdDuplicateOnUpdate =
      EventType._('UserLoginIdDuplicateOnUpdate');
  static const userLoginFailed = EventType._('UserLoginFailed');
  static const userLoginNewDevice = EventType._('UserLoginNewDevice');
  static const userLoginSuccess = EventType._('UserLoginSuccess');
  static const userLoginSuspicious = EventType._('UserLoginSuspicious');
  static const userPasswordBreach = EventType._('UserPasswordBreach');
  static const userPasswordResetSend = EventType._('UserPasswordResetSend');
  static const userPasswordResetStart = EventType._('UserPasswordResetStart');
  static const userPasswordResetSuccess =
      EventType._('UserPasswordResetSuccess');
  static const userPasswordUpdate = EventType._('UserPasswordUpdate');
  static const userReactivate = EventType._('UserReactivate');
  static const userRegistrationCreate = EventType._('UserRegistrationCreate');
  static const userRegistrationCreateComplete =
      EventType._('UserRegistrationCreateComplete');
  static const userRegistrationDelete = EventType._('UserRegistrationDelete');
  static const userRegistrationDeleteComplete =
      EventType._('UserRegistrationDeleteComplete');
  static const userRegistrationUpdate = EventType._('UserRegistrationUpdate');
  static const userRegistrationUpdateComplete =
      EventType._('UserRegistrationUpdateComplete');
  static const userRegistrationVerified =
      EventType._('UserRegistrationVerified');
  static const userTwoFactorMethodAdd = EventType._('UserTwoFactorMethodAdd');
  static const userTwoFactorMethodRemove =
      EventType._('UserTwoFactorMethodRemove');
  static const userUpdate = EventType._('UserUpdate');
  static const userUpdateComplete = EventType._('UserUpdateComplete');
  static const test = EventType._('Test');

  static const values = [
    jwtPublicKeyUpdate,
    jwtRefreshTokenRevoke,
    jwtRefresh,
    auditLogCreate,
    eventLogCreate,
    kickstartSuccess,
    groupCreate,
    groupCreateComplete,
    groupDelete,
    groupDeleteComplete,
    groupMemberAdd,
    groupMemberAddComplete,
    groupMemberRemove,
    groupMemberRemoveComplete,
    groupMemberUpdate,
    groupMemberUpdateComplete,
    groupUpdate,
    groupUpdateComplete,
    userAction,
    userBulkCreate,
    userCreate,
    userCreateComplete,
    userDeactivate,
    userDelete,
    userDeleteComplete,
    userEmailUpdate,
    userEmailVerified,
    userIdentityProviderLink,
    userIdentityProviderUnlink,
    userLoginIdDuplicateOnCreate,
    userLoginIdDuplicateOnUpdate,
    userLoginFailed,
    userLoginNewDevice,
    userLoginSuccess,
    userLoginSuspicious,
    userPasswordBreach,
    userPasswordResetSend,
    userPasswordResetStart,
    userPasswordResetSuccess,
    userPasswordUpdate,
    userReactivate,
    userRegistrationCreate,
    userRegistrationCreateComplete,
    userRegistrationDelete,
    userRegistrationDeleteComplete,
    userRegistrationUpdate,
    userRegistrationUpdateComplete,
    userRegistrationVerified,
    userTwoFactorMethodAdd,
    userTwoFactorMethodRemove,
    userUpdate,
    userUpdateComplete,
    test,
  ];
  final String value;

  const EventType._(this.value);

  static EventType fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => EventType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ExpiryUnit {
  static const minutes = ExpiryUnit._('MINUTES');
  static const hours = ExpiryUnit._('HOURS');
  static const days = ExpiryUnit._('DAYS');
  static const weeks = ExpiryUnit._('WEEKS');
  static const months = ExpiryUnit._('MONTHS');
  static const years = ExpiryUnit._('YEARS');

  static const values = [
    minutes,
    hours,
    days,
    weeks,
    months,
    years,
  ];
  final String value;

  const ExpiryUnit._(this.value);

  static ExpiryUnit fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => ExpiryUnit._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class FamilyRole {
  static const child = FamilyRole._('Child');
  static const teen = FamilyRole._('Teen');
  static const adult = FamilyRole._('Adult');

  static const values = [
    child,
    teen,
    adult,
  ];
  final String value;

  const FamilyRole._(this.value);

  static FamilyRole fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => FamilyRole._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class FormControl {
  static const checkbox = FormControl._('checkbox');
  static const number = FormControl._('number');
  static const password = FormControl._('password');
  static const radio = FormControl._('radio');
  static const select = FormControl._('select');
  static const textarea = FormControl._('textarea');
  static const text = FormControl._('text');

  static const values = [
    checkbox,
    number,
    password,
    radio,
    select,
    textarea,
    text,
  ];
  final String value;

  const FormControl._(this.value);

  static FormControl fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => FormControl._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class FormDataType {
  static const bool$ = FormDataType._('bool');
  static const consent = FormDataType._('consent');
  static const date = FormDataType._('date');
  static const email = FormDataType._('email');
  static const number = FormDataType._('number');
  static const string = FormDataType._('string');

  static const values = [
    bool$,
    consent,
    date,
    email,
    number,
    string,
  ];
  final String value;

  const FormDataType._(this.value);

  static FormDataType fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => FormDataType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class FormFieldAdminPolicy {
  static const edit = FormFieldAdminPolicy._('Edit');
  static const view = FormFieldAdminPolicy._('View');

  static const values = [
    edit,
    view,
  ];
  final String value;

  const FormFieldAdminPolicy._(this.value);

  static FormFieldAdminPolicy fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FormFieldAdminPolicy._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class FormType {
  static const registration = FormType._('registration');
  static const adminRegistration = FormType._('adminRegistration');
  static const adminUser = FormType._('adminUser');
  static const selfServiceUser = FormType._('selfServiceUser');

  static const values = [
    registration,
    adminRegistration,
    adminUser,
    selfServiceUser,
  ];
  final String value;

  const FormType._(this.value);

  static FormType fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => FormType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class GrantType {
  static const authorizationCode = GrantType._('authorization_code');
  static const implicit = GrantType._('implicit');
  static const password = GrantType._('password');
  static const clientCredentials = GrantType._('client_credentials');
  static const refreshToken = GrantType._('refresh_token');
  static const unknown = GrantType._('unknown');
  static const deviceCode = GrantType._('device_code');

  static const values = [
    authorizationCode,
    implicit,
    password,
    clientCredentials,
    refreshToken,
    unknown,
    deviceCode,
  ];
  final String value;

  const GrantType._(this.value);

  static GrantType fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => GrantType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class HTTPMethod {
  static const get = HTTPMethod._('GET');
  static const post = HTTPMethod._('POST');
  static const put = HTTPMethod._('PUT');
  static const delete = HTTPMethod._('DELETE');
  static const head = HTTPMethod._('HEAD');
  static const options = HTTPMethod._('OPTIONS');
  static const patch = HTTPMethod._('PATCH');

  static const values = [
    get,
    post,
    put,
    delete,
    head,
    options,
    patch,
  ];
  final String value;

  const HTTPMethod._(this.value);

  static HTTPMethod fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => HTTPMethod._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class IPAccessControlEntryAction {
  static const allow = IPAccessControlEntryAction._('Allow');
  static const block = IPAccessControlEntryAction._('Block');

  static const values = [
    allow,
    block,
  ];
  final String value;

  const IPAccessControlEntryAction._(this.value);

  static IPAccessControlEntryAction fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => IPAccessControlEntryAction._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class IdentityProviderLinkingStrategy {
  static const createPendingLink =
      IdentityProviderLinkingStrategy._('CreatePendingLink');
  static const disabled = IdentityProviderLinkingStrategy._('Disabled');
  static const linkAnonymously =
      IdentityProviderLinkingStrategy._('LinkAnonymously');
  static const linkByEmail = IdentityProviderLinkingStrategy._('LinkByEmail');
  static const linkByEmailForExistingUser =
      IdentityProviderLinkingStrategy._('LinkByEmailForExistingUser');
  static const linkByUsername =
      IdentityProviderLinkingStrategy._('LinkByUsername');
  static const linkByUsernameForExistingUser =
      IdentityProviderLinkingStrategy._('LinkByUsernameForExistingUser');
  static const unsupported = IdentityProviderLinkingStrategy._('Unsupported');

  static const values = [
    createPendingLink,
    disabled,
    linkAnonymously,
    linkByEmail,
    linkByEmailForExistingUser,
    linkByUsername,
    linkByUsernameForExistingUser,
    unsupported,
  ];
  final String value;

  const IdentityProviderLinkingStrategy._(this.value);

  static IdentityProviderLinkingStrategy fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => IdentityProviderLinkingStrategy._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class IdentityProviderLoginMethod {
  static const usePopup = IdentityProviderLoginMethod._('UsePopup');
  static const useRedirect = IdentityProviderLoginMethod._('UseRedirect');
  static const useVendorJavaScript =
      IdentityProviderLoginMethod._('UseVendorJavaScript');

  static const values = [
    usePopup,
    useRedirect,
    useVendorJavaScript,
  ];
  final String value;

  const IdentityProviderLoginMethod._(this.value);

  static IdentityProviderLoginMethod fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => IdentityProviderLoginMethod._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class IdentityProviderType {
  static const apple = IdentityProviderType._('Apple');
  static const epicGames = IdentityProviderType._('EpicGames');
  static const externalJwt = IdentityProviderType._('ExternalJWT');
  static const facebook = IdentityProviderType._('Facebook');
  static const google = IdentityProviderType._('Google');
  static const hypr = IdentityProviderType._('HYPR');
  static const linkedIn = IdentityProviderType._('LinkedIn');
  static const nintendo = IdentityProviderType._('Nintendo');
  static const openIdConnect = IdentityProviderType._('OpenIDConnect');
  static const samLv2 = IdentityProviderType._('SAMLv2');
  static const samLv2IdpInitiated =
      IdentityProviderType._('SAMLv2IdPInitiated');
  static const sonyPsn = IdentityProviderType._('SonyPSN');
  static const steam = IdentityProviderType._('Steam');
  static const twitch = IdentityProviderType._('Twitch');
  static const twitter = IdentityProviderType._('Twitter');
  static const xbox = IdentityProviderType._('Xbox');

  static const values = [
    apple,
    epicGames,
    externalJwt,
    facebook,
    google,
    hypr,
    linkedIn,
    nintendo,
    openIdConnect,
    samLv2,
    samLv2IdpInitiated,
    sonyPsn,
    steam,
    twitch,
    twitter,
    xbox,
  ];
  final String value;

  const IdentityProviderType._(this.value);

  static IdentityProviderType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => IdentityProviderType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class KeyAlgorithm {
  static const es256 = KeyAlgorithm._('ES256');
  static const es384 = KeyAlgorithm._('ES384');
  static const es512 = KeyAlgorithm._('ES512');
  static const hs256 = KeyAlgorithm._('HS256');
  static const hs384 = KeyAlgorithm._('HS384');
  static const hs512 = KeyAlgorithm._('HS512');
  static const rs256 = KeyAlgorithm._('RS256');
  static const rs384 = KeyAlgorithm._('RS384');
  static const rs512 = KeyAlgorithm._('RS512');

  static const values = [
    es256,
    es384,
    es512,
    hs256,
    hs384,
    hs512,
    rs256,
    rs384,
    rs512,
  ];
  final String value;

  const KeyAlgorithm._(this.value);

  static KeyAlgorithm fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => KeyAlgorithm._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class KeyType {
  static const ec = KeyType._('EC');
  static const rsa = KeyType._('RSA');
  static const hmac = KeyType._('HMAC');

  static const values = [
    ec,
    rsa,
    hmac,
  ];
  final String value;

  const KeyType._(this.value);

  static KeyType fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => KeyType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class KeyUse {
  static const signOnly = KeyUse._('SignOnly');
  static const signAndVerify = KeyUse._('SignAndVerify');
  static const verifyOnly = KeyUse._('VerifyOnly');

  static const values = [
    signOnly,
    signAndVerify,
    verifyOnly,
  ];
  final String value;

  const KeyUse._(this.value);

  static KeyUse fromValue(String value) =>
      values.firstWhere((e) => e.value == value, orElse: () => KeyUse._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class LDAPSecurityMethod {
  static const none = LDAPSecurityMethod._('None');
  static const ldaps = LDAPSecurityMethod._('LDAPS');
  static const startTls = LDAPSecurityMethod._('StartTLS');

  static const values = [
    none,
    ldaps,
    startTls,
  ];
  final String value;

  const LDAPSecurityMethod._(this.value);

  static LDAPSecurityMethod fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => LDAPSecurityMethod._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class LambdaEngineType {
  static const graalJs = LambdaEngineType._('GraalJS');
  static const nashorn = LambdaEngineType._('Nashorn');

  static const values = [
    graalJs,
    nashorn,
  ];
  final String value;

  const LambdaEngineType._(this.value);

  static LambdaEngineType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => LambdaEngineType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class LambdaType {
  static const jwtPopulate = LambdaType._('JWTPopulate');
  static const openIdReconcile = LambdaType._('OpenIDReconcile');
  static const samLv2Reconcile = LambdaType._('SAMLv2Reconcile');
  static const samLv2Populate = LambdaType._('SAMLv2Populate');
  static const appleReconcile = LambdaType._('AppleReconcile');
  static const externalJwtReconcile = LambdaType._('ExternalJWTReconcile');
  static const facebookReconcile = LambdaType._('FacebookReconcile');
  static const googleReconcile = LambdaType._('GoogleReconcile');
  static const hyprReconcile = LambdaType._('HYPRReconcile');
  static const twitterReconcile = LambdaType._('TwitterReconcile');
  static const ldapConnectorReconcile = LambdaType._('LDAPConnectorReconcile');
  static const linkedInReconcile = LambdaType._('LinkedInReconcile');
  static const epicGamesReconcile = LambdaType._('EpicGamesReconcile');
  static const nintendoReconcile = LambdaType._('NintendoReconcile');
  static const sonyPsnReconcile = LambdaType._('SonyPSNReconcile');
  static const steamReconcile = LambdaType._('SteamReconcile');
  static const twitchReconcile = LambdaType._('TwitchReconcile');
  static const xboxReconcile = LambdaType._('XboxReconcile');
  static const clientCredentialsJwtPopulate =
      LambdaType._('ClientCredentialsJWTPopulate');
  static const scimServerGroupRequestConverter =
      LambdaType._('SCIMServerGroupRequestConverter');
  static const scimServerGroupResponseConverter =
      LambdaType._('SCIMServerGroupResponseConverter');
  static const scimServerUserRequestConverter =
      LambdaType._('SCIMServerUserRequestConverter');
  static const scimServerUserResponseConverter =
      LambdaType._('SCIMServerUserResponseConverter');
  static const selfServiceRegistrationValidation =
      LambdaType._('SelfServiceRegistrationValidation');
  static const userInfoPopulate = LambdaType._('UserInfoPopulate');
  static const loginValidation = LambdaType._('LoginValidation');

  static const values = [
    jwtPopulate,
    openIdReconcile,
    samLv2Reconcile,
    samLv2Populate,
    appleReconcile,
    externalJwtReconcile,
    facebookReconcile,
    googleReconcile,
    hyprReconcile,
    twitterReconcile,
    ldapConnectorReconcile,
    linkedInReconcile,
    epicGamesReconcile,
    nintendoReconcile,
    sonyPsnReconcile,
    steamReconcile,
    twitchReconcile,
    xboxReconcile,
    clientCredentialsJwtPopulate,
    scimServerGroupRequestConverter,
    scimServerGroupResponseConverter,
    scimServerUserRequestConverter,
    scimServerUserResponseConverter,
    selfServiceRegistrationValidation,
    userInfoPopulate,
    loginValidation,
  ];
  final String value;

  const LambdaType._(this.value);

  static LambdaType fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => LambdaType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class LoginIdType {
  static const email = LoginIdType._('email');
  static const username = LoginIdType._('username');

  static const values = [
    email,
    username,
  ];
  final String value;

  const LoginIdType._(this.value);

  static LoginIdType fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => LoginIdType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class LogoutBehavior {
  static const redirectOnly = LogoutBehavior._('RedirectOnly');
  static const allApplications = LogoutBehavior._('AllApplications');

  static const values = [
    redirectOnly,
    allApplications,
  ];
  final String value;

  const LogoutBehavior._(this.value);

  static LogoutBehavior fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => LogoutBehavior._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class MessageType {
  static const sms = MessageType._('SMS');

  static const values = [
    sms,
  ];
  final String value;

  const MessageType._(this.value);

  static MessageType fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => MessageType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class MessengerType {
  static const generic = MessengerType._('Generic');
  static const kafka = MessengerType._('Kafka');
  static const twilio = MessengerType._('Twilio');

  static const values = [
    generic,
    kafka,
    twilio,
  ];
  final String value;

  const MessengerType._(this.value);

  static MessengerType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => MessengerType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class MultiFactorLoginPolicy {
  static const disabled = MultiFactorLoginPolicy._('Disabled');
  static const enabled = MultiFactorLoginPolicy._('Enabled');
  static const required = MultiFactorLoginPolicy._('Required');

  static const values = [
    disabled,
    enabled,
    required,
  ];
  final String value;

  const MultiFactorLoginPolicy._(this.value);

  static MultiFactorLoginPolicy fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => MultiFactorLoginPolicy._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class OAuthApplicationRelationship {
  static const firstParty = OAuthApplicationRelationship._('FirstParty');
  static const thirdParty = OAuthApplicationRelationship._('ThirdParty');

  static const values = [
    firstParty,
    thirdParty,
  ];
  final String value;

  const OAuthApplicationRelationship._(this.value);

  static OAuthApplicationRelationship fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => OAuthApplicationRelationship._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class OAuthErrorReason {
  static const authCodeNotFound = OAuthErrorReason._('auth_code_not_found');
  static const accessTokenMalformed =
      OAuthErrorReason._('access_token_malformed');
  static const accessTokenExpired = OAuthErrorReason._('access_token_expired');
  static const accessTokenUnavailableForProcessing =
      OAuthErrorReason._('access_token_unavailable_for_processing');
  static const accessTokenFailedProcessing =
      OAuthErrorReason._('access_token_failed_processing');
  static const accessTokenInvalid = OAuthErrorReason._('access_token_invalid');
  static const accessTokenRequired =
      OAuthErrorReason._('access_token_required');
  static const refreshTokenNotFound =
      OAuthErrorReason._('refresh_token_not_found');
  static const refreshTokenTypeNotSupported =
      OAuthErrorReason._('refresh_token_type_not_supported');
  static const invalidClientId = OAuthErrorReason._('invalid_client_id');
  static const invalidUserCredentials =
      OAuthErrorReason._('invalid_user_credentials');
  static const invalidGrantType = OAuthErrorReason._('invalid_grant_type');
  static const invalidOrigin = OAuthErrorReason._('invalid_origin');
  static const invalidOriginOpaque =
      OAuthErrorReason._('invalid_origin_opaque');
  static const invalidPkceCodeVerifier =
      OAuthErrorReason._('invalid_pkce_code_verifier');
  static const invalidPkceCodeChallenge =
      OAuthErrorReason._('invalid_pkce_code_challenge');
  static const invalidPkceCodeChallengeMethod =
      OAuthErrorReason._('invalid_pkce_code_challenge_method');
  static const invalidRedirectUri = OAuthErrorReason._('invalid_redirect_uri');
  static const invalidResponseMode =
      OAuthErrorReason._('invalid_response_mode');
  static const invalidResponseType =
      OAuthErrorReason._('invalid_response_type');
  static const invalidIdTokenHint = OAuthErrorReason._('invalid_id_token_hint');
  static const invalidPostLogoutRedirectUri =
      OAuthErrorReason._('invalid_post_logout_redirect_uri');
  static const invalidDeviceCode = OAuthErrorReason._('invalid_device_code');
  static const invalidUserCode = OAuthErrorReason._('invalid_user_code');
  static const invalidAdditionalClientId =
      OAuthErrorReason._('invalid_additional_client_id');
  static const invalidTargetEntityScope =
      OAuthErrorReason._('invalid_target_entity_scope');
  static const invalidEntityPermissionScope =
      OAuthErrorReason._('invalid_entity_permission_scope');
  static const invalidUserId = OAuthErrorReason._('invalid_user_id');
  static const grantTypeDisabled = OAuthErrorReason._('grant_type_disabled');
  static const missingClientId = OAuthErrorReason._('missing_client_id');
  static const missingClientSecret =
      OAuthErrorReason._('missing_client_secret');
  static const missingCode = OAuthErrorReason._('missing_code');
  static const missingCodeChallenge =
      OAuthErrorReason._('missing_code_challenge');
  static const missingCodeVerifier =
      OAuthErrorReason._('missing_code_verifier');
  static const missingDeviceCode = OAuthErrorReason._('missing_device_code');
  static const missingGrantType = OAuthErrorReason._('missing_grant_type');
  static const missingRedirectUri = OAuthErrorReason._('missing_redirect_uri');
  static const missingRefreshToken =
      OAuthErrorReason._('missing_refresh_token');
  static const missingResponseType =
      OAuthErrorReason._('missing_response_type');
  static const missingToken = OAuthErrorReason._('missing_token');
  static const missingUserCode = OAuthErrorReason._('missing_user_code');
  static const missingUserId = OAuthErrorReason._('missing_user_id');
  static const missingVerificationUri =
      OAuthErrorReason._('missing_verification_uri');
  static const loginPrevented = OAuthErrorReason._('login_prevented');
  static const notLicensed = OAuthErrorReason._('not_licensed');
  static const userCodeExpired = OAuthErrorReason._('user_code_expired');
  static const userExpired = OAuthErrorReason._('user_expired');
  static const userLocked = OAuthErrorReason._('user_locked');
  static const userNotFound = OAuthErrorReason._('user_not_found');
  static const clientAuthenticationMissing =
      OAuthErrorReason._('client_authentication_missing');
  static const invalidClientAuthenticationScheme =
      OAuthErrorReason._('invalid_client_authentication_scheme');
  static const invalidClientAuthentication =
      OAuthErrorReason._('invalid_client_authentication');
  static const clientIdMismatch = OAuthErrorReason._('client_id_mismatch');
  static const changePasswordAdministrative =
      OAuthErrorReason._('change_password_administrative');
  static const changePasswordBreached =
      OAuthErrorReason._('change_password_breached');
  static const changePasswordExpired =
      OAuthErrorReason._('change_password_expired');
  static const changePasswordValidation =
      OAuthErrorReason._('change_password_validation');
  static const unknown = OAuthErrorReason._('unknown');
  static const missingRequiredScope =
      OAuthErrorReason._('missing_required_scope');
  static const unknownScope = OAuthErrorReason._('unknown_scope');
  static const consentCanceled = OAuthErrorReason._('consent_canceled');

  static const values = [
    authCodeNotFound,
    accessTokenMalformed,
    accessTokenExpired,
    accessTokenUnavailableForProcessing,
    accessTokenFailedProcessing,
    accessTokenInvalid,
    accessTokenRequired,
    refreshTokenNotFound,
    refreshTokenTypeNotSupported,
    invalidClientId,
    invalidUserCredentials,
    invalidGrantType,
    invalidOrigin,
    invalidOriginOpaque,
    invalidPkceCodeVerifier,
    invalidPkceCodeChallenge,
    invalidPkceCodeChallengeMethod,
    invalidRedirectUri,
    invalidResponseMode,
    invalidResponseType,
    invalidIdTokenHint,
    invalidPostLogoutRedirectUri,
    invalidDeviceCode,
    invalidUserCode,
    invalidAdditionalClientId,
    invalidTargetEntityScope,
    invalidEntityPermissionScope,
    invalidUserId,
    grantTypeDisabled,
    missingClientId,
    missingClientSecret,
    missingCode,
    missingCodeChallenge,
    missingCodeVerifier,
    missingDeviceCode,
    missingGrantType,
    missingRedirectUri,
    missingRefreshToken,
    missingResponseType,
    missingToken,
    missingUserCode,
    missingUserId,
    missingVerificationUri,
    loginPrevented,
    notLicensed,
    userCodeExpired,
    userExpired,
    userLocked,
    userNotFound,
    clientAuthenticationMissing,
    invalidClientAuthenticationScheme,
    invalidClientAuthentication,
    clientIdMismatch,
    changePasswordAdministrative,
    changePasswordBreached,
    changePasswordExpired,
    changePasswordValidation,
    unknown,
    missingRequiredScope,
    unknownScope,
    consentCanceled,
  ];
  final String value;

  const OAuthErrorReason._(this.value);

  static OAuthErrorReason fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => OAuthErrorReason._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class OAuthErrorType {
  static const invalidRequest = OAuthErrorType._('invalid_request');
  static const invalidClient = OAuthErrorType._('invalid_client');
  static const invalidGrant = OAuthErrorType._('invalid_grant');
  static const invalidToken = OAuthErrorType._('invalid_token');
  static const unauthorizedClient = OAuthErrorType._('unauthorized_client');
  static const invalidScope = OAuthErrorType._('invalid_scope');
  static const serverError = OAuthErrorType._('server_error');
  static const unsupportedGrantType =
      OAuthErrorType._('unsupported_grant_type');
  static const unsupportedResponseType =
      OAuthErrorType._('unsupported_response_type');
  static const accessDenied = OAuthErrorType._('access_denied');
  static const changePasswordRequired =
      OAuthErrorType._('change_password_required');
  static const notLicensed = OAuthErrorType._('not_licensed');
  static const twoFactorRequired = OAuthErrorType._('two_factor_required');
  static const authorizationPending = OAuthErrorType._('authorization_pending');
  static const expiredToken = OAuthErrorType._('expired_token');
  static const unsupportedTokenType =
      OAuthErrorType._('unsupported_token_type');

  static const values = [
    invalidRequest,
    invalidClient,
    invalidGrant,
    invalidToken,
    unauthorizedClient,
    invalidScope,
    serverError,
    unsupportedGrantType,
    unsupportedResponseType,
    accessDenied,
    changePasswordRequired,
    notLicensed,
    twoFactorRequired,
    authorizationPending,
    expiredToken,
    unsupportedTokenType,
  ];
  final String value;

  const OAuthErrorType._(this.value);

  static OAuthErrorType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => OAuthErrorType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class OAuthScopeConsentMode {
  static const alwaysPrompt = OAuthScopeConsentMode._('AlwaysPrompt');
  static const rememberDecision = OAuthScopeConsentMode._('RememberDecision');
  static const neverPrompt = OAuthScopeConsentMode._('NeverPrompt');

  static const values = [
    alwaysPrompt,
    rememberDecision,
    neverPrompt,
  ];
  final String value;

  const OAuthScopeConsentMode._(this.value);

  static OAuthScopeConsentMode fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => OAuthScopeConsentMode._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class OAuthScopeHandlingPolicy {
  static const compatibility = OAuthScopeHandlingPolicy._('Compatibility');
  static const strict = OAuthScopeHandlingPolicy._('Strict');

  static const values = [
    compatibility,
    strict,
  ];
  final String value;

  const OAuthScopeHandlingPolicy._(this.value);

  static OAuthScopeHandlingPolicy fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => OAuthScopeHandlingPolicy._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class Oauth2AuthorizedURLValidationPolicy {
  static const allowWildcards =
      Oauth2AuthorizedURLValidationPolicy._('AllowWildcards');
  static const exactMatch = Oauth2AuthorizedURLValidationPolicy._('ExactMatch');

  static const values = [
    allowWildcards,
    exactMatch,
  ];
  final String value;

  const Oauth2AuthorizedURLValidationPolicy._(this.value);

  static Oauth2AuthorizedURLValidationPolicy fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => Oauth2AuthorizedURLValidationPolicy._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ObjectState {
  static const active = ObjectState._('Active');
  static const inactive = ObjectState._('Inactive');
  static const pendingDelete = ObjectState._('PendingDelete');

  static const values = [
    active,
    inactive,
    pendingDelete,
  ];
  final String value;

  const ObjectState._(this.value);

  static ObjectState fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => ObjectState._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ProofKeyForCodeExchangePolicy {
  static const required = ProofKeyForCodeExchangePolicy._('Required');
  static const notRequired = ProofKeyForCodeExchangePolicy._('NotRequired');
  static const notRequiredWhenUsingClientAuthentication =
      ProofKeyForCodeExchangePolicy._(
          'NotRequiredWhenUsingClientAuthentication');

  static const values = [
    required,
    notRequired,
    notRequiredWhenUsingClientAuthentication,
  ];
  final String value;

  const ProofKeyForCodeExchangePolicy._(this.value);

  static ProofKeyForCodeExchangePolicy fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProofKeyForCodeExchangePolicy._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class PublicKeyCredentialType {
  static const publicKey = PublicKeyCredentialType._('publicKey');

  static const values = [
    publicKey,
  ];
  final String value;

  const PublicKeyCredentialType._(this.value);

  static PublicKeyCredentialType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => PublicKeyCredentialType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class RateLimitedRequestType {
  static const failedLogin = RateLimitedRequestType._('FailedLogin');
  static const forgotPassword = RateLimitedRequestType._('ForgotPassword');
  static const sendEmailVerification =
      RateLimitedRequestType._('SendEmailVerification');
  static const sendPasswordless = RateLimitedRequestType._('SendPasswordless');
  static const sendRegistrationVerification =
      RateLimitedRequestType._('SendRegistrationVerification');
  static const sendTwoFactor = RateLimitedRequestType._('SendTwoFactor');

  static const values = [
    failedLogin,
    forgotPassword,
    sendEmailVerification,
    sendPasswordless,
    sendRegistrationVerification,
    sendTwoFactor,
  ];
  final String value;

  const RateLimitedRequestType._(this.value);

  static RateLimitedRequestType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => RateLimitedRequestType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ReactorFeatureStatus {
  static const active = ReactorFeatureStatus._('ACTIVE');
  static const disconnected = ReactorFeatureStatus._('DISCONNECTED');
  static const pending = ReactorFeatureStatus._('PENDING');
  static const disabled = ReactorFeatureStatus._('DISABLED');
  static const unknown = ReactorFeatureStatus._('UNKNOWN');

  static const values = [
    active,
    disconnected,
    pending,
    disabled,
    unknown,
  ];
  final String value;

  const ReactorFeatureStatus._(this.value);

  static ReactorFeatureStatus fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ReactorFeatureStatus._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class RefreshTokenExpirationPolicy {
  static const fixed = RefreshTokenExpirationPolicy._('Fixed');
  static const slidingWindow = RefreshTokenExpirationPolicy._('SlidingWindow');
  static const slidingWindowWithMaximumLifetime =
      RefreshTokenExpirationPolicy._('SlidingWindowWithMaximumLifetime');

  static const values = [
    fixed,
    slidingWindow,
    slidingWindowWithMaximumLifetime,
  ];
  final String value;

  const RefreshTokenExpirationPolicy._(this.value);

  static RefreshTokenExpirationPolicy fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => RefreshTokenExpirationPolicy._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class RefreshTokenUsagePolicy {
  static const reusable = RefreshTokenUsagePolicy._('Reusable');
  static const oneTimeUse = RefreshTokenUsagePolicy._('OneTimeUse');

  static const values = [
    reusable,
    oneTimeUse,
  ];
  final String value;

  const RefreshTokenUsagePolicy._(this.value);

  static RefreshTokenUsagePolicy fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => RefreshTokenUsagePolicy._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class RegistrationType {
  static const basic = RegistrationType._('basic');
  static const advanced = RegistrationType._('advanced');

  static const values = [
    basic,
    advanced,
  ];
  final String value;

  const RegistrationType._(this.value);

  static RegistrationType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => RegistrationType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ResidentKeyRequirement {
  static const discouraged = ResidentKeyRequirement._('discouraged');
  static const preferred = ResidentKeyRequirement._('preferred');
  static const required = ResidentKeyRequirement._('required');

  static const values = [
    discouraged,
    preferred,
    required,
  ];
  final String value;

  const ResidentKeyRequirement._(this.value);

  static ResidentKeyRequirement fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ResidentKeyRequirement._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class SAMLLogoutBehavior {
  static const allParticipants = SAMLLogoutBehavior._('AllParticipants');
  static const onlyOriginator = SAMLLogoutBehavior._('OnlyOriginator');

  static const values = [
    allParticipants,
    onlyOriginator,
  ];
  final String value;

  const SAMLLogoutBehavior._(this.value);

  static SAMLLogoutBehavior fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => SAMLLogoutBehavior._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class SAMLv2DestinationAssertionPolicy {
  static const enabled = SAMLv2DestinationAssertionPolicy._('Enabled');
  static const disabled = SAMLv2DestinationAssertionPolicy._('Disabled');
  static const allowAlternates =
      SAMLv2DestinationAssertionPolicy._('AllowAlternates');

  static const values = [
    enabled,
    disabled,
    allowAlternates,
  ];
  final String value;

  const SAMLv2DestinationAssertionPolicy._(this.value);

  static SAMLv2DestinationAssertionPolicy fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => SAMLv2DestinationAssertionPolicy._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class SecureGeneratorType {
  static const randomDigits = SecureGeneratorType._('randomDigits');
  static const randomBytes = SecureGeneratorType._('randomBytes');
  static const randomAlpha = SecureGeneratorType._('randomAlpha');
  static const randomAlphaNumeric = SecureGeneratorType._('randomAlphaNumeric');

  static const values = [
    randomDigits,
    randomBytes,
    randomAlpha,
    randomAlphaNumeric,
  ];
  final String value;

  const SecureGeneratorType._(this.value);

  static SecureGeneratorType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => SecureGeneratorType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class Sort {
  static const asc = Sort._('asc');
  static const desc = Sort._('desc');

  static const values = [
    asc,
    desc,
  ];
  final String value;

  const Sort._(this.value);

  static Sort fromValue(String value) =>
      values.firstWhere((e) => e.value == value, orElse: () => Sort._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class SteamAPIMode {
  static const public = SteamAPIMode._('Public');
  static const partner = SteamAPIMode._('Partner');

  static const values = [
    public,
    partner,
  ];
  final String value;

  const SteamAPIMode._(this.value);

  static SteamAPIMode fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => SteamAPIMode._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class SystemTrustedProxyConfigurationPolicy {
  static const all = SystemTrustedProxyConfigurationPolicy._('All');
  static const onlyConfigured =
      SystemTrustedProxyConfigurationPolicy._('OnlyConfigured');

  static const values = [
    all,
    onlyConfigured,
  ];
  final String value;

  const SystemTrustedProxyConfigurationPolicy._(this.value);

  static SystemTrustedProxyConfigurationPolicy fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => SystemTrustedProxyConfigurationPolicy._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class TOTPAlgorithm {
  static const hmacSha1 = TOTPAlgorithm._('HmacSHA1');
  static const hmacSha256 = TOTPAlgorithm._('HmacSHA256');
  static const hmacSha512 = TOTPAlgorithm._('HmacSHA512');

  static const values = [
    hmacSha1,
    hmacSha256,
    hmacSha512,
  ];
  final String value;

  const TOTPAlgorithm._(this.value);

  static TOTPAlgorithm fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => TOTPAlgorithm._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ThemeType {
  static const advanced = ThemeType._('advanced');
  static const simple = ThemeType._('simple');

  static const values = [
    advanced,
    simple,
  ];
  final String value;

  const ThemeType._(this.value);

  static ThemeType fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => ThemeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class TokenType {
  static const bearer = TokenType._('Bearer');
  static const mac = TokenType._('MAC');

  static const values = [
    bearer,
    mac,
  ];
  final String value;

  const TokenType._(this.value);

  static TokenType fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => TokenType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class TransactionType {
  static const none = TransactionType._('None');
  static const any = TransactionType._('Any');
  static const simpleMajority = TransactionType._('SimpleMajority');
  static const superMajority = TransactionType._('SuperMajority');
  static const absoluteMajority = TransactionType._('AbsoluteMajority');

  static const values = [
    none,
    any,
    simpleMajority,
    superMajority,
    absoluteMajority,
  ];
  final String value;

  const TransactionType._(this.value);

  static TransactionType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => TransactionType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class UniqueUsernameStrategy {
  static const always = UniqueUsernameStrategy._('Always');
  static const onCollision = UniqueUsernameStrategy._('OnCollision');

  static const values = [
    always,
    onCollision,
  ];
  final String value;

  const UniqueUsernameStrategy._(this.value);

  static UniqueUsernameStrategy fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => UniqueUsernameStrategy._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class UnknownScopePolicy {
  static const allow = UnknownScopePolicy._('Allow');
  static const remove = UnknownScopePolicy._('Remove');
  static const reject = UnknownScopePolicy._('Reject');

  static const values = [
    allow,
    remove,
    reject,
  ];
  final String value;

  const UnknownScopePolicy._(this.value);

  static UnknownScopePolicy fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => UnknownScopePolicy._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class UnverifiedBehavior {
  static const allow = UnverifiedBehavior._('Allow');
  static const gated = UnverifiedBehavior._('Gated');

  static const values = [
    allow,
    gated,
  ];
  final String value;

  const UnverifiedBehavior._(this.value);

  static UnverifiedBehavior fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => UnverifiedBehavior._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class UserActionPhase {
  static const start = UserActionPhase._('start');
  static const modify = UserActionPhase._('modify');
  static const cancel = UserActionPhase._('cancel');
  static const end = UserActionPhase._('end');

  static const values = [
    start,
    modify,
    cancel,
    end,
  ];
  final String value;

  const UserActionPhase._(this.value);

  static UserActionPhase fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => UserActionPhase._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class UserState {
  static const authenticated = UserState._('Authenticated');
  static const authenticatedNotRegistered =
      UserState._('AuthenticatedNotRegistered');
  static const authenticatedNotVerified =
      UserState._('AuthenticatedNotVerified');
  static const authenticatedRegistrationNotVerified =
      UserState._('AuthenticatedRegistrationNotVerified');

  static const values = [
    authenticated,
    authenticatedNotRegistered,
    authenticatedNotVerified,
    authenticatedRegistrationNotVerified,
  ];
  final String value;

  const UserState._(this.value);

  static UserState fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => UserState._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class UserVerificationRequirement {
  static const required = UserVerificationRequirement._('required');
  static const preferred = UserVerificationRequirement._('preferred');
  static const discouraged = UserVerificationRequirement._('discouraged');

  static const values = [
    required,
    preferred,
    discouraged,
  ];
  final String value;

  const UserVerificationRequirement._(this.value);

  static UserVerificationRequirement fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => UserVerificationRequirement._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class VerificationStrategy {
  static const clickableLink = VerificationStrategy._('ClickableLink');
  static const formField = VerificationStrategy._('FormField');

  static const values = [
    clickableLink,
    formField,
  ];
  final String value;

  const VerificationStrategy._(this.value);

  static VerificationStrategy fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => VerificationStrategy._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class WebAuthnWorkflow {
  static const bootstrap = WebAuthnWorkflow._('bootstrap');
  static const general = WebAuthnWorkflow._('general');
  static const reauthentication = WebAuthnWorkflow._('reauthentication');

  static const values = [
    bootstrap,
    general,
    reauthentication,
  ];
  final String value;

  const WebAuthnWorkflow._(this.value);

  static WebAuthnWorkflow fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => WebAuthnWorkflow._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class WebhookAttemptResult {
  static const success = WebhookAttemptResult._('Success');
  static const failure = WebhookAttemptResult._('Failure');
  static const unknown = WebhookAttemptResult._('Unknown');

  static const values = [
    success,
    failure,
    unknown,
  ];
  final String value;

  const WebhookAttemptResult._(this.value);

  static WebhookAttemptResult fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => WebhookAttemptResult._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class WebhookEventResult {
  static const failed = WebhookEventResult._('Failed');
  static const running = WebhookEventResult._('Running');
  static const succeeded = WebhookEventResult._('Succeeded');

  static const values = [
    failed,
    running,
    succeeded,
  ];
  final String value;

  const WebhookEventResult._(this.value);

  static WebhookEventResult fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => WebhookEventResult._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class XMLSignatureLocation {
  static const assertion = XMLSignatureLocation._('Assertion');
  static const response = XMLSignatureLocation._('Response');

  static const values = [
    assertion,
    response,
  ];
  final String value;

  const XMLSignatureLocation._(this.value);

  static XMLSignatureLocation fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => XMLSignatureLocation._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// domain POJO to represent AuthenticationKey
class APIKey {
  final String? id;
  final ZonedDateTime? insertInstant;
  final String? ipAccessControlListId;
  final String? key;
  final bool keyManager;
  final ZonedDateTime? lastUpdateInstant;
  final APIKeyMetaData? metaData;
  final APIKeyPermissions? permissions;
  final String? tenantId;

  APIKey(
      {this.id,
      this.insertInstant,
      this.ipAccessControlListId,
      this.key,
      bool? keyManager,
      this.lastUpdateInstant,
      this.metaData,
      this.permissions,
      this.tenantId})
      : keyManager = keyManager ?? false;

  factory APIKey.fromJson(Map<String, Object?> json) {
    return APIKey(
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      ipAccessControlListId: json[r'ipAccessControlListId'] as String?,
      key: json[r'key'] as String?,
      keyManager: json[r'keyManager'] as bool? ?? false,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      metaData: json[r'metaData'] != null
          ? APIKeyMetaData.fromJson(json[r'metaData']! as Map<String, Object?>)
          : null,
      permissions: json[r'permissions'] != null
          ? APIKeyPermissions.fromJson(
              json[r'permissions']! as Map<String, Object?>)
          : null,
      tenantId: json[r'tenantId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var insertInstant = this.insertInstant;
    var ipAccessControlListId = this.ipAccessControlListId;
    var key = this.key;
    var keyManager = this.keyManager;
    var lastUpdateInstant = this.lastUpdateInstant;
    var metaData = this.metaData;
    var permissions = this.permissions;
    var tenantId = this.tenantId;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (ipAccessControlListId != null) {
      json[r'ipAccessControlListId'] = ipAccessControlListId;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    json[r'keyManager'] = keyManager;
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (metaData != null) {
      json[r'metaData'] = metaData.toJson();
    }
    if (permissions != null) {
      json[r'permissions'] = permissions.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    return json;
  }

  APIKey copyWith(
      {String? id,
      ZonedDateTime? insertInstant,
      String? ipAccessControlListId,
      String? key,
      bool? keyManager,
      ZonedDateTime? lastUpdateInstant,
      APIKeyMetaData? metaData,
      APIKeyPermissions? permissions,
      String? tenantId}) {
    return APIKey(
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      ipAccessControlListId:
          ipAccessControlListId ?? this.ipAccessControlListId,
      key: key ?? this.key,
      keyManager: keyManager ?? this.keyManager,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      metaData: metaData ?? this.metaData,
      permissions: permissions ?? this.permissions,
      tenantId: tenantId ?? this.tenantId,
    );
  }
}

class APIKeyMetaData {
  final Map<String, dynamic>? attributes;

  APIKeyMetaData({this.attributes});

  factory APIKeyMetaData.fromJson(Map<String, Object?> json) {
    return APIKeyMetaData(
      attributes: json[r'attributes'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var attributes = this.attributes;

    final json = <String, Object?>{};
    if (attributes != null) {
      json[r'attributes'] = attributes;
    }
    return json;
  }

  APIKeyMetaData copyWith({Map<String, dynamic>? attributes}) {
    return APIKeyMetaData(
      attributes: attributes ?? this.attributes,
    );
  }
}

class APIKeyPermissions {
  final Map<String, dynamic>? endpoints;

  APIKeyPermissions({this.endpoints});

  factory APIKeyPermissions.fromJson(Map<String, Object?> json) {
    return APIKeyPermissions(
      endpoints: json[r'endpoints'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var endpoints = this.endpoints;

    final json = <String, Object?>{};
    if (endpoints != null) {
      json[r'endpoints'] = endpoints;
    }
    return json;
  }

  APIKeyPermissions copyWith({Map<String, dynamic>? endpoints}) {
    return APIKeyPermissions(
      endpoints: endpoints ?? this.endpoints,
    );
  }
}

/// Authentication key request object.
class APIKeyRequest {
  final APIKey? apiKey;
  final String? sourceKeyId;

  APIKeyRequest({this.apiKey, this.sourceKeyId});

  factory APIKeyRequest.fromJson(Map<String, Object?> json) {
    return APIKeyRequest(
      apiKey: json[r'apiKey'] != null
          ? APIKey.fromJson(json[r'apiKey']! as Map<String, Object?>)
          : null,
      sourceKeyId: json[r'sourceKeyId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var apiKey = this.apiKey;
    var sourceKeyId = this.sourceKeyId;

    final json = <String, Object?>{};
    if (apiKey != null) {
      json[r'apiKey'] = apiKey.toJson();
    }
    if (sourceKeyId != null) {
      json[r'sourceKeyId'] = sourceKeyId;
    }
    return json;
  }

  APIKeyRequest copyWith({APIKey? apiKey, String? sourceKeyId}) {
    return APIKeyRequest(
      apiKey: apiKey ?? this.apiKey,
      sourceKeyId: sourceKeyId ?? this.sourceKeyId,
    );
  }
}

/// Authentication key response object.
class APIKeyResponse {
  final APIKey? apiKey;

  APIKeyResponse({this.apiKey});

  factory APIKeyResponse.fromJson(Map<String, Object?> json) {
    return APIKeyResponse(
      apiKey: json[r'apiKey'] != null
          ? APIKey.fromJson(json[r'apiKey']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var apiKey = this.apiKey;

    final json = <String, Object?>{};
    if (apiKey != null) {
      json[r'apiKey'] = apiKey.toJson();
    }
    return json;
  }

  APIKeyResponse copyWith({APIKey? apiKey}) {
    return APIKeyResponse(
      apiKey: apiKey ?? this.apiKey,
    );
  }
}

class AccessToken {
  final int? expiresIn;
  final String? idToken;
  final String? refreshToken;
  final String? refreshTokenId;
  final String? scope;
  final String? accessToken;
  final TokenType? tokenType;
  final String? userId;

  AccessToken(
      {this.expiresIn,
      this.idToken,
      this.refreshToken,
      this.refreshTokenId,
      this.scope,
      this.accessToken,
      this.tokenType,
      this.userId});

  factory AccessToken.fromJson(Map<String, Object?> json) {
    return AccessToken(
      expiresIn: (json[r'expires_in'] as num?)?.toInt(),
      idToken: json[r'id_token'] as String?,
      refreshToken: json[r'refresh_token'] as String?,
      refreshTokenId: json[r'refresh_token_id'] as String?,
      scope: json[r'scope'] as String?,
      accessToken: json[r'access_token'] as String?,
      tokenType: json[r'token_type'] != null
          ? TokenType.fromValue(json[r'token_type']! as String)
          : null,
      userId: json[r'userId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var expiresIn = this.expiresIn;
    var idToken = this.idToken;
    var refreshToken = this.refreshToken;
    var refreshTokenId = this.refreshTokenId;
    var scope = this.scope;
    var accessToken = this.accessToken;
    var tokenType = this.tokenType;
    var userId = this.userId;

    final json = <String, Object?>{};
    if (expiresIn != null) {
      json[r'expires_in'] = expiresIn;
    }
    if (idToken != null) {
      json[r'id_token'] = idToken;
    }
    if (refreshToken != null) {
      json[r'refresh_token'] = refreshToken;
    }
    if (refreshTokenId != null) {
      json[r'refresh_token_id'] = refreshTokenId;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (accessToken != null) {
      json[r'access_token'] = accessToken;
    }
    if (tokenType != null) {
      json[r'token_type'] = tokenType.value;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    return json;
  }

  AccessToken copyWith(
      {int? expiresIn,
      String? idToken,
      String? refreshToken,
      String? refreshTokenId,
      String? scope,
      String? accessToken,
      TokenType? tokenType,
      String? userId}) {
    return AccessToken(
      expiresIn: expiresIn ?? this.expiresIn,
      idToken: idToken ?? this.idToken,
      refreshToken: refreshToken ?? this.refreshToken,
      refreshTokenId: refreshTokenId ?? this.refreshTokenId,
      scope: scope ?? this.scope,
      accessToken: accessToken ?? this.accessToken,
      tokenType: tokenType ?? this.tokenType,
      userId: userId ?? this.userId,
    );
  }
}

class ActionData {
  final String? actioneeUserId;
  final String? actionerUserId;
  final List<String> applicationIds;
  final String? comment;
  final bool emailUser;
  final ZonedDateTime? expiry;
  final bool notifyUser;
  final String? option;
  final String? reasonId;
  final String? userActionId;

  ActionData(
      {this.actioneeUserId,
      this.actionerUserId,
      List<String>? applicationIds,
      this.comment,
      bool? emailUser,
      this.expiry,
      bool? notifyUser,
      this.option,
      this.reasonId,
      this.userActionId})
      : applicationIds = applicationIds ?? [],
        emailUser = emailUser ?? false,
        notifyUser = notifyUser ?? false;

  factory ActionData.fromJson(Map<String, Object?> json) {
    return ActionData(
      actioneeUserId: json[r'actioneeUserId'] as String?,
      actionerUserId: json[r'actionerUserId'] as String?,
      applicationIds: (json[r'applicationIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      comment: json[r'comment'] as String?,
      emailUser: json[r'emailUser'] as bool? ?? false,
      expiry: (json[r'expiry'] as num?)?.toInt() as ZonedDateTime?,
      notifyUser: json[r'notifyUser'] as bool? ?? false,
      option: json[r'option'] as String?,
      reasonId: json[r'reasonId'] as String?,
      userActionId: json[r'userActionId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var actioneeUserId = this.actioneeUserId;
    var actionerUserId = this.actionerUserId;
    var applicationIds = this.applicationIds;
    var comment = this.comment;
    var emailUser = this.emailUser;
    var expiry = this.expiry;
    var notifyUser = this.notifyUser;
    var option = this.option;
    var reasonId = this.reasonId;
    var userActionId = this.userActionId;

    final json = <String, Object?>{};
    if (actioneeUserId != null) {
      json[r'actioneeUserId'] = actioneeUserId;
    }
    if (actionerUserId != null) {
      json[r'actionerUserId'] = actionerUserId;
    }
    json[r'applicationIds'] = applicationIds;
    if (comment != null) {
      json[r'comment'] = comment;
    }
    json[r'emailUser'] = emailUser;
    if (expiry != null) {
      json[r'expiry'] = expiry.toJson();
    }
    json[r'notifyUser'] = notifyUser;
    if (option != null) {
      json[r'option'] = option;
    }
    if (reasonId != null) {
      json[r'reasonId'] = reasonId;
    }
    if (userActionId != null) {
      json[r'userActionId'] = userActionId;
    }
    return json;
  }

  ActionData copyWith(
      {String? actioneeUserId,
      String? actionerUserId,
      List<String>? applicationIds,
      String? comment,
      bool? emailUser,
      ZonedDateTime? expiry,
      bool? notifyUser,
      String? option,
      String? reasonId,
      String? userActionId}) {
    return ActionData(
      actioneeUserId: actioneeUserId ?? this.actioneeUserId,
      actionerUserId: actionerUserId ?? this.actionerUserId,
      applicationIds: applicationIds ?? this.applicationIds,
      comment: comment ?? this.comment,
      emailUser: emailUser ?? this.emailUser,
      expiry: expiry ?? this.expiry,
      notifyUser: notifyUser ?? this.notifyUser,
      option: option ?? this.option,
      reasonId: reasonId ?? this.reasonId,
      userActionId: userActionId ?? this.userActionId,
    );
  }
}

/// The user action request object.
class ActionRequest {
  final ActionData? action;
  final bool broadcast;
  final EventInfo? eventInfo;

  ActionRequest({this.action, bool? broadcast, this.eventInfo})
      : broadcast = broadcast ?? false;

  factory ActionRequest.fromJson(Map<String, Object?> json) {
    return ActionRequest(
      action: json[r'action'] != null
          ? ActionData.fromJson(json[r'action']! as Map<String, Object?>)
          : null,
      broadcast: json[r'broadcast'] as bool? ?? false,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var action = this.action;
    var broadcast = this.broadcast;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (action != null) {
      json[r'action'] = action.toJson();
    }
    json[r'broadcast'] = broadcast;
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  ActionRequest copyWith(
      {ActionData? action, bool? broadcast, EventInfo? eventInfo}) {
    return ActionRequest(
      action: action ?? this.action,
      broadcast: broadcast ?? this.broadcast,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

/// The user action response object.
class ActionResponse {
  final UserActionLog? action;
  final List<UserActionLog> actions;

  ActionResponse({this.action, List<UserActionLog>? actions})
      : actions = actions ?? [];

  factory ActionResponse.fromJson(Map<String, Object?> json) {
    return ActionResponse(
      action: json[r'action'] != null
          ? UserActionLog.fromJson(json[r'action']! as Map<String, Object?>)
          : null,
      actions: (json[r'actions'] as List<Object?>?)
              ?.map((i) => UserActionLog.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var action = this.action;
    var actions = this.actions;

    final json = <String, Object?>{};
    if (action != null) {
      json[r'action'] = action.toJson();
    }
    json[r'actions'] = actions.map((i) => i.toJson()).toList();
    return json;
  }

  ActionResponse copyWith(
      {UserActionLog? action, List<UserActionLog>? actions}) {
    return ActionResponse(
      action: action ?? this.action,
      actions: actions ?? this.actions,
    );
  }
}

class AppleApplicationConfiguration {
  final String? bundleId;
  final String? buttonText;
  final String? keyId;
  final String? scope;
  final String? servicesId;
  final String? teamId;
  final Map<String, dynamic>? data;
  final bool createRegistration;

  AppleApplicationConfiguration(
      {this.bundleId,
      this.buttonText,
      this.keyId,
      this.scope,
      this.servicesId,
      this.teamId,
      this.data,
      bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory AppleApplicationConfiguration.fromJson(Map<String, Object?> json) {
    return AppleApplicationConfiguration(
      bundleId: json[r'bundleId'] as String?,
      buttonText: json[r'buttonText'] as String?,
      keyId: json[r'keyId'] as String?,
      scope: json[r'scope'] as String?,
      servicesId: json[r'servicesId'] as String?,
      teamId: json[r'teamId'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var bundleId = this.bundleId;
    var buttonText = this.buttonText;
    var keyId = this.keyId;
    var scope = this.scope;
    var servicesId = this.servicesId;
    var teamId = this.teamId;
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (bundleId != null) {
      json[r'bundleId'] = bundleId;
    }
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (keyId != null) {
      json[r'keyId'] = keyId;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (servicesId != null) {
      json[r'servicesId'] = servicesId;
    }
    if (teamId != null) {
      json[r'teamId'] = teamId;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  AppleApplicationConfiguration copyWith(
      {String? bundleId,
      String? buttonText,
      String? keyId,
      String? scope,
      String? servicesId,
      String? teamId,
      Map<String, dynamic>? data,
      bool? createRegistration}) {
    return AppleApplicationConfiguration(
      bundleId: bundleId ?? this.bundleId,
      buttonText: buttonText ?? this.buttonText,
      keyId: keyId ?? this.keyId,
      scope: scope ?? this.scope,
      servicesId: servicesId ?? this.servicesId,
      teamId: teamId ?? this.teamId,
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

class AppleIdentityProvider {
  final String? bundleId;
  final String? buttonText;
  final String? keyId;
  final String? scope;
  final String? servicesId;
  final String? teamId;
  final Map<String, dynamic>? data;
  final Map<String, dynamic>? applicationConfiguration;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ProviderLambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final IdentityProviderLinkingStrategy? linkingStrategy;
  final String? name;
  final Map<String, dynamic>? tenantConfiguration;
  final IdentityProviderType? type;

  AppleIdentityProvider(
      {this.bundleId,
      this.buttonText,
      this.keyId,
      this.scope,
      this.servicesId,
      this.teamId,
      this.data,
      this.applicationConfiguration,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.linkingStrategy,
      this.name,
      this.tenantConfiguration,
      this.type})
      : debug = debug ?? false;

  factory AppleIdentityProvider.fromJson(Map<String, Object?> json) {
    return AppleIdentityProvider(
      bundleId: json[r'bundleId'] as String?,
      buttonText: json[r'buttonText'] as String?,
      keyId: json[r'keyId'] as String?,
      scope: json[r'scope'] as String?,
      servicesId: json[r'servicesId'] as String?,
      teamId: json[r'teamId'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      applicationConfiguration:
          json[r'applicationConfiguration'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? ProviderLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      linkingStrategy: json[r'linkingStrategy'] != null
          ? IdentityProviderLinkingStrategy.fromValue(
              json[r'linkingStrategy']! as String)
          : null,
      name: json[r'name'] as String?,
      tenantConfiguration:
          json[r'tenantConfiguration'] as Map<String, Object?>?,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var bundleId = this.bundleId;
    var buttonText = this.buttonText;
    var keyId = this.keyId;
    var scope = this.scope;
    var servicesId = this.servicesId;
    var teamId = this.teamId;
    var data = this.data;
    var applicationConfiguration = this.applicationConfiguration;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var linkingStrategy = this.linkingStrategy;
    var name = this.name;
    var tenantConfiguration = this.tenantConfiguration;
    var type = this.type;

    final json = <String, Object?>{};
    if (bundleId != null) {
      json[r'bundleId'] = bundleId;
    }
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (keyId != null) {
      json[r'keyId'] = keyId;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (servicesId != null) {
      json[r'servicesId'] = servicesId;
    }
    if (teamId != null) {
      json[r'teamId'] = teamId;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (applicationConfiguration != null) {
      json[r'applicationConfiguration'] = applicationConfiguration;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (linkingStrategy != null) {
      json[r'linkingStrategy'] = linkingStrategy.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (tenantConfiguration != null) {
      json[r'tenantConfiguration'] = tenantConfiguration;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  AppleIdentityProvider copyWith(
      {String? bundleId,
      String? buttonText,
      String? keyId,
      String? scope,
      String? servicesId,
      String? teamId,
      Map<String, dynamic>? data,
      Map<String, dynamic>? applicationConfiguration,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ProviderLambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      IdentityProviderLinkingStrategy? linkingStrategy,
      String? name,
      Map<String, dynamic>? tenantConfiguration,
      IdentityProviderType? type}) {
    return AppleIdentityProvider(
      bundleId: bundleId ?? this.bundleId,
      buttonText: buttonText ?? this.buttonText,
      keyId: keyId ?? this.keyId,
      scope: scope ?? this.scope,
      servicesId: servicesId ?? this.servicesId,
      teamId: teamId ?? this.teamId,
      data: data ?? this.data,
      applicationConfiguration:
          applicationConfiguration ?? this.applicationConfiguration,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      linkingStrategy: linkingStrategy ?? this.linkingStrategy,
      name: name ?? this.name,
      tenantConfiguration: tenantConfiguration ?? this.tenantConfiguration,
      type: type ?? this.type,
    );
  }
}

class Application {
  final ApplicationAccessControlConfiguration? accessControlConfiguration;
  final bool active;
  final AuthenticationTokenConfiguration? authenticationTokenConfiguration;
  final CleanSpeakConfiguration? cleanSpeakConfiguration;
  final Map<String, dynamic>? data;
  final ApplicationEmailConfiguration? emailConfiguration;
  final ApplicationExternalIdentifierConfiguration?
      externalIdentifierConfiguration;
  final ApplicationFormConfiguration? formConfiguration;
  final String? id;
  final ZonedDateTime? insertInstant;
  final JWTConfiguration? jwtConfiguration;
  final LambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final LoginConfiguration? loginConfiguration;
  final ApplicationMultiFactorConfiguration? multiFactorConfiguration;
  final String? name;
  final OAuth2Configuration? oauthConfiguration;
  final PasswordlessConfiguration? passwordlessConfiguration;
  final RegistrationConfiguration? registrationConfiguration;
  final ApplicationRegistrationDeletePolicy? registrationDeletePolicy;
  final List<ApplicationRole> roles;
  final SAMLv2Configuration? samlv2Configuration;
  final List<ApplicationOAuthScope> scopes;
  final ObjectState? state;
  final String? tenantId;
  final String? themeId;
  final RegistrationUnverifiedOptions? unverified;
  final String? verificationEmailTemplateId;
  final VerificationStrategy? verificationStrategy;
  final bool verifyRegistration;
  final ApplicationWebAuthnConfiguration? webAuthnConfiguration;

  Application(
      {this.accessControlConfiguration,
      bool? active,
      this.authenticationTokenConfiguration,
      this.cleanSpeakConfiguration,
      this.data,
      this.emailConfiguration,
      this.externalIdentifierConfiguration,
      this.formConfiguration,
      this.id,
      this.insertInstant,
      this.jwtConfiguration,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.loginConfiguration,
      this.multiFactorConfiguration,
      this.name,
      this.oauthConfiguration,
      this.passwordlessConfiguration,
      this.registrationConfiguration,
      this.registrationDeletePolicy,
      List<ApplicationRole>? roles,
      this.samlv2Configuration,
      List<ApplicationOAuthScope>? scopes,
      this.state,
      this.tenantId,
      this.themeId,
      this.unverified,
      this.verificationEmailTemplateId,
      this.verificationStrategy,
      bool? verifyRegistration,
      this.webAuthnConfiguration})
      : active = active ?? false,
        roles = roles ?? [],
        scopes = scopes ?? [],
        verifyRegistration = verifyRegistration ?? false;

  factory Application.fromJson(Map<String, Object?> json) {
    return Application(
      accessControlConfiguration: json[r'accessControlConfiguration'] != null
          ? ApplicationAccessControlConfiguration.fromJson(
              json[r'accessControlConfiguration']! as Map<String, Object?>)
          : null,
      active: json[r'active'] as bool? ?? false,
      authenticationTokenConfiguration:
          json[r'authenticationTokenConfiguration'] != null
              ? AuthenticationTokenConfiguration.fromJson(
                  json[r'authenticationTokenConfiguration']!
                      as Map<String, Object?>)
              : null,
      cleanSpeakConfiguration: json[r'cleanSpeakConfiguration'] != null
          ? CleanSpeakConfiguration.fromJson(
              json[r'cleanSpeakConfiguration']! as Map<String, Object?>)
          : null,
      data: json[r'data'] as Map<String, Object?>?,
      emailConfiguration: json[r'emailConfiguration'] != null
          ? ApplicationEmailConfiguration.fromJson(
              json[r'emailConfiguration']! as Map<String, Object?>)
          : null,
      externalIdentifierConfiguration:
          json[r'externalIdentifierConfiguration'] != null
              ? ApplicationExternalIdentifierConfiguration.fromJson(
                  json[r'externalIdentifierConfiguration']!
                      as Map<String, Object?>)
              : null,
      formConfiguration: json[r'formConfiguration'] != null
          ? ApplicationFormConfiguration.fromJson(
              json[r'formConfiguration']! as Map<String, Object?>)
          : null,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      jwtConfiguration: json[r'jwtConfiguration'] != null
          ? JWTConfiguration.fromJson(
              json[r'jwtConfiguration']! as Map<String, Object?>)
          : null,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? LambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      loginConfiguration: json[r'loginConfiguration'] != null
          ? LoginConfiguration.fromJson(
              json[r'loginConfiguration']! as Map<String, Object?>)
          : null,
      multiFactorConfiguration: json[r'multiFactorConfiguration'] != null
          ? ApplicationMultiFactorConfiguration.fromJson(
              json[r'multiFactorConfiguration']! as Map<String, Object?>)
          : null,
      name: json[r'name'] as String?,
      oauthConfiguration: json[r'oauthConfiguration'] != null
          ? OAuth2Configuration.fromJson(
              json[r'oauthConfiguration']! as Map<String, Object?>)
          : null,
      passwordlessConfiguration: json[r'passwordlessConfiguration'] != null
          ? PasswordlessConfiguration.fromJson(
              json[r'passwordlessConfiguration']! as Map<String, Object?>)
          : null,
      registrationConfiguration: json[r'registrationConfiguration'] != null
          ? RegistrationConfiguration.fromJson(
              json[r'registrationConfiguration']! as Map<String, Object?>)
          : null,
      registrationDeletePolicy: json[r'registrationDeletePolicy'] != null
          ? ApplicationRegistrationDeletePolicy.fromJson(
              json[r'registrationDeletePolicy']! as Map<String, Object?>)
          : null,
      roles: (json[r'roles'] as List<Object?>?)
              ?.map((i) => ApplicationRole.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      samlv2Configuration: json[r'samlv2Configuration'] != null
          ? SAMLv2Configuration.fromJson(
              json[r'samlv2Configuration']! as Map<String, Object?>)
          : null,
      scopes: (json[r'scopes'] as List<Object?>?)
              ?.map((i) => ApplicationOAuthScope.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      state: json[r'state'] != null
          ? ObjectState.fromValue(json[r'state']! as String)
          : null,
      tenantId: json[r'tenantId'] as String?,
      themeId: json[r'themeId'] as String?,
      unverified: json[r'unverified'] != null
          ? RegistrationUnverifiedOptions.fromJson(
              json[r'unverified']! as Map<String, Object?>)
          : null,
      verificationEmailTemplateId:
          json[r'verificationEmailTemplateId'] as String?,
      verificationStrategy: json[r'verificationStrategy'] != null
          ? VerificationStrategy.fromValue(
              json[r'verificationStrategy']! as String)
          : null,
      verifyRegistration: json[r'verifyRegistration'] as bool? ?? false,
      webAuthnConfiguration: json[r'webAuthnConfiguration'] != null
          ? ApplicationWebAuthnConfiguration.fromJson(
              json[r'webAuthnConfiguration']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var accessControlConfiguration = this.accessControlConfiguration;
    var active = this.active;
    var authenticationTokenConfiguration =
        this.authenticationTokenConfiguration;
    var cleanSpeakConfiguration = this.cleanSpeakConfiguration;
    var data = this.data;
    var emailConfiguration = this.emailConfiguration;
    var externalIdentifierConfiguration = this.externalIdentifierConfiguration;
    var formConfiguration = this.formConfiguration;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var jwtConfiguration = this.jwtConfiguration;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var loginConfiguration = this.loginConfiguration;
    var multiFactorConfiguration = this.multiFactorConfiguration;
    var name = this.name;
    var oauthConfiguration = this.oauthConfiguration;
    var passwordlessConfiguration = this.passwordlessConfiguration;
    var registrationConfiguration = this.registrationConfiguration;
    var registrationDeletePolicy = this.registrationDeletePolicy;
    var roles = this.roles;
    var samlv2Configuration = this.samlv2Configuration;
    var scopes = this.scopes;
    var state = this.state;
    var tenantId = this.tenantId;
    var themeId = this.themeId;
    var unverified = this.unverified;
    var verificationEmailTemplateId = this.verificationEmailTemplateId;
    var verificationStrategy = this.verificationStrategy;
    var verifyRegistration = this.verifyRegistration;
    var webAuthnConfiguration = this.webAuthnConfiguration;

    final json = <String, Object?>{};
    if (accessControlConfiguration != null) {
      json[r'accessControlConfiguration'] = accessControlConfiguration.toJson();
    }
    json[r'active'] = active;
    if (authenticationTokenConfiguration != null) {
      json[r'authenticationTokenConfiguration'] =
          authenticationTokenConfiguration.toJson();
    }
    if (cleanSpeakConfiguration != null) {
      json[r'cleanSpeakConfiguration'] = cleanSpeakConfiguration.toJson();
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (emailConfiguration != null) {
      json[r'emailConfiguration'] = emailConfiguration.toJson();
    }
    if (externalIdentifierConfiguration != null) {
      json[r'externalIdentifierConfiguration'] =
          externalIdentifierConfiguration.toJson();
    }
    if (formConfiguration != null) {
      json[r'formConfiguration'] = formConfiguration.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (jwtConfiguration != null) {
      json[r'jwtConfiguration'] = jwtConfiguration.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (loginConfiguration != null) {
      json[r'loginConfiguration'] = loginConfiguration.toJson();
    }
    if (multiFactorConfiguration != null) {
      json[r'multiFactorConfiguration'] = multiFactorConfiguration.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (oauthConfiguration != null) {
      json[r'oauthConfiguration'] = oauthConfiguration.toJson();
    }
    if (passwordlessConfiguration != null) {
      json[r'passwordlessConfiguration'] = passwordlessConfiguration.toJson();
    }
    if (registrationConfiguration != null) {
      json[r'registrationConfiguration'] = registrationConfiguration.toJson();
    }
    if (registrationDeletePolicy != null) {
      json[r'registrationDeletePolicy'] = registrationDeletePolicy.toJson();
    }
    json[r'roles'] = roles.map((i) => i.toJson()).toList();
    if (samlv2Configuration != null) {
      json[r'samlv2Configuration'] = samlv2Configuration.toJson();
    }
    json[r'scopes'] = scopes.map((i) => i.toJson()).toList();
    if (state != null) {
      json[r'state'] = state.value;
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (themeId != null) {
      json[r'themeId'] = themeId;
    }
    if (unverified != null) {
      json[r'unverified'] = unverified.toJson();
    }
    if (verificationEmailTemplateId != null) {
      json[r'verificationEmailTemplateId'] = verificationEmailTemplateId;
    }
    if (verificationStrategy != null) {
      json[r'verificationStrategy'] = verificationStrategy.value;
    }
    json[r'verifyRegistration'] = verifyRegistration;
    if (webAuthnConfiguration != null) {
      json[r'webAuthnConfiguration'] = webAuthnConfiguration.toJson();
    }
    return json;
  }

  Application copyWith(
      {ApplicationAccessControlConfiguration? accessControlConfiguration,
      bool? active,
      AuthenticationTokenConfiguration? authenticationTokenConfiguration,
      CleanSpeakConfiguration? cleanSpeakConfiguration,
      Map<String, dynamic>? data,
      ApplicationEmailConfiguration? emailConfiguration,
      ApplicationExternalIdentifierConfiguration?
          externalIdentifierConfiguration,
      ApplicationFormConfiguration? formConfiguration,
      String? id,
      ZonedDateTime? insertInstant,
      JWTConfiguration? jwtConfiguration,
      LambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      LoginConfiguration? loginConfiguration,
      ApplicationMultiFactorConfiguration? multiFactorConfiguration,
      String? name,
      OAuth2Configuration? oauthConfiguration,
      PasswordlessConfiguration? passwordlessConfiguration,
      RegistrationConfiguration? registrationConfiguration,
      ApplicationRegistrationDeletePolicy? registrationDeletePolicy,
      List<ApplicationRole>? roles,
      SAMLv2Configuration? samlv2Configuration,
      List<ApplicationOAuthScope>? scopes,
      ObjectState? state,
      String? tenantId,
      String? themeId,
      RegistrationUnverifiedOptions? unverified,
      String? verificationEmailTemplateId,
      VerificationStrategy? verificationStrategy,
      bool? verifyRegistration,
      ApplicationWebAuthnConfiguration? webAuthnConfiguration}) {
    return Application(
      accessControlConfiguration:
          accessControlConfiguration ?? this.accessControlConfiguration,
      active: active ?? this.active,
      authenticationTokenConfiguration: authenticationTokenConfiguration ??
          this.authenticationTokenConfiguration,
      cleanSpeakConfiguration:
          cleanSpeakConfiguration ?? this.cleanSpeakConfiguration,
      data: data ?? this.data,
      emailConfiguration: emailConfiguration ?? this.emailConfiguration,
      externalIdentifierConfiguration: externalIdentifierConfiguration ??
          this.externalIdentifierConfiguration,
      formConfiguration: formConfiguration ?? this.formConfiguration,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      jwtConfiguration: jwtConfiguration ?? this.jwtConfiguration,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      loginConfiguration: loginConfiguration ?? this.loginConfiguration,
      multiFactorConfiguration:
          multiFactorConfiguration ?? this.multiFactorConfiguration,
      name: name ?? this.name,
      oauthConfiguration: oauthConfiguration ?? this.oauthConfiguration,
      passwordlessConfiguration:
          passwordlessConfiguration ?? this.passwordlessConfiguration,
      registrationConfiguration:
          registrationConfiguration ?? this.registrationConfiguration,
      registrationDeletePolicy:
          registrationDeletePolicy ?? this.registrationDeletePolicy,
      roles: roles ?? this.roles,
      samlv2Configuration: samlv2Configuration ?? this.samlv2Configuration,
      scopes: scopes ?? this.scopes,
      state: state ?? this.state,
      tenantId: tenantId ?? this.tenantId,
      themeId: themeId ?? this.themeId,
      unverified: unverified ?? this.unverified,
      verificationEmailTemplateId:
          verificationEmailTemplateId ?? this.verificationEmailTemplateId,
      verificationStrategy: verificationStrategy ?? this.verificationStrategy,
      verifyRegistration: verifyRegistration ?? this.verifyRegistration,
      webAuthnConfiguration:
          webAuthnConfiguration ?? this.webAuthnConfiguration,
    );
  }
}

class ApplicationAccessControlConfiguration {
  final String? uiIpAccessControlListId;

  ApplicationAccessControlConfiguration({this.uiIpAccessControlListId});

  factory ApplicationAccessControlConfiguration.fromJson(
      Map<String, Object?> json) {
    return ApplicationAccessControlConfiguration(
      uiIpAccessControlListId: json[r'uiIPAccessControlListId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var uiIpAccessControlListId = this.uiIpAccessControlListId;

    final json = <String, Object?>{};
    if (uiIpAccessControlListId != null) {
      json[r'uiIPAccessControlListId'] = uiIpAccessControlListId;
    }
    return json;
  }

  ApplicationAccessControlConfiguration copyWith(
      {String? uiIpAccessControlListId}) {
    return ApplicationAccessControlConfiguration(
      uiIpAccessControlListId:
          uiIpAccessControlListId ?? this.uiIpAccessControlListId,
    );
  }
}

class ApplicationEmailConfiguration {
  final String? emailUpdateEmailTemplateId;
  final String? emailVerificationEmailTemplateId;
  final String? emailVerifiedEmailTemplateId;
  final String? forgotPasswordEmailTemplateId;
  final String? loginIdInUseOnCreateEmailTemplateId;
  final String? loginIdInUseOnUpdateEmailTemplateId;
  final String? loginNewDeviceEmailTemplateId;
  final String? loginSuspiciousEmailTemplateId;
  final String? passwordResetSuccessEmailTemplateId;
  final String? passwordUpdateEmailTemplateId;
  final String? passwordlessEmailTemplateId;
  final String? setPasswordEmailTemplateId;
  final String? twoFactorMethodAddEmailTemplateId;
  final String? twoFactorMethodRemoveEmailTemplateId;

  ApplicationEmailConfiguration(
      {this.emailUpdateEmailTemplateId,
      this.emailVerificationEmailTemplateId,
      this.emailVerifiedEmailTemplateId,
      this.forgotPasswordEmailTemplateId,
      this.loginIdInUseOnCreateEmailTemplateId,
      this.loginIdInUseOnUpdateEmailTemplateId,
      this.loginNewDeviceEmailTemplateId,
      this.loginSuspiciousEmailTemplateId,
      this.passwordResetSuccessEmailTemplateId,
      this.passwordUpdateEmailTemplateId,
      this.passwordlessEmailTemplateId,
      this.setPasswordEmailTemplateId,
      this.twoFactorMethodAddEmailTemplateId,
      this.twoFactorMethodRemoveEmailTemplateId});

  factory ApplicationEmailConfiguration.fromJson(Map<String, Object?> json) {
    return ApplicationEmailConfiguration(
      emailUpdateEmailTemplateId:
          json[r'emailUpdateEmailTemplateId'] as String?,
      emailVerificationEmailTemplateId:
          json[r'emailVerificationEmailTemplateId'] as String?,
      emailVerifiedEmailTemplateId:
          json[r'emailVerifiedEmailTemplateId'] as String?,
      forgotPasswordEmailTemplateId:
          json[r'forgotPasswordEmailTemplateId'] as String?,
      loginIdInUseOnCreateEmailTemplateId:
          json[r'loginIdInUseOnCreateEmailTemplateId'] as String?,
      loginIdInUseOnUpdateEmailTemplateId:
          json[r'loginIdInUseOnUpdateEmailTemplateId'] as String?,
      loginNewDeviceEmailTemplateId:
          json[r'loginNewDeviceEmailTemplateId'] as String?,
      loginSuspiciousEmailTemplateId:
          json[r'loginSuspiciousEmailTemplateId'] as String?,
      passwordResetSuccessEmailTemplateId:
          json[r'passwordResetSuccessEmailTemplateId'] as String?,
      passwordUpdateEmailTemplateId:
          json[r'passwordUpdateEmailTemplateId'] as String?,
      passwordlessEmailTemplateId:
          json[r'passwordlessEmailTemplateId'] as String?,
      setPasswordEmailTemplateId:
          json[r'setPasswordEmailTemplateId'] as String?,
      twoFactorMethodAddEmailTemplateId:
          json[r'twoFactorMethodAddEmailTemplateId'] as String?,
      twoFactorMethodRemoveEmailTemplateId:
          json[r'twoFactorMethodRemoveEmailTemplateId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var emailUpdateEmailTemplateId = this.emailUpdateEmailTemplateId;
    var emailVerificationEmailTemplateId =
        this.emailVerificationEmailTemplateId;
    var emailVerifiedEmailTemplateId = this.emailVerifiedEmailTemplateId;
    var forgotPasswordEmailTemplateId = this.forgotPasswordEmailTemplateId;
    var loginIdInUseOnCreateEmailTemplateId =
        this.loginIdInUseOnCreateEmailTemplateId;
    var loginIdInUseOnUpdateEmailTemplateId =
        this.loginIdInUseOnUpdateEmailTemplateId;
    var loginNewDeviceEmailTemplateId = this.loginNewDeviceEmailTemplateId;
    var loginSuspiciousEmailTemplateId = this.loginSuspiciousEmailTemplateId;
    var passwordResetSuccessEmailTemplateId =
        this.passwordResetSuccessEmailTemplateId;
    var passwordUpdateEmailTemplateId = this.passwordUpdateEmailTemplateId;
    var passwordlessEmailTemplateId = this.passwordlessEmailTemplateId;
    var setPasswordEmailTemplateId = this.setPasswordEmailTemplateId;
    var twoFactorMethodAddEmailTemplateId =
        this.twoFactorMethodAddEmailTemplateId;
    var twoFactorMethodRemoveEmailTemplateId =
        this.twoFactorMethodRemoveEmailTemplateId;

    final json = <String, Object?>{};
    if (emailUpdateEmailTemplateId != null) {
      json[r'emailUpdateEmailTemplateId'] = emailUpdateEmailTemplateId;
    }
    if (emailVerificationEmailTemplateId != null) {
      json[r'emailVerificationEmailTemplateId'] =
          emailVerificationEmailTemplateId;
    }
    if (emailVerifiedEmailTemplateId != null) {
      json[r'emailVerifiedEmailTemplateId'] = emailVerifiedEmailTemplateId;
    }
    if (forgotPasswordEmailTemplateId != null) {
      json[r'forgotPasswordEmailTemplateId'] = forgotPasswordEmailTemplateId;
    }
    if (loginIdInUseOnCreateEmailTemplateId != null) {
      json[r'loginIdInUseOnCreateEmailTemplateId'] =
          loginIdInUseOnCreateEmailTemplateId;
    }
    if (loginIdInUseOnUpdateEmailTemplateId != null) {
      json[r'loginIdInUseOnUpdateEmailTemplateId'] =
          loginIdInUseOnUpdateEmailTemplateId;
    }
    if (loginNewDeviceEmailTemplateId != null) {
      json[r'loginNewDeviceEmailTemplateId'] = loginNewDeviceEmailTemplateId;
    }
    if (loginSuspiciousEmailTemplateId != null) {
      json[r'loginSuspiciousEmailTemplateId'] = loginSuspiciousEmailTemplateId;
    }
    if (passwordResetSuccessEmailTemplateId != null) {
      json[r'passwordResetSuccessEmailTemplateId'] =
          passwordResetSuccessEmailTemplateId;
    }
    if (passwordUpdateEmailTemplateId != null) {
      json[r'passwordUpdateEmailTemplateId'] = passwordUpdateEmailTemplateId;
    }
    if (passwordlessEmailTemplateId != null) {
      json[r'passwordlessEmailTemplateId'] = passwordlessEmailTemplateId;
    }
    if (setPasswordEmailTemplateId != null) {
      json[r'setPasswordEmailTemplateId'] = setPasswordEmailTemplateId;
    }
    if (twoFactorMethodAddEmailTemplateId != null) {
      json[r'twoFactorMethodAddEmailTemplateId'] =
          twoFactorMethodAddEmailTemplateId;
    }
    if (twoFactorMethodRemoveEmailTemplateId != null) {
      json[r'twoFactorMethodRemoveEmailTemplateId'] =
          twoFactorMethodRemoveEmailTemplateId;
    }
    return json;
  }

  ApplicationEmailConfiguration copyWith(
      {String? emailUpdateEmailTemplateId,
      String? emailVerificationEmailTemplateId,
      String? emailVerifiedEmailTemplateId,
      String? forgotPasswordEmailTemplateId,
      String? loginIdInUseOnCreateEmailTemplateId,
      String? loginIdInUseOnUpdateEmailTemplateId,
      String? loginNewDeviceEmailTemplateId,
      String? loginSuspiciousEmailTemplateId,
      String? passwordResetSuccessEmailTemplateId,
      String? passwordUpdateEmailTemplateId,
      String? passwordlessEmailTemplateId,
      String? setPasswordEmailTemplateId,
      String? twoFactorMethodAddEmailTemplateId,
      String? twoFactorMethodRemoveEmailTemplateId}) {
    return ApplicationEmailConfiguration(
      emailUpdateEmailTemplateId:
          emailUpdateEmailTemplateId ?? this.emailUpdateEmailTemplateId,
      emailVerificationEmailTemplateId: emailVerificationEmailTemplateId ??
          this.emailVerificationEmailTemplateId,
      emailVerifiedEmailTemplateId:
          emailVerifiedEmailTemplateId ?? this.emailVerifiedEmailTemplateId,
      forgotPasswordEmailTemplateId:
          forgotPasswordEmailTemplateId ?? this.forgotPasswordEmailTemplateId,
      loginIdInUseOnCreateEmailTemplateId:
          loginIdInUseOnCreateEmailTemplateId ??
              this.loginIdInUseOnCreateEmailTemplateId,
      loginIdInUseOnUpdateEmailTemplateId:
          loginIdInUseOnUpdateEmailTemplateId ??
              this.loginIdInUseOnUpdateEmailTemplateId,
      loginNewDeviceEmailTemplateId:
          loginNewDeviceEmailTemplateId ?? this.loginNewDeviceEmailTemplateId,
      loginSuspiciousEmailTemplateId:
          loginSuspiciousEmailTemplateId ?? this.loginSuspiciousEmailTemplateId,
      passwordResetSuccessEmailTemplateId:
          passwordResetSuccessEmailTemplateId ??
              this.passwordResetSuccessEmailTemplateId,
      passwordUpdateEmailTemplateId:
          passwordUpdateEmailTemplateId ?? this.passwordUpdateEmailTemplateId,
      passwordlessEmailTemplateId:
          passwordlessEmailTemplateId ?? this.passwordlessEmailTemplateId,
      setPasswordEmailTemplateId:
          setPasswordEmailTemplateId ?? this.setPasswordEmailTemplateId,
      twoFactorMethodAddEmailTemplateId: twoFactorMethodAddEmailTemplateId ??
          this.twoFactorMethodAddEmailTemplateId,
      twoFactorMethodRemoveEmailTemplateId:
          twoFactorMethodRemoveEmailTemplateId ??
              this.twoFactorMethodRemoveEmailTemplateId,
    );
  }
}

/// Events that are bound to applications.
class ApplicationEvent {
  ApplicationEvent();

  factory ApplicationEvent.fromJson(Map<String, Object?> json) {
    return ApplicationEvent();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class ApplicationExternalIdentifierConfiguration {
  final int? twoFactorTrustIdTimeToLiveInSeconds;

  ApplicationExternalIdentifierConfiguration(
      {this.twoFactorTrustIdTimeToLiveInSeconds});

  factory ApplicationExternalIdentifierConfiguration.fromJson(
      Map<String, Object?> json) {
    return ApplicationExternalIdentifierConfiguration(
      twoFactorTrustIdTimeToLiveInSeconds:
          (json[r'twoFactorTrustIdTimeToLiveInSeconds'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var twoFactorTrustIdTimeToLiveInSeconds =
        this.twoFactorTrustIdTimeToLiveInSeconds;

    final json = <String, Object?>{};
    if (twoFactorTrustIdTimeToLiveInSeconds != null) {
      json[r'twoFactorTrustIdTimeToLiveInSeconds'] =
          twoFactorTrustIdTimeToLiveInSeconds;
    }
    return json;
  }

  ApplicationExternalIdentifierConfiguration copyWith(
      {int? twoFactorTrustIdTimeToLiveInSeconds}) {
    return ApplicationExternalIdentifierConfiguration(
      twoFactorTrustIdTimeToLiveInSeconds:
          twoFactorTrustIdTimeToLiveInSeconds ??
              this.twoFactorTrustIdTimeToLiveInSeconds,
    );
  }
}

class ApplicationFormConfiguration {
  final String? adminRegistrationFormId;
  final SelfServiceFormConfiguration? selfServiceFormConfiguration;
  final String? selfServiceFormId;

  ApplicationFormConfiguration(
      {this.adminRegistrationFormId,
      this.selfServiceFormConfiguration,
      this.selfServiceFormId});

  factory ApplicationFormConfiguration.fromJson(Map<String, Object?> json) {
    return ApplicationFormConfiguration(
      adminRegistrationFormId: json[r'adminRegistrationFormId'] as String?,
      selfServiceFormConfiguration: json[r'selfServiceFormConfiguration'] !=
              null
          ? SelfServiceFormConfiguration.fromJson(
              json[r'selfServiceFormConfiguration']! as Map<String, Object?>)
          : null,
      selfServiceFormId: json[r'selfServiceFormId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var adminRegistrationFormId = this.adminRegistrationFormId;
    var selfServiceFormConfiguration = this.selfServiceFormConfiguration;
    var selfServiceFormId = this.selfServiceFormId;

    final json = <String, Object?>{};
    if (adminRegistrationFormId != null) {
      json[r'adminRegistrationFormId'] = adminRegistrationFormId;
    }
    if (selfServiceFormConfiguration != null) {
      json[r'selfServiceFormConfiguration'] =
          selfServiceFormConfiguration.toJson();
    }
    if (selfServiceFormId != null) {
      json[r'selfServiceFormId'] = selfServiceFormId;
    }
    return json;
  }

  ApplicationFormConfiguration copyWith(
      {String? adminRegistrationFormId,
      SelfServiceFormConfiguration? selfServiceFormConfiguration,
      String? selfServiceFormId}) {
    return ApplicationFormConfiguration(
      adminRegistrationFormId:
          adminRegistrationFormId ?? this.adminRegistrationFormId,
      selfServiceFormConfiguration:
          selfServiceFormConfiguration ?? this.selfServiceFormConfiguration,
      selfServiceFormId: selfServiceFormId ?? this.selfServiceFormId,
    );
  }
}

class ApplicationMultiFactorConfiguration {
  final MultiFactorEmailTemplate? email;
  final MultiFactorLoginPolicy? loginPolicy;
  final MultiFactorSMSTemplate? sms;
  final ApplicationMultiFactorTrustPolicy? trustPolicy;

  ApplicationMultiFactorConfiguration(
      {this.email, this.loginPolicy, this.sms, this.trustPolicy});

  factory ApplicationMultiFactorConfiguration.fromJson(
      Map<String, Object?> json) {
    return ApplicationMultiFactorConfiguration(
      email: json[r'email'] != null
          ? MultiFactorEmailTemplate.fromJson(
              json[r'email']! as Map<String, Object?>)
          : null,
      loginPolicy: json[r'loginPolicy'] != null
          ? MultiFactorLoginPolicy.fromValue(json[r'loginPolicy']! as String)
          : null,
      sms: json[r'sms'] != null
          ? MultiFactorSMSTemplate.fromJson(
              json[r'sms']! as Map<String, Object?>)
          : null,
      trustPolicy: json[r'trustPolicy'] != null
          ? ApplicationMultiFactorTrustPolicy.fromValue(
              json[r'trustPolicy']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var email = this.email;
    var loginPolicy = this.loginPolicy;
    var sms = this.sms;
    var trustPolicy = this.trustPolicy;

    final json = <String, Object?>{};
    if (email != null) {
      json[r'email'] = email.toJson();
    }
    if (loginPolicy != null) {
      json[r'loginPolicy'] = loginPolicy.value;
    }
    if (sms != null) {
      json[r'sms'] = sms.toJson();
    }
    if (trustPolicy != null) {
      json[r'trustPolicy'] = trustPolicy.value;
    }
    return json;
  }

  ApplicationMultiFactorConfiguration copyWith(
      {MultiFactorEmailTemplate? email,
      MultiFactorLoginPolicy? loginPolicy,
      MultiFactorSMSTemplate? sms,
      ApplicationMultiFactorTrustPolicy? trustPolicy}) {
    return ApplicationMultiFactorConfiguration(
      email: email ?? this.email,
      loginPolicy: loginPolicy ?? this.loginPolicy,
      sms: sms ?? this.sms,
      trustPolicy: trustPolicy ?? this.trustPolicy,
    );
  }
}

/// A custom OAuth scope for a specific application.
class ApplicationOAuthScope {
  final String? applicationId;
  final Map<String, dynamic>? data;
  final String? defaultConsentDetail;
  final String? defaultConsentMessage;
  final String? description;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final bool required;

  ApplicationOAuthScope(
      {this.applicationId,
      this.data,
      this.defaultConsentDetail,
      this.defaultConsentMessage,
      this.description,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.name,
      bool? required})
      : required = required ?? false;

  factory ApplicationOAuthScope.fromJson(Map<String, Object?> json) {
    return ApplicationOAuthScope(
      applicationId: json[r'applicationId'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      defaultConsentDetail: json[r'defaultConsentDetail'] as String?,
      defaultConsentMessage: json[r'defaultConsentMessage'] as String?,
      description: json[r'description'] as String?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      required: json[r'required'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var data = this.data;
    var defaultConsentDetail = this.defaultConsentDetail;
    var defaultConsentMessage = this.defaultConsentMessage;
    var description = this.description;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var required = this.required;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (defaultConsentDetail != null) {
      json[r'defaultConsentDetail'] = defaultConsentDetail;
    }
    if (defaultConsentMessage != null) {
      json[r'defaultConsentMessage'] = defaultConsentMessage;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'required'] = required;
    return json;
  }

  ApplicationOAuthScope copyWith(
      {String? applicationId,
      Map<String, dynamic>? data,
      String? defaultConsentDetail,
      String? defaultConsentMessage,
      String? description,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      bool? required}) {
    return ApplicationOAuthScope(
      applicationId: applicationId ?? this.applicationId,
      data: data ?? this.data,
      defaultConsentDetail: defaultConsentDetail ?? this.defaultConsentDetail,
      defaultConsentMessage:
          defaultConsentMessage ?? this.defaultConsentMessage,
      description: description ?? this.description,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      required: required ?? this.required,
    );
  }
}

/// The Application Scope API request object.
class ApplicationOAuthScopeRequest {
  final ApplicationOAuthScope? scope;

  ApplicationOAuthScopeRequest({this.scope});

  factory ApplicationOAuthScopeRequest.fromJson(Map<String, Object?> json) {
    return ApplicationOAuthScopeRequest(
      scope: json[r'scope'] != null
          ? ApplicationOAuthScope.fromJson(
              json[r'scope']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var scope = this.scope;

    final json = <String, Object?>{};
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    return json;
  }

  ApplicationOAuthScopeRequest copyWith({ApplicationOAuthScope? scope}) {
    return ApplicationOAuthScopeRequest(
      scope: scope ?? this.scope,
    );
  }
}

/// The Application Scope API response.
class ApplicationOAuthScopeResponse {
  final ApplicationOAuthScope? scope;

  ApplicationOAuthScopeResponse({this.scope});

  factory ApplicationOAuthScopeResponse.fromJson(Map<String, Object?> json) {
    return ApplicationOAuthScopeResponse(
      scope: json[r'scope'] != null
          ? ApplicationOAuthScope.fromJson(
              json[r'scope']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var scope = this.scope;

    final json = <String, Object?>{};
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    return json;
  }

  ApplicationOAuthScopeResponse copyWith({ApplicationOAuthScope? scope}) {
    return ApplicationOAuthScopeResponse(
      scope: scope ?? this.scope,
    );
  }
}

/// A Application-level policy for deleting Users.
class ApplicationRegistrationDeletePolicy {
  final TimeBasedDeletePolicy? unverified;

  ApplicationRegistrationDeletePolicy({this.unverified});

  factory ApplicationRegistrationDeletePolicy.fromJson(
      Map<String, Object?> json) {
    return ApplicationRegistrationDeletePolicy(
      unverified: json[r'unverified'] != null
          ? TimeBasedDeletePolicy.fromJson(
              json[r'unverified']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var unverified = this.unverified;

    final json = <String, Object?>{};
    if (unverified != null) {
      json[r'unverified'] = unverified.toJson();
    }
    return json;
  }

  ApplicationRegistrationDeletePolicy copyWith(
      {TimeBasedDeletePolicy? unverified}) {
    return ApplicationRegistrationDeletePolicy(
      unverified: unverified ?? this.unverified,
    );
  }
}

/// The Application API request object.
class ApplicationRequest {
  final Application? application;
  final ApplicationRole? role;
  final String? sourceApplicationId;
  final EventInfo? eventInfo;

  ApplicationRequest(
      {this.application, this.role, this.sourceApplicationId, this.eventInfo});

  factory ApplicationRequest.fromJson(Map<String, Object?> json) {
    return ApplicationRequest(
      application: json[r'application'] != null
          ? Application.fromJson(json[r'application']! as Map<String, Object?>)
          : null,
      role: json[r'role'] != null
          ? ApplicationRole.fromJson(json[r'role']! as Map<String, Object?>)
          : null,
      sourceApplicationId: json[r'sourceApplicationId'] as String?,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var application = this.application;
    var role = this.role;
    var sourceApplicationId = this.sourceApplicationId;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (application != null) {
      json[r'application'] = application.toJson();
    }
    if (role != null) {
      json[r'role'] = role.toJson();
    }
    if (sourceApplicationId != null) {
      json[r'sourceApplicationId'] = sourceApplicationId;
    }
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  ApplicationRequest copyWith(
      {Application? application,
      ApplicationRole? role,
      String? sourceApplicationId,
      EventInfo? eventInfo}) {
    return ApplicationRequest(
      application: application ?? this.application,
      role: role ?? this.role,
      sourceApplicationId: sourceApplicationId ?? this.sourceApplicationId,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

/// The Application API response.
class ApplicationResponse {
  final Application? application;
  final List<Application> applications;
  final ApplicationRole? role;

  ApplicationResponse(
      {this.application, List<Application>? applications, this.role})
      : applications = applications ?? [];

  factory ApplicationResponse.fromJson(Map<String, Object?> json) {
    return ApplicationResponse(
      application: json[r'application'] != null
          ? Application.fromJson(json[r'application']! as Map<String, Object?>)
          : null,
      applications: (json[r'applications'] as List<Object?>?)
              ?.map((i) =>
                  Application.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      role: json[r'role'] != null
          ? ApplicationRole.fromJson(json[r'role']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var application = this.application;
    var applications = this.applications;
    var role = this.role;

    final json = <String, Object?>{};
    if (application != null) {
      json[r'application'] = application.toJson();
    }
    json[r'applications'] = applications.map((i) => i.toJson()).toList();
    if (role != null) {
      json[r'role'] = role.toJson();
    }
    return json;
  }

  ApplicationResponse copyWith(
      {Application? application,
      List<Application>? applications,
      ApplicationRole? role}) {
    return ApplicationResponse(
      application: application ?? this.application,
      applications: applications ?? this.applications,
      role: role ?? this.role,
    );
  }
}

/// A role given to a user for a specific application.
class ApplicationRole {
  final String? description;
  final String? id;
  final ZonedDateTime? insertInstant;
  final bool isDefault;
  final bool isSuperRole;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;

  ApplicationRole(
      {this.description,
      this.id,
      this.insertInstant,
      bool? isDefault,
      bool? isSuperRole,
      this.lastUpdateInstant,
      this.name})
      : isDefault = isDefault ?? false,
        isSuperRole = isSuperRole ?? false;

  factory ApplicationRole.fromJson(Map<String, Object?> json) {
    return ApplicationRole(
      description: json[r'description'] as String?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      isDefault: json[r'isDefault'] as bool? ?? false,
      isSuperRole: json[r'isSuperRole'] as bool? ?? false,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var isDefault = this.isDefault;
    var isSuperRole = this.isSuperRole;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    json[r'isDefault'] = isDefault;
    json[r'isSuperRole'] = isSuperRole;
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  ApplicationRole copyWith(
      {String? description,
      String? id,
      ZonedDateTime? insertInstant,
      bool? isDefault,
      bool? isSuperRole,
      ZonedDateTime? lastUpdateInstant,
      String? name}) {
    return ApplicationRole(
      description: description ?? this.description,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      isDefault: isDefault ?? this.isDefault,
      isSuperRole: isSuperRole ?? this.isSuperRole,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
    );
  }
}

/// Search criteria for Applications
class ApplicationSearchCriteria {
  final String? name;
  final ObjectState? state;
  final String? tenantId;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  ApplicationSearchCriteria(
      {this.name,
      this.state,
      this.tenantId,
      this.numberOfResults,
      this.orderBy,
      this.startRow});

  factory ApplicationSearchCriteria.fromJson(Map<String, Object?> json) {
    return ApplicationSearchCriteria(
      name: json[r'name'] as String?,
      state: json[r'state'] != null
          ? ObjectState.fromValue(json[r'state']! as String)
          : null,
      tenantId: json[r'tenantId'] as String?,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var state = this.state;
    var tenantId = this.tenantId;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (state != null) {
      json[r'state'] = state.value;
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  ApplicationSearchCriteria copyWith(
      {String? name,
      ObjectState? state,
      String? tenantId,
      int? numberOfResults,
      String? orderBy,
      int? startRow}) {
    return ApplicationSearchCriteria(
      name: name ?? this.name,
      state: state ?? this.state,
      tenantId: tenantId ?? this.tenantId,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Search request for Applications
class ApplicationSearchRequest {
  final ApplicationSearchCriteria? search;
  final List<String> expand;

  ApplicationSearchRequest({this.search, List<String>? expand})
      : expand = expand ?? [];

  factory ApplicationSearchRequest.fromJson(Map<String, Object?> json) {
    return ApplicationSearchRequest(
      search: json[r'search'] != null
          ? ApplicationSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
      expand: (json[r'expand'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;
    var expand = this.expand;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    json[r'expand'] = expand;
    return json;
  }

  ApplicationSearchRequest copyWith(
      {ApplicationSearchCriteria? search, List<String>? expand}) {
    return ApplicationSearchRequest(
      search: search ?? this.search,
      expand: expand ?? this.expand,
    );
  }
}

/// Application search response
class ApplicationSearchResponse {
  final List<Application> applications;
  final int? total;
  final List<String> expandable;

  ApplicationSearchResponse(
      {List<Application>? applications, this.total, List<String>? expandable})
      : applications = applications ?? [],
        expandable = expandable ?? [];

  factory ApplicationSearchResponse.fromJson(Map<String, Object?> json) {
    return ApplicationSearchResponse(
      applications: (json[r'applications'] as List<Object?>?)
              ?.map((i) =>
                  Application.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
      expandable: (json[r'expandable'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var applications = this.applications;
    var total = this.total;
    var expandable = this.expandable;

    final json = <String, Object?>{};
    json[r'applications'] = applications.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'expandable'] = expandable;
    return json;
  }

  ApplicationSearchResponse copyWith(
      {List<Application>? applications, int? total, List<String>? expandable}) {
    return ApplicationSearchResponse(
      applications: applications ?? this.applications,
      total: total ?? this.total,
      expandable: expandable ?? this.expandable,
    );
  }
}

/// Application-level configuration for WebAuthn
class ApplicationWebAuthnConfiguration {
  final ApplicationWebAuthnWorkflowConfiguration? bootstrapWorkflow;
  final ApplicationWebAuthnWorkflowConfiguration? reauthenticationWorkflow;
  final bool enabled;

  ApplicationWebAuthnConfiguration(
      {this.bootstrapWorkflow, this.reauthenticationWorkflow, bool? enabled})
      : enabled = enabled ?? false;

  factory ApplicationWebAuthnConfiguration.fromJson(Map<String, Object?> json) {
    return ApplicationWebAuthnConfiguration(
      bootstrapWorkflow: json[r'bootstrapWorkflow'] != null
          ? ApplicationWebAuthnWorkflowConfiguration.fromJson(
              json[r'bootstrapWorkflow']! as Map<String, Object?>)
          : null,
      reauthenticationWorkflow: json[r'reauthenticationWorkflow'] != null
          ? ApplicationWebAuthnWorkflowConfiguration.fromJson(
              json[r'reauthenticationWorkflow']! as Map<String, Object?>)
          : null,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var bootstrapWorkflow = this.bootstrapWorkflow;
    var reauthenticationWorkflow = this.reauthenticationWorkflow;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (bootstrapWorkflow != null) {
      json[r'bootstrapWorkflow'] = bootstrapWorkflow.toJson();
    }
    if (reauthenticationWorkflow != null) {
      json[r'reauthenticationWorkflow'] = reauthenticationWorkflow.toJson();
    }
    json[r'enabled'] = enabled;
    return json;
  }

  ApplicationWebAuthnConfiguration copyWith(
      {ApplicationWebAuthnWorkflowConfiguration? bootstrapWorkflow,
      ApplicationWebAuthnWorkflowConfiguration? reauthenticationWorkflow,
      bool? enabled}) {
    return ApplicationWebAuthnConfiguration(
      bootstrapWorkflow: bootstrapWorkflow ?? this.bootstrapWorkflow,
      reauthenticationWorkflow:
          reauthenticationWorkflow ?? this.reauthenticationWorkflow,
      enabled: enabled ?? this.enabled,
    );
  }
}

class ApplicationWebAuthnWorkflowConfiguration {
  final bool enabled;

  ApplicationWebAuthnWorkflowConfiguration({bool? enabled})
      : enabled = enabled ?? false;

  factory ApplicationWebAuthnWorkflowConfiguration.fromJson(
      Map<String, Object?> json) {
    return ApplicationWebAuthnWorkflowConfiguration(
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var enabled = this.enabled;

    final json = <String, Object?>{};
    json[r'enabled'] = enabled;
    return json;
  }

  ApplicationWebAuthnWorkflowConfiguration copyWith({bool? enabled}) {
    return ApplicationWebAuthnWorkflowConfiguration(
      enabled: enabled ?? this.enabled,
    );
  }
}

/// This class is a simple attachment with a byte array, name and MIME type.
class Attachment {
  final String? attachment;
  final String? mime;
  final String? name;

  Attachment({this.attachment, this.mime, this.name});

  factory Attachment.fromJson(Map<String, Object?> json) {
    return Attachment(
      attachment: json[r'attachment'] as String?,
      mime: json[r'mime'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var attachment = this.attachment;
    var mime = this.mime;
    var name = this.name;

    final json = <String, Object?>{};
    if (attachment != null) {
      json[r'attachment'] = attachment;
    }
    if (mime != null) {
      json[r'mime'] = mime;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  Attachment copyWith({String? attachment, String? mime, String? name}) {
    return Attachment(
      attachment: attachment ?? this.attachment,
      mime: mime ?? this.mime,
      name: name ?? this.name,
    );
  }
}

/// An audit log.
class AuditLog {
  final Map<String, dynamic>? data;
  final int? id;
  final ZonedDateTime? insertInstant;
  final String? insertUser;
  final String? message;
  final Map<String, dynamic>? newValue;
  final Map<String, dynamic>? oldValue;
  final String? reason;

  AuditLog(
      {this.data,
      this.id,
      this.insertInstant,
      this.insertUser,
      this.message,
      this.newValue,
      this.oldValue,
      this.reason});

  factory AuditLog.fromJson(Map<String, Object?> json) {
    return AuditLog(
      data: json[r'data'] as Map<String, Object?>?,
      id: (json[r'id'] as num?)?.toInt(),
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      insertUser: json[r'insertUser'] as String?,
      message: json[r'message'] as String?,
      newValue: json[r'newValue'] as Map<String, Object?>?,
      oldValue: json[r'oldValue'] as Map<String, Object?>?,
      reason: json[r'reason'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var insertUser = this.insertUser;
    var message = this.message;
    var newValue = this.newValue;
    var oldValue = this.oldValue;
    var reason = this.reason;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (insertUser != null) {
      json[r'insertUser'] = insertUser;
    }
    if (message != null) {
      json[r'message'] = message;
    }
    if (newValue != null) {
      json[r'newValue'] = newValue;
    }
    if (oldValue != null) {
      json[r'oldValue'] = oldValue;
    }
    if (reason != null) {
      json[r'reason'] = reason;
    }
    return json;
  }

  AuditLog copyWith(
      {Map<String, dynamic>? data,
      int? id,
      ZonedDateTime? insertInstant,
      String? insertUser,
      String? message,
      Map<String, dynamic>? newValue,
      Map<String, dynamic>? oldValue,
      String? reason}) {
    return AuditLog(
      data: data ?? this.data,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      insertUser: insertUser ?? this.insertUser,
      message: message ?? this.message,
      newValue: newValue ?? this.newValue,
      oldValue: oldValue ?? this.oldValue,
      reason: reason ?? this.reason,
    );
  }
}

class AuditLogConfiguration {
  final DeleteConfiguration? delete;

  AuditLogConfiguration({this.delete});

  factory AuditLogConfiguration.fromJson(Map<String, Object?> json) {
    return AuditLogConfiguration(
      delete: json[r'delete'] != null
          ? DeleteConfiguration.fromJson(
              json[r'delete']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var delete = this.delete;

    final json = <String, Object?>{};
    if (delete != null) {
      json[r'delete'] = delete.toJson();
    }
    return json;
  }

  AuditLogConfiguration copyWith({DeleteConfiguration? delete}) {
    return AuditLogConfiguration(
      delete: delete ?? this.delete,
    );
  }
}

/// Event to indicate an audit log was created.
class AuditLogCreateEvent {
  final AuditLog? auditLog;
  final ZonedDateTime? createInstant;
  final String? id;
  final EventInfo? info;
  final String? tenantId;
  final EventType? type;

  AuditLogCreateEvent(
      {this.auditLog,
      this.createInstant,
      this.id,
      this.info,
      this.tenantId,
      this.type});

  factory AuditLogCreateEvent.fromJson(Map<String, Object?> json) {
    return AuditLogCreateEvent(
      auditLog: json[r'auditLog'] != null
          ? AuditLog.fromJson(json[r'auditLog']! as Map<String, Object?>)
          : null,
      createInstant:
          (json[r'createInstant'] as num?)?.toInt() as ZonedDateTime?,
      id: json[r'id'] as String?,
      info: json[r'info'] != null
          ? EventInfo.fromJson(json[r'info']! as Map<String, Object?>)
          : null,
      tenantId: json[r'tenantId'] as String?,
      type: json[r'type'] != null
          ? EventType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var auditLog = this.auditLog;
    var createInstant = this.createInstant;
    var id = this.id;
    var info = this.info;
    var tenantId = this.tenantId;
    var type = this.type;

    final json = <String, Object?>{};
    if (auditLog != null) {
      json[r'auditLog'] = auditLog.toJson();
    }
    if (createInstant != null) {
      json[r'createInstant'] = createInstant.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (info != null) {
      json[r'info'] = info.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  AuditLogCreateEvent copyWith(
      {AuditLog? auditLog,
      ZonedDateTime? createInstant,
      String? id,
      EventInfo? info,
      String? tenantId,
      EventType? type}) {
    return AuditLogCreateEvent(
      auditLog: auditLog ?? this.auditLog,
      createInstant: createInstant ?? this.createInstant,
      id: id ?? this.id,
      info: info ?? this.info,
      tenantId: tenantId ?? this.tenantId,
      type: type ?? this.type,
    );
  }
}

class AuditLogExportRequest {
  final AuditLogSearchCriteria? criteria;
  final String? dateTimeSecondsFormat;
  final ZoneId? zoneId;

  AuditLogExportRequest(
      {this.criteria, this.dateTimeSecondsFormat, this.zoneId});

  factory AuditLogExportRequest.fromJson(Map<String, Object?> json) {
    return AuditLogExportRequest(
      criteria: json[r'criteria'] != null
          ? AuditLogSearchCriteria.fromJson(
              json[r'criteria']! as Map<String, Object?>)
          : null,
      dateTimeSecondsFormat: json[r'dateTimeSecondsFormat'] as String?,
      zoneId: json[r'zoneId'] as ZoneId?,
    );
  }

  Map<String, Object?> toJson() {
    var criteria = this.criteria;
    var dateTimeSecondsFormat = this.dateTimeSecondsFormat;
    var zoneId = this.zoneId;

    final json = <String, Object?>{};
    if (criteria != null) {
      json[r'criteria'] = criteria.toJson();
    }
    if (dateTimeSecondsFormat != null) {
      json[r'dateTimeSecondsFormat'] = dateTimeSecondsFormat;
    }
    if (zoneId != null) {
      json[r'zoneId'] = zoneId.toJson();
    }
    return json;
  }

  AuditLogExportRequest copyWith(
      {AuditLogSearchCriteria? criteria,
      String? dateTimeSecondsFormat,
      ZoneId? zoneId}) {
    return AuditLogExportRequest(
      criteria: criteria ?? this.criteria,
      dateTimeSecondsFormat:
          dateTimeSecondsFormat ?? this.dateTimeSecondsFormat,
      zoneId: zoneId ?? this.zoneId,
    );
  }
}

class AuditLogRequest {
  final AuditLog? auditLog;
  final EventInfo? eventInfo;

  AuditLogRequest({this.auditLog, this.eventInfo});

  factory AuditLogRequest.fromJson(Map<String, Object?> json) {
    return AuditLogRequest(
      auditLog: json[r'auditLog'] != null
          ? AuditLog.fromJson(json[r'auditLog']! as Map<String, Object?>)
          : null,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var auditLog = this.auditLog;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (auditLog != null) {
      json[r'auditLog'] = auditLog.toJson();
    }
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  AuditLogRequest copyWith({AuditLog? auditLog, EventInfo? eventInfo}) {
    return AuditLogRequest(
      auditLog: auditLog ?? this.auditLog,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

/// Audit log response.
class AuditLogResponse {
  final AuditLog? auditLog;

  AuditLogResponse({this.auditLog});

  factory AuditLogResponse.fromJson(Map<String, Object?> json) {
    return AuditLogResponse(
      auditLog: json[r'auditLog'] != null
          ? AuditLog.fromJson(json[r'auditLog']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var auditLog = this.auditLog;

    final json = <String, Object?>{};
    if (auditLog != null) {
      json[r'auditLog'] = auditLog.toJson();
    }
    return json;
  }

  AuditLogResponse copyWith({AuditLog? auditLog}) {
    return AuditLogResponse(
      auditLog: auditLog ?? this.auditLog,
    );
  }
}

class AuditLogSearchCriteria {
  final ZonedDateTime? end;
  final String? message;
  final String? newValue;
  final String? oldValue;
  final String? reason;
  final ZonedDateTime? start;
  final String? user;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  AuditLogSearchCriteria(
      {this.end,
      this.message,
      this.newValue,
      this.oldValue,
      this.reason,
      this.start,
      this.user,
      this.numberOfResults,
      this.orderBy,
      this.startRow});

  factory AuditLogSearchCriteria.fromJson(Map<String, Object?> json) {
    return AuditLogSearchCriteria(
      end: (json[r'end'] as num?)?.toInt() as ZonedDateTime?,
      message: json[r'message'] as String?,
      newValue: json[r'newValue'] as String?,
      oldValue: json[r'oldValue'] as String?,
      reason: json[r'reason'] as String?,
      start: (json[r'start'] as num?)?.toInt() as ZonedDateTime?,
      user: json[r'user'] as String?,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var end = this.end;
    var message = this.message;
    var newValue = this.newValue;
    var oldValue = this.oldValue;
    var reason = this.reason;
    var start = this.start;
    var user = this.user;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (end != null) {
      json[r'end'] = end.toJson();
    }
    if (message != null) {
      json[r'message'] = message;
    }
    if (newValue != null) {
      json[r'newValue'] = newValue;
    }
    if (oldValue != null) {
      json[r'oldValue'] = oldValue;
    }
    if (reason != null) {
      json[r'reason'] = reason;
    }
    if (start != null) {
      json[r'start'] = start.toJson();
    }
    if (user != null) {
      json[r'user'] = user;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  AuditLogSearchCriteria copyWith(
      {ZonedDateTime? end,
      String? message,
      String? newValue,
      String? oldValue,
      String? reason,
      ZonedDateTime? start,
      String? user,
      int? numberOfResults,
      String? orderBy,
      int? startRow}) {
    return AuditLogSearchCriteria(
      end: end ?? this.end,
      message: message ?? this.message,
      newValue: newValue ?? this.newValue,
      oldValue: oldValue ?? this.oldValue,
      reason: reason ?? this.reason,
      start: start ?? this.start,
      user: user ?? this.user,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

class AuditLogSearchRequest {
  final AuditLogSearchCriteria? search;

  AuditLogSearchRequest({this.search});

  factory AuditLogSearchRequest.fromJson(Map<String, Object?> json) {
    return AuditLogSearchRequest(
      search: json[r'search'] != null
          ? AuditLogSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  AuditLogSearchRequest copyWith({AuditLogSearchCriteria? search}) {
    return AuditLogSearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Audit log response.
class AuditLogSearchResponse {
  final List<AuditLog> auditLogs;
  final int? total;

  AuditLogSearchResponse({List<AuditLog>? auditLogs, this.total})
      : auditLogs = auditLogs ?? [];

  factory AuditLogSearchResponse.fromJson(Map<String, Object?> json) {
    return AuditLogSearchResponse(
      auditLogs: (json[r'auditLogs'] as List<Object?>?)
              ?.map((i) =>
                  AuditLog.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var auditLogs = this.auditLogs;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'auditLogs'] = auditLogs.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  AuditLogSearchResponse copyWith({List<AuditLog>? auditLogs, int? total}) {
    return AuditLogSearchResponse(
      auditLogs: auditLogs ?? this.auditLogs,
      total: total ?? this.total,
    );
  }
}

class AuthenticationTokenConfiguration {
  final bool enabled;

  AuthenticationTokenConfiguration({bool? enabled})
      : enabled = enabled ?? false;

  factory AuthenticationTokenConfiguration.fromJson(Map<String, Object?> json) {
    return AuthenticationTokenConfiguration(
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var enabled = this.enabled;

    final json = <String, Object?>{};
    json[r'enabled'] = enabled;
    return json;
  }

  AuthenticationTokenConfiguration copyWith({bool? enabled}) {
    return AuthenticationTokenConfiguration(
      enabled: enabled ?? this.enabled,
    );
  }
}

class AuthenticatorConfiguration {
  final TOTPAlgorithm? algorithm;
  final int? codeLength;
  final int? timeStep;

  AuthenticatorConfiguration({this.algorithm, this.codeLength, this.timeStep});

  factory AuthenticatorConfiguration.fromJson(Map<String, Object?> json) {
    return AuthenticatorConfiguration(
      algorithm: json[r'algorithm'] != null
          ? TOTPAlgorithm.fromValue(json[r'algorithm']! as String)
          : null,
      codeLength: (json[r'codeLength'] as num?)?.toInt(),
      timeStep: (json[r'timeStep'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var algorithm = this.algorithm;
    var codeLength = this.codeLength;
    var timeStep = this.timeStep;

    final json = <String, Object?>{};
    if (algorithm != null) {
      json[r'algorithm'] = algorithm.value;
    }
    if (codeLength != null) {
      json[r'codeLength'] = codeLength;
    }
    if (timeStep != null) {
      json[r'timeStep'] = timeStep;
    }
    return json;
  }

  AuthenticatorConfiguration copyWith(
      {TOTPAlgorithm? algorithm, int? codeLength, int? timeStep}) {
    return AuthenticatorConfiguration(
      algorithm: algorithm ?? this.algorithm,
      codeLength: codeLength ?? this.codeLength,
      timeStep: timeStep ?? this.timeStep,
    );
  }
}

/// Used by the Relying Party to specify their requirements for authenticator
/// attributes. Fields use the deprecated "resident key" terminology to refer
/// to client-side discoverable credentials to maintain backwards compatibility
/// with WebAuthn Level 1.
class AuthenticatorSelectionCriteria {
  final AuthenticatorAttachment? authenticatorAttachment;
  final bool requireResidentKey;
  final ResidentKeyRequirement? residentKey;
  final UserVerificationRequirement? userVerification;

  AuthenticatorSelectionCriteria(
      {this.authenticatorAttachment,
      bool? requireResidentKey,
      this.residentKey,
      this.userVerification})
      : requireResidentKey = requireResidentKey ?? false;

  factory AuthenticatorSelectionCriteria.fromJson(Map<String, Object?> json) {
    return AuthenticatorSelectionCriteria(
      authenticatorAttachment: json[r'authenticatorAttachment'] != null
          ? AuthenticatorAttachment.fromValue(
              json[r'authenticatorAttachment']! as String)
          : null,
      requireResidentKey: json[r'requireResidentKey'] as bool? ?? false,
      residentKey: json[r'residentKey'] != null
          ? ResidentKeyRequirement.fromValue(json[r'residentKey']! as String)
          : null,
      userVerification: json[r'userVerification'] != null
          ? UserVerificationRequirement.fromValue(
              json[r'userVerification']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var authenticatorAttachment = this.authenticatorAttachment;
    var requireResidentKey = this.requireResidentKey;
    var residentKey = this.residentKey;
    var userVerification = this.userVerification;

    final json = <String, Object?>{};
    if (authenticatorAttachment != null) {
      json[r'authenticatorAttachment'] = authenticatorAttachment.value;
    }
    json[r'requireResidentKey'] = requireResidentKey;
    if (residentKey != null) {
      json[r'residentKey'] = residentKey.value;
    }
    if (userVerification != null) {
      json[r'userVerification'] = userVerification.value;
    }
    return json;
  }

  AuthenticatorSelectionCriteria copyWith(
      {AuthenticatorAttachment? authenticatorAttachment,
      bool? requireResidentKey,
      ResidentKeyRequirement? residentKey,
      UserVerificationRequirement? userVerification}) {
    return AuthenticatorSelectionCriteria(
      authenticatorAttachment:
          authenticatorAttachment ?? this.authenticatorAttachment,
      requireResidentKey: requireResidentKey ?? this.requireResidentKey,
      residentKey: residentKey ?? this.residentKey,
      userVerification: userVerification ?? this.userVerification,
    );
  }
}

/// Do not require a setter for 'type', it is defined by the concrete class and
/// is not mutable
class BaseConnectorConfiguration {
  final Map<String, dynamic>? data;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final ConnectorType? type;

  BaseConnectorConfiguration(
      {this.data,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.name,
      this.type})
      : debug = debug ?? false;

  factory BaseConnectorConfiguration.fromJson(Map<String, Object?> json) {
    return BaseConnectorConfiguration(
      data: json[r'data'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      type: json[r'type'] != null
          ? ConnectorType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var type = this.type;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  BaseConnectorConfiguration copyWith(
      {Map<String, dynamic>? data,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      ConnectorType? type}) {
    return BaseConnectorConfiguration(
      data: data ?? this.data,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      type: type ?? this.type,
    );
  }
}

class BaseElasticSearchCriteria {
  final bool accurateTotal;
  final List<String> ids;
  final String? nextResults;
  final String? query;
  final String? queryString;
  final List<SortField> sortFields;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  BaseElasticSearchCriteria(
      {bool? accurateTotal,
      List<String>? ids,
      this.nextResults,
      this.query,
      this.queryString,
      List<SortField>? sortFields,
      this.numberOfResults,
      this.orderBy,
      this.startRow})
      : accurateTotal = accurateTotal ?? false,
        ids = ids ?? [],
        sortFields = sortFields ?? [];

  factory BaseElasticSearchCriteria.fromJson(Map<String, Object?> json) {
    return BaseElasticSearchCriteria(
      accurateTotal: json[r'accurateTotal'] as bool? ?? false,
      ids: (json[r'ids'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      nextResults: json[r'nextResults'] as String?,
      query: json[r'query'] as String?,
      queryString: json[r'queryString'] as String?,
      sortFields: (json[r'sortFields'] as List<Object?>?)
              ?.map((i) =>
                  SortField.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var accurateTotal = this.accurateTotal;
    var ids = this.ids;
    var nextResults = this.nextResults;
    var query = this.query;
    var queryString = this.queryString;
    var sortFields = this.sortFields;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    json[r'accurateTotal'] = accurateTotal;
    json[r'ids'] = ids;
    if (nextResults != null) {
      json[r'nextResults'] = nextResults;
    }
    if (query != null) {
      json[r'query'] = query;
    }
    if (queryString != null) {
      json[r'queryString'] = queryString;
    }
    json[r'sortFields'] = sortFields.map((i) => i.toJson()).toList();
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  BaseElasticSearchCriteria copyWith(
      {bool? accurateTotal,
      List<String>? ids,
      String? nextResults,
      String? query,
      String? queryString,
      List<SortField>? sortFields,
      int? numberOfResults,
      String? orderBy,
      int? startRow}) {
    return BaseElasticSearchCriteria(
      accurateTotal: accurateTotal ?? this.accurateTotal,
      ids: ids ?? this.ids,
      nextResults: nextResults ?? this.nextResults,
      query: query ?? this.query,
      queryString: queryString ?? this.queryString,
      sortFields: sortFields ?? this.sortFields,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Base class for all FusionAuth events.
class BaseEvent {
  final ZonedDateTime? createInstant;
  final String? id;
  final EventInfo? info;
  final String? tenantId;
  final EventType? type;

  BaseEvent({this.createInstant, this.id, this.info, this.tenantId, this.type});

  factory BaseEvent.fromJson(Map<String, Object?> json) {
    return BaseEvent(
      createInstant:
          (json[r'createInstant'] as num?)?.toInt() as ZonedDateTime?,
      id: json[r'id'] as String?,
      info: json[r'info'] != null
          ? EventInfo.fromJson(json[r'info']! as Map<String, Object?>)
          : null,
      tenantId: json[r'tenantId'] as String?,
      type: json[r'type'] != null
          ? EventType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var createInstant = this.createInstant;
    var id = this.id;
    var info = this.info;
    var tenantId = this.tenantId;
    var type = this.type;

    final json = <String, Object?>{};
    if (createInstant != null) {
      json[r'createInstant'] = createInstant.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (info != null) {
      json[r'info'] = info.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  BaseEvent copyWith(
      {ZonedDateTime? createInstant,
      String? id,
      EventInfo? info,
      String? tenantId,
      EventType? type}) {
    return BaseEvent(
      createInstant: createInstant ?? this.createInstant,
      id: id ?? this.id,
      info: info ?? this.info,
      tenantId: tenantId ?? this.tenantId,
      type: type ?? this.type,
    );
  }
}

/// Base class for requests that can contain event information. This event
/// information is used when sending Webhooks or emails  during the transaction.
/// The caller is responsible for ensuring that the event information is
/// correct.
class BaseEventRequest {
  final EventInfo? eventInfo;

  BaseEventRequest({this.eventInfo});

  factory BaseEventRequest.fromJson(Map<String, Object?> json) {
    return BaseEventRequest(
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  BaseEventRequest copyWith({EventInfo? eventInfo}) {
    return BaseEventRequest(
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

class BaseExportRequest {
  final String? dateTimeSecondsFormat;
  final ZoneId? zoneId;

  BaseExportRequest({this.dateTimeSecondsFormat, this.zoneId});

  factory BaseExportRequest.fromJson(Map<String, Object?> json) {
    return BaseExportRequest(
      dateTimeSecondsFormat: json[r'dateTimeSecondsFormat'] as String?,
      zoneId: json[r'zoneId'] as ZoneId?,
    );
  }

  Map<String, Object?> toJson() {
    var dateTimeSecondsFormat = this.dateTimeSecondsFormat;
    var zoneId = this.zoneId;

    final json = <String, Object?>{};
    if (dateTimeSecondsFormat != null) {
      json[r'dateTimeSecondsFormat'] = dateTimeSecondsFormat;
    }
    if (zoneId != null) {
      json[r'zoneId'] = zoneId.toJson();
    }
    return json;
  }

  BaseExportRequest copyWith({String? dateTimeSecondsFormat, ZoneId? zoneId}) {
    return BaseExportRequest(
      dateTimeSecondsFormat:
          dateTimeSecondsFormat ?? this.dateTimeSecondsFormat,
      zoneId: zoneId ?? this.zoneId,
    );
  }
}

/// Base class for all {@link Group} and {@link GroupMember} events.
class BaseGroupEvent {
  final Group? group;
  final ZonedDateTime? createInstant;
  final String? id;
  final EventInfo? info;
  final String? tenantId;
  final EventType? type;

  BaseGroupEvent(
      {this.group,
      this.createInstant,
      this.id,
      this.info,
      this.tenantId,
      this.type});

  factory BaseGroupEvent.fromJson(Map<String, Object?> json) {
    return BaseGroupEvent(
      group: json[r'group'] != null
          ? Group.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
      createInstant:
          (json[r'createInstant'] as num?)?.toInt() as ZonedDateTime?,
      id: json[r'id'] as String?,
      info: json[r'info'] != null
          ? EventInfo.fromJson(json[r'info']! as Map<String, Object?>)
          : null,
      tenantId: json[r'tenantId'] as String?,
      type: json[r'type'] != null
          ? EventType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var group = this.group;
    var createInstant = this.createInstant;
    var id = this.id;
    var info = this.info;
    var tenantId = this.tenantId;
    var type = this.type;

    final json = <String, Object?>{};
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    if (createInstant != null) {
      json[r'createInstant'] = createInstant.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (info != null) {
      json[r'info'] = info.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  BaseGroupEvent copyWith(
      {Group? group,
      ZonedDateTime? createInstant,
      String? id,
      EventInfo? info,
      String? tenantId,
      EventType? type}) {
    return BaseGroupEvent(
      group: group ?? this.group,
      createInstant: createInstant ?? this.createInstant,
      id: id ?? this.id,
      info: info ?? this.info,
      tenantId: tenantId ?? this.tenantId,
      type: type ?? this.type,
    );
  }
}

class BaseIdentityProviderApplicationConfiguration {
  final Map<String, dynamic>? data;
  final bool createRegistration;
  final bool enabled;

  BaseIdentityProviderApplicationConfiguration(
      {this.data, bool? createRegistration, bool? enabled})
      : createRegistration = createRegistration ?? false,
        enabled = enabled ?? false;

  factory BaseIdentityProviderApplicationConfiguration.fromJson(
      Map<String, Object?> json) {
    return BaseIdentityProviderApplicationConfiguration(
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var createRegistration = this.createRegistration;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    json[r'enabled'] = enabled;
    return json;
  }

  BaseIdentityProviderApplicationConfiguration copyWith(
      {Map<String, dynamic>? data, bool? createRegistration, bool? enabled}) {
    return BaseIdentityProviderApplicationConfiguration(
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
      enabled: enabled ?? this.enabled,
    );
  }
}

class BaseLoginRequest {
  final String? applicationId;
  final String? ipAddress;
  final MetaData? metaData;
  final bool newDevice;
  final bool noJwt;
  final EventInfo? eventInfo;

  BaseLoginRequest(
      {this.applicationId,
      this.ipAddress,
      this.metaData,
      bool? newDevice,
      bool? noJwt,
      this.eventInfo})
      : newDevice = newDevice ?? false,
        noJwt = noJwt ?? false;

  factory BaseLoginRequest.fromJson(Map<String, Object?> json) {
    return BaseLoginRequest(
      applicationId: json[r'applicationId'] as String?,
      ipAddress: json[r'ipAddress'] as String?,
      metaData: json[r'metaData'] != null
          ? MetaData.fromJson(json[r'metaData']! as Map<String, Object?>)
          : null,
      newDevice: json[r'newDevice'] as bool? ?? false,
      noJwt: json[r'noJWT'] as bool? ?? false,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var ipAddress = this.ipAddress;
    var metaData = this.metaData;
    var newDevice = this.newDevice;
    var noJwt = this.noJwt;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (ipAddress != null) {
      json[r'ipAddress'] = ipAddress;
    }
    if (metaData != null) {
      json[r'metaData'] = metaData.toJson();
    }
    json[r'newDevice'] = newDevice;
    json[r'noJWT'] = noJwt;
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  BaseLoginRequest copyWith(
      {String? applicationId,
      String? ipAddress,
      MetaData? metaData,
      bool? newDevice,
      bool? noJwt,
      EventInfo? eventInfo}) {
    return BaseLoginRequest(
      applicationId: applicationId ?? this.applicationId,
      ipAddress: ipAddress ?? this.ipAddress,
      metaData: metaData ?? this.metaData,
      newDevice: newDevice ?? this.newDevice,
      noJwt: noJwt ?? this.noJwt,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

/// Do not require a setter for 'type', it is defined by the concrete class and
/// is not mutable
class BaseMessengerConfiguration {
  final Map<String, dynamic>? data;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final String? transport;
  final MessengerType? type;

  BaseMessengerConfiguration(
      {this.data,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.name,
      this.transport,
      this.type})
      : debug = debug ?? false;

  factory BaseMessengerConfiguration.fromJson(Map<String, Object?> json) {
    return BaseMessengerConfiguration(
      data: json[r'data'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      transport: json[r'transport'] as String?,
      type: json[r'type'] != null
          ? MessengerType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var transport = this.transport;
    var type = this.type;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (transport != null) {
      json[r'transport'] = transport;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  BaseMessengerConfiguration copyWith(
      {Map<String, dynamic>? data,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      String? transport,
      MessengerType? type}) {
    return BaseMessengerConfiguration(
      data: data ?? this.data,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      transport: transport ?? this.transport,
      type: type ?? this.type,
    );
  }
}

class BaseSearchCriteria {
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  BaseSearchCriteria({this.numberOfResults, this.orderBy, this.startRow});

  factory BaseSearchCriteria.fromJson(Map<String, Object?> json) {
    return BaseSearchCriteria(
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  BaseSearchCriteria copyWith(
      {int? numberOfResults, String? orderBy, int? startRow}) {
    return BaseSearchCriteria(
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Base class for all {@link User}-related events.
class BaseUserEvent {
  final User? user;
  final ZonedDateTime? createInstant;
  final String? id;
  final EventInfo? info;
  final String? tenantId;
  final EventType? type;

  BaseUserEvent(
      {this.user,
      this.createInstant,
      this.id,
      this.info,
      this.tenantId,
      this.type});

  factory BaseUserEvent.fromJson(Map<String, Object?> json) {
    return BaseUserEvent(
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
      createInstant:
          (json[r'createInstant'] as num?)?.toInt() as ZonedDateTime?,
      id: json[r'id'] as String?,
      info: json[r'info'] != null
          ? EventInfo.fromJson(json[r'info']! as Map<String, Object?>)
          : null,
      tenantId: json[r'tenantId'] as String?,
      type: json[r'type'] != null
          ? EventType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var user = this.user;
    var createInstant = this.createInstant;
    var id = this.id;
    var info = this.info;
    var tenantId = this.tenantId;
    var type = this.type;

    final json = <String, Object?>{};
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    if (createInstant != null) {
      json[r'createInstant'] = createInstant.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (info != null) {
      json[r'info'] = info.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  BaseUserEvent copyWith(
      {User? user,
      ZonedDateTime? createInstant,
      String? id,
      EventInfo? info,
      String? tenantId,
      EventType? type}) {
    return BaseUserEvent(
      user: user ?? this.user,
      createInstant: createInstant ?? this.createInstant,
      id: id ?? this.id,
      info: info ?? this.info,
      tenantId: tenantId ?? this.tenantId,
      type: type ?? this.type,
    );
  }
}

class BreachedPasswordTenantMetric {
  final int? actionRequired;
  final int? matchedCommonPasswordCount;
  final int? matchedExactCount;
  final int? matchedPasswordCount;
  final int? matchedSubAddressCount;
  final int? passwordsCheckedCount;

  BreachedPasswordTenantMetric(
      {this.actionRequired,
      this.matchedCommonPasswordCount,
      this.matchedExactCount,
      this.matchedPasswordCount,
      this.matchedSubAddressCount,
      this.passwordsCheckedCount});

  factory BreachedPasswordTenantMetric.fromJson(Map<String, Object?> json) {
    return BreachedPasswordTenantMetric(
      actionRequired: (json[r'actionRequired'] as num?)?.toInt(),
      matchedCommonPasswordCount:
          (json[r'matchedCommonPasswordCount'] as num?)?.toInt(),
      matchedExactCount: (json[r'matchedExactCount'] as num?)?.toInt(),
      matchedPasswordCount: (json[r'matchedPasswordCount'] as num?)?.toInt(),
      matchedSubAddressCount:
          (json[r'matchedSubAddressCount'] as num?)?.toInt(),
      passwordsCheckedCount: (json[r'passwordsCheckedCount'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var actionRequired = this.actionRequired;
    var matchedCommonPasswordCount = this.matchedCommonPasswordCount;
    var matchedExactCount = this.matchedExactCount;
    var matchedPasswordCount = this.matchedPasswordCount;
    var matchedSubAddressCount = this.matchedSubAddressCount;
    var passwordsCheckedCount = this.passwordsCheckedCount;

    final json = <String, Object?>{};
    if (actionRequired != null) {
      json[r'actionRequired'] = actionRequired;
    }
    if (matchedCommonPasswordCount != null) {
      json[r'matchedCommonPasswordCount'] = matchedCommonPasswordCount;
    }
    if (matchedExactCount != null) {
      json[r'matchedExactCount'] = matchedExactCount;
    }
    if (matchedPasswordCount != null) {
      json[r'matchedPasswordCount'] = matchedPasswordCount;
    }
    if (matchedSubAddressCount != null) {
      json[r'matchedSubAddressCount'] = matchedSubAddressCount;
    }
    if (passwordsCheckedCount != null) {
      json[r'passwordsCheckedCount'] = passwordsCheckedCount;
    }
    return json;
  }

  BreachedPasswordTenantMetric copyWith(
      {int? actionRequired,
      int? matchedCommonPasswordCount,
      int? matchedExactCount,
      int? matchedPasswordCount,
      int? matchedSubAddressCount,
      int? passwordsCheckedCount}) {
    return BreachedPasswordTenantMetric(
      actionRequired: actionRequired ?? this.actionRequired,
      matchedCommonPasswordCount:
          matchedCommonPasswordCount ?? this.matchedCommonPasswordCount,
      matchedExactCount: matchedExactCount ?? this.matchedExactCount,
      matchedPasswordCount: matchedPasswordCount ?? this.matchedPasswordCount,
      matchedSubAddressCount:
          matchedSubAddressCount ?? this.matchedSubAddressCount,
      passwordsCheckedCount:
          passwordsCheckedCount ?? this.passwordsCheckedCount,
    );
  }
}

class CORSConfiguration {
  final bool allowCredentials;
  final List<String> allowedHeaders;
  final List<HTTPMethod> allowedMethods;
  final List<String> allowedOrigins;
  final bool debug;
  final List<String> exposedHeaders;
  final int? preflightMaxAgeInSeconds;
  final bool enabled;

  CORSConfiguration(
      {bool? allowCredentials,
      List<String>? allowedHeaders,
      List<HTTPMethod>? allowedMethods,
      List<String>? allowedOrigins,
      bool? debug,
      List<String>? exposedHeaders,
      this.preflightMaxAgeInSeconds,
      bool? enabled})
      : allowCredentials = allowCredentials ?? false,
        allowedHeaders = allowedHeaders ?? [],
        allowedMethods = allowedMethods ?? [],
        allowedOrigins = allowedOrigins ?? [],
        debug = debug ?? false,
        exposedHeaders = exposedHeaders ?? [],
        enabled = enabled ?? false;

  factory CORSConfiguration.fromJson(Map<String, Object?> json) {
    return CORSConfiguration(
      allowCredentials: json[r'allowCredentials'] as bool? ?? false,
      allowedHeaders: (json[r'allowedHeaders'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      allowedMethods: (json[r'allowedMethods'] as List<Object?>?)
              ?.map((i) => HTTPMethod.fromValue(i as String? ?? ''))
              .toList() ??
          [],
      allowedOrigins: (json[r'allowedOrigins'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      debug: json[r'debug'] as bool? ?? false,
      exposedHeaders: (json[r'exposedHeaders'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      preflightMaxAgeInSeconds:
          (json[r'preflightMaxAgeInSeconds'] as num?)?.toInt(),
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var allowCredentials = this.allowCredentials;
    var allowedHeaders = this.allowedHeaders;
    var allowedMethods = this.allowedMethods;
    var allowedOrigins = this.allowedOrigins;
    var debug = this.debug;
    var exposedHeaders = this.exposedHeaders;
    var preflightMaxAgeInSeconds = this.preflightMaxAgeInSeconds;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    json[r'allowCredentials'] = allowCredentials;
    json[r'allowedHeaders'] = allowedHeaders;
    json[r'allowedMethods'] = allowedMethods.map((i) => i.value).toList();
    json[r'allowedOrigins'] = allowedOrigins;
    json[r'debug'] = debug;
    json[r'exposedHeaders'] = exposedHeaders;
    if (preflightMaxAgeInSeconds != null) {
      json[r'preflightMaxAgeInSeconds'] = preflightMaxAgeInSeconds;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  CORSConfiguration copyWith(
      {bool? allowCredentials,
      List<String>? allowedHeaders,
      List<HTTPMethod>? allowedMethods,
      List<String>? allowedOrigins,
      bool? debug,
      List<String>? exposedHeaders,
      int? preflightMaxAgeInSeconds,
      bool? enabled}) {
    return CORSConfiguration(
      allowCredentials: allowCredentials ?? this.allowCredentials,
      allowedHeaders: allowedHeaders ?? this.allowedHeaders,
      allowedMethods: allowedMethods ?? this.allowedMethods,
      allowedOrigins: allowedOrigins ?? this.allowedOrigins,
      debug: debug ?? this.debug,
      exposedHeaders: exposedHeaders ?? this.exposedHeaders,
      preflightMaxAgeInSeconds:
          preflightMaxAgeInSeconds ?? this.preflightMaxAgeInSeconds,
      enabled: enabled ?? this.enabled,
    );
  }
}

class CertificateInformation {
  final String? issuer;
  final String? md5Fingerprint;
  final String? serialNumber;
  final String? sha1Fingerprint;
  final String? sha1Thumbprint;
  final String? sha256Fingerprint;
  final String? sha256Thumbprint;
  final String? subject;
  final ZonedDateTime? validFrom;
  final ZonedDateTime? validTo;

  CertificateInformation(
      {this.issuer,
      this.md5Fingerprint,
      this.serialNumber,
      this.sha1Fingerprint,
      this.sha1Thumbprint,
      this.sha256Fingerprint,
      this.sha256Thumbprint,
      this.subject,
      this.validFrom,
      this.validTo});

  factory CertificateInformation.fromJson(Map<String, Object?> json) {
    return CertificateInformation(
      issuer: json[r'issuer'] as String?,
      md5Fingerprint: json[r'md5Fingerprint'] as String?,
      serialNumber: json[r'serialNumber'] as String?,
      sha1Fingerprint: json[r'sha1Fingerprint'] as String?,
      sha1Thumbprint: json[r'sha1Thumbprint'] as String?,
      sha256Fingerprint: json[r'sha256Fingerprint'] as String?,
      sha256Thumbprint: json[r'sha256Thumbprint'] as String?,
      subject: json[r'subject'] as String?,
      validFrom: (json[r'validFrom'] as num?)?.toInt() as ZonedDateTime?,
      validTo: (json[r'validTo'] as num?)?.toInt() as ZonedDateTime?,
    );
  }

  Map<String, Object?> toJson() {
    var issuer = this.issuer;
    var md5Fingerprint = this.md5Fingerprint;
    var serialNumber = this.serialNumber;
    var sha1Fingerprint = this.sha1Fingerprint;
    var sha1Thumbprint = this.sha1Thumbprint;
    var sha256Fingerprint = this.sha256Fingerprint;
    var sha256Thumbprint = this.sha256Thumbprint;
    var subject = this.subject;
    var validFrom = this.validFrom;
    var validTo = this.validTo;

    final json = <String, Object?>{};
    if (issuer != null) {
      json[r'issuer'] = issuer;
    }
    if (md5Fingerprint != null) {
      json[r'md5Fingerprint'] = md5Fingerprint;
    }
    if (serialNumber != null) {
      json[r'serialNumber'] = serialNumber;
    }
    if (sha1Fingerprint != null) {
      json[r'sha1Fingerprint'] = sha1Fingerprint;
    }
    if (sha1Thumbprint != null) {
      json[r'sha1Thumbprint'] = sha1Thumbprint;
    }
    if (sha256Fingerprint != null) {
      json[r'sha256Fingerprint'] = sha256Fingerprint;
    }
    if (sha256Thumbprint != null) {
      json[r'sha256Thumbprint'] = sha256Thumbprint;
    }
    if (subject != null) {
      json[r'subject'] = subject;
    }
    if (validFrom != null) {
      json[r'validFrom'] = validFrom.toJson();
    }
    if (validTo != null) {
      json[r'validTo'] = validTo.toJson();
    }
    return json;
  }

  CertificateInformation copyWith(
      {String? issuer,
      String? md5Fingerprint,
      String? serialNumber,
      String? sha1Fingerprint,
      String? sha1Thumbprint,
      String? sha256Fingerprint,
      String? sha256Thumbprint,
      String? subject,
      ZonedDateTime? validFrom,
      ZonedDateTime? validTo}) {
    return CertificateInformation(
      issuer: issuer ?? this.issuer,
      md5Fingerprint: md5Fingerprint ?? this.md5Fingerprint,
      serialNumber: serialNumber ?? this.serialNumber,
      sha1Fingerprint: sha1Fingerprint ?? this.sha1Fingerprint,
      sha1Thumbprint: sha1Thumbprint ?? this.sha1Thumbprint,
      sha256Fingerprint: sha256Fingerprint ?? this.sha256Fingerprint,
      sha256Thumbprint: sha256Thumbprint ?? this.sha256Thumbprint,
      subject: subject ?? this.subject,
      validFrom: validFrom ?? this.validFrom,
      validTo: validTo ?? this.validTo,
    );
  }
}

/// Change password request object.
class ChangePasswordRequest {
  final String? applicationId;
  final String? changePasswordId;
  final String? currentPassword;
  final String? loginId;
  final String? password;
  final String? refreshToken;
  final String? trustChallenge;
  final String? trustToken;
  final EventInfo? eventInfo;

  ChangePasswordRequest(
      {this.applicationId,
      this.changePasswordId,
      this.currentPassword,
      this.loginId,
      this.password,
      this.refreshToken,
      this.trustChallenge,
      this.trustToken,
      this.eventInfo});

  factory ChangePasswordRequest.fromJson(Map<String, Object?> json) {
    return ChangePasswordRequest(
      applicationId: json[r'applicationId'] as String?,
      changePasswordId: json[r'changePasswordId'] as String?,
      currentPassword: json[r'currentPassword'] as String?,
      loginId: json[r'loginId'] as String?,
      password: json[r'password'] as String?,
      refreshToken: json[r'refreshToken'] as String?,
      trustChallenge: json[r'trustChallenge'] as String?,
      trustToken: json[r'trustToken'] as String?,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var changePasswordId = this.changePasswordId;
    var currentPassword = this.currentPassword;
    var loginId = this.loginId;
    var password = this.password;
    var refreshToken = this.refreshToken;
    var trustChallenge = this.trustChallenge;
    var trustToken = this.trustToken;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (changePasswordId != null) {
      json[r'changePasswordId'] = changePasswordId;
    }
    if (currentPassword != null) {
      json[r'currentPassword'] = currentPassword;
    }
    if (loginId != null) {
      json[r'loginId'] = loginId;
    }
    if (password != null) {
      json[r'password'] = password;
    }
    if (refreshToken != null) {
      json[r'refreshToken'] = refreshToken;
    }
    if (trustChallenge != null) {
      json[r'trustChallenge'] = trustChallenge;
    }
    if (trustToken != null) {
      json[r'trustToken'] = trustToken;
    }
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  ChangePasswordRequest copyWith(
      {String? applicationId,
      String? changePasswordId,
      String? currentPassword,
      String? loginId,
      String? password,
      String? refreshToken,
      String? trustChallenge,
      String? trustToken,
      EventInfo? eventInfo}) {
    return ChangePasswordRequest(
      applicationId: applicationId ?? this.applicationId,
      changePasswordId: changePasswordId ?? this.changePasswordId,
      currentPassword: currentPassword ?? this.currentPassword,
      loginId: loginId ?? this.loginId,
      password: password ?? this.password,
      refreshToken: refreshToken ?? this.refreshToken,
      trustChallenge: trustChallenge ?? this.trustChallenge,
      trustToken: trustToken ?? this.trustToken,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

/// Change password response object.
class ChangePasswordResponse {
  final String? oneTimePassword;
  final Map<String, dynamic>? state;

  ChangePasswordResponse({this.oneTimePassword, this.state});

  factory ChangePasswordResponse.fromJson(Map<String, Object?> json) {
    return ChangePasswordResponse(
      oneTimePassword: json[r'oneTimePassword'] as String?,
      state: json[r'state'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var oneTimePassword = this.oneTimePassword;
    var state = this.state;

    final json = <String, Object?>{};
    if (oneTimePassword != null) {
      json[r'oneTimePassword'] = oneTimePassword;
    }
    if (state != null) {
      json[r'state'] = state;
    }
    return json;
  }

  ChangePasswordResponse copyWith(
      {String? oneTimePassword, Map<String, dynamic>? state}) {
    return ChangePasswordResponse(
      oneTimePassword: oneTimePassword ?? this.oneTimePassword,
      state: state ?? this.state,
    );
  }
}

/// CleanSpeak configuration at the system and application level.
class CleanSpeakConfiguration {
  final String? apiKey;
  final List<String> applicationIds;
  final String? url;
  final UsernameModeration? usernameModeration;
  final bool enabled;

  CleanSpeakConfiguration(
      {this.apiKey,
      List<String>? applicationIds,
      this.url,
      this.usernameModeration,
      bool? enabled})
      : applicationIds = applicationIds ?? [],
        enabled = enabled ?? false;

  factory CleanSpeakConfiguration.fromJson(Map<String, Object?> json) {
    return CleanSpeakConfiguration(
      apiKey: json[r'apiKey'] as String?,
      applicationIds: (json[r'applicationIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      url: json[r'url'] as String?,
      usernameModeration: json[r'usernameModeration'] != null
          ? UsernameModeration.fromJson(
              json[r'usernameModeration']! as Map<String, Object?>)
          : null,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var apiKey = this.apiKey;
    var applicationIds = this.applicationIds;
    var url = this.url;
    var usernameModeration = this.usernameModeration;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (apiKey != null) {
      json[r'apiKey'] = apiKey;
    }
    json[r'applicationIds'] = applicationIds;
    if (url != null) {
      json[r'url'] = url;
    }
    if (usernameModeration != null) {
      json[r'usernameModeration'] = usernameModeration.toJson();
    }
    json[r'enabled'] = enabled;
    return json;
  }

  CleanSpeakConfiguration copyWith(
      {String? apiKey,
      List<String>? applicationIds,
      String? url,
      UsernameModeration? usernameModeration,
      bool? enabled}) {
    return CleanSpeakConfiguration(
      apiKey: apiKey ?? this.apiKey,
      applicationIds: applicationIds ?? this.applicationIds,
      url: url ?? this.url,
      usernameModeration: usernameModeration ?? this.usernameModeration,
      enabled: enabled ?? this.enabled,
    );
  }
}

class ConnectorLambdaConfiguration {
  final String? reconcileId;

  ConnectorLambdaConfiguration({this.reconcileId});

  factory ConnectorLambdaConfiguration.fromJson(Map<String, Object?> json) {
    return ConnectorLambdaConfiguration(
      reconcileId: json[r'reconcileId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var reconcileId = this.reconcileId;

    final json = <String, Object?>{};
    if (reconcileId != null) {
      json[r'reconcileId'] = reconcileId;
    }
    return json;
  }

  ConnectorLambdaConfiguration copyWith({String? reconcileId}) {
    return ConnectorLambdaConfiguration(
      reconcileId: reconcileId ?? this.reconcileId,
    );
  }
}

class ConnectorPolicy {
  final String? connectorId;
  final Map<String, dynamic>? data;
  final List<dynamic> domains;
  final bool migrate;

  ConnectorPolicy(
      {this.connectorId, this.data, List<dynamic>? domains, bool? migrate})
      : domains = domains ?? [],
        migrate = migrate ?? false;

  factory ConnectorPolicy.fromJson(Map<String, Object?> json) {
    return ConnectorPolicy(
      connectorId: json[r'connectorId'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      domains:
          (json[r'domains'] as List<Object?>?)?.map((i) => i).toList() ?? [],
      migrate: json[r'migrate'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var connectorId = this.connectorId;
    var data = this.data;
    var domains = this.domains;
    var migrate = this.migrate;

    final json = <String, Object?>{};
    if (connectorId != null) {
      json[r'connectorId'] = connectorId;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'domains'] = domains;
    json[r'migrate'] = migrate;
    return json;
  }

  ConnectorPolicy copyWith(
      {String? connectorId,
      Map<String, dynamic>? data,
      List<dynamic>? domains,
      bool? migrate}) {
    return ConnectorPolicy(
      connectorId: connectorId ?? this.connectorId,
      data: data ?? this.data,
      domains: domains ?? this.domains,
      migrate: migrate ?? this.migrate,
    );
  }
}

class ConnectorRequest {
  final BaseConnectorConfiguration? connector;

  ConnectorRequest({this.connector});

  factory ConnectorRequest.fromJson(Map<String, Object?> json) {
    return ConnectorRequest(
      connector: json[r'connector'] != null
          ? BaseConnectorConfiguration.fromJson(
              json[r'connector']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var connector = this.connector;

    final json = <String, Object?>{};
    if (connector != null) {
      json[r'connector'] = connector.toJson();
    }
    return json;
  }

  ConnectorRequest copyWith({BaseConnectorConfiguration? connector}) {
    return ConnectorRequest(
      connector: connector ?? this.connector,
    );
  }
}

class ConnectorResponse {
  final BaseConnectorConfiguration? connector;
  final List<BaseConnectorConfiguration> connectors;

  ConnectorResponse(
      {this.connector, List<BaseConnectorConfiguration>? connectors})
      : connectors = connectors ?? [];

  factory ConnectorResponse.fromJson(Map<String, Object?> json) {
    return ConnectorResponse(
      connector: json[r'connector'] != null
          ? BaseConnectorConfiguration.fromJson(
              json[r'connector']! as Map<String, Object?>)
          : null,
      connectors: (json[r'connectors'] as List<Object?>?)
              ?.map((i) => BaseConnectorConfiguration.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var connector = this.connector;
    var connectors = this.connectors;

    final json = <String, Object?>{};
    if (connector != null) {
      json[r'connector'] = connector.toJson();
    }
    json[r'connectors'] = connectors.map((i) => i.toJson()).toList();
    return json;
  }

  ConnectorResponse copyWith(
      {BaseConnectorConfiguration? connector,
      List<BaseConnectorConfiguration>? connectors}) {
    return ConnectorResponse(
      connector: connector ?? this.connector,
      connectors: connectors ?? this.connectors,
    );
  }
}

/// Models a consent.
class Consent {
  final Map<String, dynamic>? data;
  final String? consentEmailTemplateId;
  final LocalizedIntegers? countryMinimumAgeForSelfConsent;
  final int? defaultMinimumAgeForSelfConsent;
  final EmailPlus? emailPlus;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final bool multipleValuesAllowed;
  final String? name;
  final List<String> values;

  Consent(
      {this.data,
      this.consentEmailTemplateId,
      this.countryMinimumAgeForSelfConsent,
      this.defaultMinimumAgeForSelfConsent,
      this.emailPlus,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      bool? multipleValuesAllowed,
      this.name,
      List<String>? values})
      : multipleValuesAllowed = multipleValuesAllowed ?? false,
        values = values ?? [];

  factory Consent.fromJson(Map<String, Object?> json) {
    return Consent(
      data: json[r'data'] as Map<String, Object?>?,
      consentEmailTemplateId: json[r'consentEmailTemplateId'] as String?,
      countryMinimumAgeForSelfConsent:
          json[r'countryMinimumAgeForSelfConsent'] != null
              ? LocalizedIntegers.fromJson(
                  json[r'countryMinimumAgeForSelfConsent']!
                      as Map<String, Object?>)
              : null,
      defaultMinimumAgeForSelfConsent:
          (json[r'defaultMinimumAgeForSelfConsent'] as num?)?.toInt(),
      emailPlus: json[r'emailPlus'] != null
          ? EmailPlus.fromJson(json[r'emailPlus']! as Map<String, Object?>)
          : null,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      multipleValuesAllowed: json[r'multipleValuesAllowed'] as bool? ?? false,
      name: json[r'name'] as String?,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var consentEmailTemplateId = this.consentEmailTemplateId;
    var countryMinimumAgeForSelfConsent = this.countryMinimumAgeForSelfConsent;
    var defaultMinimumAgeForSelfConsent = this.defaultMinimumAgeForSelfConsent;
    var emailPlus = this.emailPlus;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var multipleValuesAllowed = this.multipleValuesAllowed;
    var name = this.name;
    var values = this.values;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (consentEmailTemplateId != null) {
      json[r'consentEmailTemplateId'] = consentEmailTemplateId;
    }
    if (countryMinimumAgeForSelfConsent != null) {
      json[r'countryMinimumAgeForSelfConsent'] =
          countryMinimumAgeForSelfConsent.toJson();
    }
    if (defaultMinimumAgeForSelfConsent != null) {
      json[r'defaultMinimumAgeForSelfConsent'] =
          defaultMinimumAgeForSelfConsent;
    }
    if (emailPlus != null) {
      json[r'emailPlus'] = emailPlus.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    json[r'multipleValuesAllowed'] = multipleValuesAllowed;
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'values'] = values;
    return json;
  }

  Consent copyWith(
      {Map<String, dynamic>? data,
      String? consentEmailTemplateId,
      LocalizedIntegers? countryMinimumAgeForSelfConsent,
      int? defaultMinimumAgeForSelfConsent,
      EmailPlus? emailPlus,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      bool? multipleValuesAllowed,
      String? name,
      List<String>? values}) {
    return Consent(
      data: data ?? this.data,
      consentEmailTemplateId:
          consentEmailTemplateId ?? this.consentEmailTemplateId,
      countryMinimumAgeForSelfConsent: countryMinimumAgeForSelfConsent ??
          this.countryMinimumAgeForSelfConsent,
      defaultMinimumAgeForSelfConsent: defaultMinimumAgeForSelfConsent ??
          this.defaultMinimumAgeForSelfConsent,
      emailPlus: emailPlus ?? this.emailPlus,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      multipleValuesAllowed:
          multipleValuesAllowed ?? this.multipleValuesAllowed,
      name: name ?? this.name,
      values: values ?? this.values,
    );
  }
}

/// API request for User consent types.
class ConsentRequest {
  final Consent? consent;

  ConsentRequest({this.consent});

  factory ConsentRequest.fromJson(Map<String, Object?> json) {
    return ConsentRequest(
      consent: json[r'consent'] != null
          ? Consent.fromJson(json[r'consent']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var consent = this.consent;

    final json = <String, Object?>{};
    if (consent != null) {
      json[r'consent'] = consent.toJson();
    }
    return json;
  }

  ConsentRequest copyWith({Consent? consent}) {
    return ConsentRequest(
      consent: consent ?? this.consent,
    );
  }
}

/// API response for consent.
class ConsentResponse {
  final Consent? consent;
  final List<Consent> consents;

  ConsentResponse({this.consent, List<Consent>? consents})
      : consents = consents ?? [];

  factory ConsentResponse.fromJson(Map<String, Object?> json) {
    return ConsentResponse(
      consent: json[r'consent'] != null
          ? Consent.fromJson(json[r'consent']! as Map<String, Object?>)
          : null,
      consents: (json[r'consents'] as List<Object?>?)
              ?.map((i) =>
                  Consent.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var consent = this.consent;
    var consents = this.consents;

    final json = <String, Object?>{};
    if (consent != null) {
      json[r'consent'] = consent.toJson();
    }
    json[r'consents'] = consents.map((i) => i.toJson()).toList();
    return json;
  }

  ConsentResponse copyWith({Consent? consent, List<Consent>? consents}) {
    return ConsentResponse(
      consent: consent ?? this.consent,
      consents: consents ?? this.consents,
    );
  }
}

/// Search criteria for Consents
class ConsentSearchCriteria {
  final String? name;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  ConsentSearchCriteria(
      {this.name, this.numberOfResults, this.orderBy, this.startRow});

  factory ConsentSearchCriteria.fromJson(Map<String, Object?> json) {
    return ConsentSearchCriteria(
      name: json[r'name'] as String?,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  ConsentSearchCriteria copyWith(
      {String? name, int? numberOfResults, String? orderBy, int? startRow}) {
    return ConsentSearchCriteria(
      name: name ?? this.name,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Search request for Consents
class ConsentSearchRequest {
  final ConsentSearchCriteria? search;

  ConsentSearchRequest({this.search});

  factory ConsentSearchRequest.fromJson(Map<String, Object?> json) {
    return ConsentSearchRequest(
      search: json[r'search'] != null
          ? ConsentSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  ConsentSearchRequest copyWith({ConsentSearchCriteria? search}) {
    return ConsentSearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Consent search response
class ConsentSearchResponse {
  final List<Consent> consents;
  final int? total;

  ConsentSearchResponse({List<Consent>? consents, this.total})
      : consents = consents ?? [];

  factory ConsentSearchResponse.fromJson(Map<String, Object?> json) {
    return ConsentSearchResponse(
      consents: (json[r'consents'] as List<Object?>?)
              ?.map((i) =>
                  Consent.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var consents = this.consents;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'consents'] = consents.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  ConsentSearchResponse copyWith({List<Consent>? consents, int? total}) {
    return ConsentSearchResponse(
      consents: consents ?? this.consents,
      total: total ?? this.total,
    );
  }
}

class Count {
  final int? count;
  final int? interval;

  Count({this.count, this.interval});

  factory Count.fromJson(Map<String, Object?> json) {
    return Count(
      count: (json[r'count'] as num?)?.toInt(),
      interval: (json[r'interval'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var count = this.count;
    var interval = this.interval;

    final json = <String, Object?>{};
    if (count != null) {
      json[r'count'] = count;
    }
    if (interval != null) {
      json[r'interval'] = interval;
    }
    return json;
  }

  Count copyWith({int? count, int? interval}) {
    return Count(
      count: count ?? this.count,
      interval: interval ?? this.interval,
    );
  }
}

/// Contains the output for the {@code credProps} extension
class CredentialPropertiesOutput {
  final bool rk;

  CredentialPropertiesOutput({bool? rk}) : rk = rk ?? false;

  factory CredentialPropertiesOutput.fromJson(Map<String, Object?> json) {
    return CredentialPropertiesOutput(
      rk: json[r'rk'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var rk = this.rk;

    final json = <String, Object?>{};
    json[r'rk'] = rk;
    return json;
  }

  CredentialPropertiesOutput copyWith({bool? rk}) {
    return CredentialPropertiesOutput(
      rk: rk ?? this.rk,
    );
  }
}

/// Response for the daily active user report.
class DailyActiveUserReportResponse {
  final List<Count> dailyActiveUsers;
  final int? total;

  DailyActiveUserReportResponse({List<Count>? dailyActiveUsers, this.total})
      : dailyActiveUsers = dailyActiveUsers ?? [];

  factory DailyActiveUserReportResponse.fromJson(Map<String, Object?> json) {
    return DailyActiveUserReportResponse(
      dailyActiveUsers: (json[r'dailyActiveUsers'] as List<Object?>?)
              ?.map(
                  (i) => Count.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var dailyActiveUsers = this.dailyActiveUsers;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'dailyActiveUsers'] =
        dailyActiveUsers.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  DailyActiveUserReportResponse copyWith(
      {List<Count>? dailyActiveUsers, int? total}) {
    return DailyActiveUserReportResponse(
      dailyActiveUsers: dailyActiveUsers ?? this.dailyActiveUsers,
      total: total ?? this.total,
    );
  }
}

class DeleteConfiguration {
  final int? numberOfDaysToRetain;
  final bool enabled;

  DeleteConfiguration({this.numberOfDaysToRetain, bool? enabled})
      : enabled = enabled ?? false;

  factory DeleteConfiguration.fromJson(Map<String, Object?> json) {
    return DeleteConfiguration(
      numberOfDaysToRetain: (json[r'numberOfDaysToRetain'] as num?)?.toInt(),
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var numberOfDaysToRetain = this.numberOfDaysToRetain;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (numberOfDaysToRetain != null) {
      json[r'numberOfDaysToRetain'] = numberOfDaysToRetain;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  DeleteConfiguration copyWith({int? numberOfDaysToRetain, bool? enabled}) {
    return DeleteConfiguration(
      numberOfDaysToRetain: numberOfDaysToRetain ?? this.numberOfDaysToRetain,
      enabled: enabled ?? this.enabled,
    );
  }
}

class DeviceApprovalResponse {
  final String? deviceGrantStatus;
  final DeviceInfo? deviceInfo;
  final IdentityProviderLink? identityProviderLink;
  final String? tenantId;
  final String? userId;

  DeviceApprovalResponse(
      {this.deviceGrantStatus,
      this.deviceInfo,
      this.identityProviderLink,
      this.tenantId,
      this.userId});

  factory DeviceApprovalResponse.fromJson(Map<String, Object?> json) {
    return DeviceApprovalResponse(
      deviceGrantStatus: json[r'deviceGrantStatus'] as String?,
      deviceInfo: json[r'deviceInfo'] != null
          ? DeviceInfo.fromJson(json[r'deviceInfo']! as Map<String, Object?>)
          : null,
      identityProviderLink: json[r'identityProviderLink'] != null
          ? IdentityProviderLink.fromJson(
              json[r'identityProviderLink']! as Map<String, Object?>)
          : null,
      tenantId: json[r'tenantId'] as String?,
      userId: json[r'userId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var deviceGrantStatus = this.deviceGrantStatus;
    var deviceInfo = this.deviceInfo;
    var identityProviderLink = this.identityProviderLink;
    var tenantId = this.tenantId;
    var userId = this.userId;

    final json = <String, Object?>{};
    if (deviceGrantStatus != null) {
      json[r'deviceGrantStatus'] = deviceGrantStatus;
    }
    if (deviceInfo != null) {
      json[r'deviceInfo'] = deviceInfo.toJson();
    }
    if (identityProviderLink != null) {
      json[r'identityProviderLink'] = identityProviderLink.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    return json;
  }

  DeviceApprovalResponse copyWith(
      {String? deviceGrantStatus,
      DeviceInfo? deviceInfo,
      IdentityProviderLink? identityProviderLink,
      String? tenantId,
      String? userId}) {
    return DeviceApprovalResponse(
      deviceGrantStatus: deviceGrantStatus ?? this.deviceGrantStatus,
      deviceInfo: deviceInfo ?? this.deviceInfo,
      identityProviderLink: identityProviderLink ?? this.identityProviderLink,
      tenantId: tenantId ?? this.tenantId,
      userId: userId ?? this.userId,
    );
  }
}

class DeviceInfo {
  final String? description;
  final String? lastAccessedAddress;
  final ZonedDateTime? lastAccessedInstant;
  final String? name;
  final String? type;

  DeviceInfo(
      {this.description,
      this.lastAccessedAddress,
      this.lastAccessedInstant,
      this.name,
      this.type});

  factory DeviceInfo.fromJson(Map<String, Object?> json) {
    return DeviceInfo(
      description: json[r'description'] as String?,
      lastAccessedAddress: json[r'lastAccessedAddress'] as String?,
      lastAccessedInstant:
          (json[r'lastAccessedInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      type: json[r'type'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var lastAccessedAddress = this.lastAccessedAddress;
    var lastAccessedInstant = this.lastAccessedInstant;
    var name = this.name;
    var type = this.type;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (lastAccessedAddress != null) {
      json[r'lastAccessedAddress'] = lastAccessedAddress;
    }
    if (lastAccessedInstant != null) {
      json[r'lastAccessedInstant'] = lastAccessedInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type;
    }
    return json;
  }

  DeviceInfo copyWith(
      {String? description,
      String? lastAccessedAddress,
      ZonedDateTime? lastAccessedInstant,
      String? name,
      String? type}) {
    return DeviceInfo(
      description: description ?? this.description,
      lastAccessedAddress: lastAccessedAddress ?? this.lastAccessedAddress,
      lastAccessedInstant: lastAccessedInstant ?? this.lastAccessedInstant,
      name: name ?? this.name,
      type: type ?? this.type,
    );
  }
}

class DeviceResponse {
  final String? deviceCode;
  final int? expiresIn;
  final int? interval;
  final String? userCode;
  final String? verificationUri;
  final String? verificationUriComplete;

  DeviceResponse(
      {this.deviceCode,
      this.expiresIn,
      this.interval,
      this.userCode,
      this.verificationUri,
      this.verificationUriComplete});

  factory DeviceResponse.fromJson(Map<String, Object?> json) {
    return DeviceResponse(
      deviceCode: json[r'device_code'] as String?,
      expiresIn: (json[r'expires_in'] as num?)?.toInt(),
      interval: (json[r'interval'] as num?)?.toInt(),
      userCode: json[r'user_code'] as String?,
      verificationUri: json[r'verification_uri'] as String?,
      verificationUriComplete: json[r'verification_uri_complete'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var deviceCode = this.deviceCode;
    var expiresIn = this.expiresIn;
    var interval = this.interval;
    var userCode = this.userCode;
    var verificationUri = this.verificationUri;
    var verificationUriComplete = this.verificationUriComplete;

    final json = <String, Object?>{};
    if (deviceCode != null) {
      json[r'device_code'] = deviceCode;
    }
    if (expiresIn != null) {
      json[r'expires_in'] = expiresIn;
    }
    if (interval != null) {
      json[r'interval'] = interval;
    }
    if (userCode != null) {
      json[r'user_code'] = userCode;
    }
    if (verificationUri != null) {
      json[r'verification_uri'] = verificationUri;
    }
    if (verificationUriComplete != null) {
      json[r'verification_uri_complete'] = verificationUriComplete;
    }
    return json;
  }

  DeviceResponse copyWith(
      {String? deviceCode,
      int? expiresIn,
      int? interval,
      String? userCode,
      String? verificationUri,
      String? verificationUriComplete}) {
    return DeviceResponse(
      deviceCode: deviceCode ?? this.deviceCode,
      expiresIn: expiresIn ?? this.expiresIn,
      interval: interval ?? this.interval,
      userCode: userCode ?? this.userCode,
      verificationUri: verificationUri ?? this.verificationUri,
      verificationUriComplete:
          verificationUriComplete ?? this.verificationUriComplete,
    );
  }
}

class DeviceUserCodeResponse {
  final String? clientId;
  final DeviceInfo? deviceInfo;
  final int? expiresIn;
  final PendingIdPLink? pendingIdpLink;
  final String? scope;
  final String? tenantId;
  final String? userCode;

  DeviceUserCodeResponse(
      {this.clientId,
      this.deviceInfo,
      this.expiresIn,
      this.pendingIdpLink,
      this.scope,
      this.tenantId,
      this.userCode});

  factory DeviceUserCodeResponse.fromJson(Map<String, Object?> json) {
    return DeviceUserCodeResponse(
      clientId: json[r'client_id'] as String?,
      deviceInfo: json[r'deviceInfo'] != null
          ? DeviceInfo.fromJson(json[r'deviceInfo']! as Map<String, Object?>)
          : null,
      expiresIn: (json[r'expires_in'] as num?)?.toInt(),
      pendingIdpLink: json[r'pendingIdPLink'] != null
          ? PendingIdPLink.fromJson(
              json[r'pendingIdPLink']! as Map<String, Object?>)
          : null,
      scope: json[r'scope'] as String?,
      tenantId: json[r'tenantId'] as String?,
      userCode: json[r'user_code'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var clientId = this.clientId;
    var deviceInfo = this.deviceInfo;
    var expiresIn = this.expiresIn;
    var pendingIdpLink = this.pendingIdpLink;
    var scope = this.scope;
    var tenantId = this.tenantId;
    var userCode = this.userCode;

    final json = <String, Object?>{};
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (deviceInfo != null) {
      json[r'deviceInfo'] = deviceInfo.toJson();
    }
    if (expiresIn != null) {
      json[r'expires_in'] = expiresIn;
    }
    if (pendingIdpLink != null) {
      json[r'pendingIdPLink'] = pendingIdpLink.toJson();
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (userCode != null) {
      json[r'user_code'] = userCode;
    }
    return json;
  }

  DeviceUserCodeResponse copyWith(
      {String? clientId,
      DeviceInfo? deviceInfo,
      int? expiresIn,
      PendingIdPLink? pendingIdpLink,
      String? scope,
      String? tenantId,
      String? userCode}) {
    return DeviceUserCodeResponse(
      clientId: clientId ?? this.clientId,
      deviceInfo: deviceInfo ?? this.deviceInfo,
      expiresIn: expiresIn ?? this.expiresIn,
      pendingIdpLink: pendingIdpLink ?? this.pendingIdpLink,
      scope: scope ?? this.scope,
      tenantId: tenantId ?? this.tenantId,
      userCode: userCode ?? this.userCode,
    );
  }
}

/// A displayable raw login that includes application name and user loginId.
class DisplayableRawLogin {
  final String? applicationName;
  final Location? location;
  final String? loginId;

  DisplayableRawLogin({this.applicationName, this.location, this.loginId});

  factory DisplayableRawLogin.fromJson(Map<String, Object?> json) {
    return DisplayableRawLogin(
      applicationName: json[r'applicationName'] as String?,
      location: json[r'location'] != null
          ? Location.fromJson(json[r'location']! as Map<String, Object?>)
          : null,
      loginId: json[r'loginId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var applicationName = this.applicationName;
    var location = this.location;
    var loginId = this.loginId;

    final json = <String, Object?>{};
    if (applicationName != null) {
      json[r'applicationName'] = applicationName;
    }
    if (location != null) {
      json[r'location'] = location.toJson();
    }
    if (loginId != null) {
      json[r'loginId'] = loginId;
    }
    return json;
  }

  DisplayableRawLogin copyWith(
      {String? applicationName, Location? location, String? loginId}) {
    return DisplayableRawLogin(
      applicationName: applicationName ?? this.applicationName,
      location: location ?? this.location,
      loginId: loginId ?? this.loginId,
    );
  }
}

/// Interface for all identity providers that can be domain based.
class DomainBasedIdentityProvider {
  DomainBasedIdentityProvider();

  factory DomainBasedIdentityProvider.fromJson(Map<String, Object?> json) {
    return DomainBasedIdentityProvider();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// This class is an abstraction of a simple email message.
class Email {
  final List<Attachment> attachments;
  final List<EmailAddress> bcc;
  final List<EmailAddress> cc;
  final EmailAddress? from;
  final String? html;
  final EmailAddress? replyTo;
  final String? subject;
  final String? text;
  final List<EmailAddress> to;

  Email(
      {List<Attachment>? attachments,
      List<EmailAddress>? bcc,
      List<EmailAddress>? cc,
      this.from,
      this.html,
      this.replyTo,
      this.subject,
      this.text,
      List<EmailAddress>? to})
      : attachments = attachments ?? [],
        bcc = bcc ?? [],
        cc = cc ?? [],
        to = to ?? [];

  factory Email.fromJson(Map<String, Object?> json) {
    return Email(
      attachments: (json[r'attachments'] as List<Object?>?)
              ?.map((i) =>
                  Attachment.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      bcc: (json[r'bcc'] as List<Object?>?)
              ?.map((i) =>
                  EmailAddress.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      cc: (json[r'cc'] as List<Object?>?)
              ?.map((i) =>
                  EmailAddress.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      from: json[r'from'] != null
          ? EmailAddress.fromJson(json[r'from']! as Map<String, Object?>)
          : null,
      html: json[r'html'] as String?,
      replyTo: json[r'replyTo'] != null
          ? EmailAddress.fromJson(json[r'replyTo']! as Map<String, Object?>)
          : null,
      subject: json[r'subject'] as String?,
      text: json[r'text'] as String?,
      to: (json[r'to'] as List<Object?>?)
              ?.map((i) =>
                  EmailAddress.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var attachments = this.attachments;
    var bcc = this.bcc;
    var cc = this.cc;
    var from = this.from;
    var html = this.html;
    var replyTo = this.replyTo;
    var subject = this.subject;
    var text = this.text;
    var to = this.to;

    final json = <String, Object?>{};
    json[r'attachments'] = attachments.map((i) => i.toJson()).toList();
    json[r'bcc'] = bcc.map((i) => i.toJson()).toList();
    json[r'cc'] = cc.map((i) => i.toJson()).toList();
    if (from != null) {
      json[r'from'] = from.toJson();
    }
    if (html != null) {
      json[r'html'] = html;
    }
    if (replyTo != null) {
      json[r'replyTo'] = replyTo.toJson();
    }
    if (subject != null) {
      json[r'subject'] = subject;
    }
    if (text != null) {
      json[r'text'] = text;
    }
    json[r'to'] = to.map((i) => i.toJson()).toList();
    return json;
  }

  Email copyWith(
      {List<Attachment>? attachments,
      List<EmailAddress>? bcc,
      List<EmailAddress>? cc,
      EmailAddress? from,
      String? html,
      EmailAddress? replyTo,
      String? subject,
      String? text,
      List<EmailAddress>? to}) {
    return Email(
      attachments: attachments ?? this.attachments,
      bcc: bcc ?? this.bcc,
      cc: cc ?? this.cc,
      from: from ?? this.from,
      html: html ?? this.html,
      replyTo: replyTo ?? this.replyTo,
      subject: subject ?? this.subject,
      text: text ?? this.text,
      to: to ?? this.to,
    );
  }
}

/// An email address.
class EmailAddress {
  final String? address;
  final String? display;

  EmailAddress({this.address, this.display});

  factory EmailAddress.fromJson(Map<String, Object?> json) {
    return EmailAddress(
      address: json[r'address'] as String?,
      display: json[r'display'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var address = this.address;
    var display = this.display;

    final json = <String, Object?>{};
    if (address != null) {
      json[r'address'] = address;
    }
    if (display != null) {
      json[r'display'] = display;
    }
    return json;
  }

  EmailAddress copyWith({String? address, String? display}) {
    return EmailAddress(
      address: address ?? this.address,
      display: display ?? this.display,
    );
  }
}

class EmailConfiguration {
  final List<EmailHeader> additionalHeaders;
  final bool debug;
  final String? defaultFromEmail;
  final String? defaultFromName;
  final String? emailUpdateEmailTemplateId;
  final String? emailVerifiedEmailTemplateId;
  final String? forgotPasswordEmailTemplateId;
  final String? host;
  final bool implicitEmailVerificationAllowed;
  final String? loginIdInUseOnCreateEmailTemplateId;
  final String? loginIdInUseOnUpdateEmailTemplateId;
  final String? loginNewDeviceEmailTemplateId;
  final String? loginSuspiciousEmailTemplateId;
  final String? password;
  final String? passwordResetSuccessEmailTemplateId;
  final String? passwordUpdateEmailTemplateId;
  final String? passwordlessEmailTemplateId;
  final int? port;
  final String? properties;
  final EmailSecurityType? security;
  final String? setPasswordEmailTemplateId;
  final String? twoFactorMethodAddEmailTemplateId;
  final String? twoFactorMethodRemoveEmailTemplateId;
  final EmailUnverifiedOptions? unverified;
  final String? username;
  final String? verificationEmailTemplateId;
  final VerificationStrategy? verificationStrategy;
  final bool verifyEmail;
  final bool verifyEmailWhenChanged;

  EmailConfiguration(
      {List<EmailHeader>? additionalHeaders,
      bool? debug,
      this.defaultFromEmail,
      this.defaultFromName,
      this.emailUpdateEmailTemplateId,
      this.emailVerifiedEmailTemplateId,
      this.forgotPasswordEmailTemplateId,
      this.host,
      bool? implicitEmailVerificationAllowed,
      this.loginIdInUseOnCreateEmailTemplateId,
      this.loginIdInUseOnUpdateEmailTemplateId,
      this.loginNewDeviceEmailTemplateId,
      this.loginSuspiciousEmailTemplateId,
      this.password,
      this.passwordResetSuccessEmailTemplateId,
      this.passwordUpdateEmailTemplateId,
      this.passwordlessEmailTemplateId,
      this.port,
      this.properties,
      this.security,
      this.setPasswordEmailTemplateId,
      this.twoFactorMethodAddEmailTemplateId,
      this.twoFactorMethodRemoveEmailTemplateId,
      this.unverified,
      this.username,
      this.verificationEmailTemplateId,
      this.verificationStrategy,
      bool? verifyEmail,
      bool? verifyEmailWhenChanged})
      : additionalHeaders = additionalHeaders ?? [],
        debug = debug ?? false,
        implicitEmailVerificationAllowed =
            implicitEmailVerificationAllowed ?? false,
        verifyEmail = verifyEmail ?? false,
        verifyEmailWhenChanged = verifyEmailWhenChanged ?? false;

  factory EmailConfiguration.fromJson(Map<String, Object?> json) {
    return EmailConfiguration(
      additionalHeaders: (json[r'additionalHeaders'] as List<Object?>?)
              ?.map((i) =>
                  EmailHeader.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      debug: json[r'debug'] as bool? ?? false,
      defaultFromEmail: json[r'defaultFromEmail'] as String?,
      defaultFromName: json[r'defaultFromName'] as String?,
      emailUpdateEmailTemplateId:
          json[r'emailUpdateEmailTemplateId'] as String?,
      emailVerifiedEmailTemplateId:
          json[r'emailVerifiedEmailTemplateId'] as String?,
      forgotPasswordEmailTemplateId:
          json[r'forgotPasswordEmailTemplateId'] as String?,
      host: json[r'host'] as String?,
      implicitEmailVerificationAllowed:
          json[r'implicitEmailVerificationAllowed'] as bool? ?? false,
      loginIdInUseOnCreateEmailTemplateId:
          json[r'loginIdInUseOnCreateEmailTemplateId'] as String?,
      loginIdInUseOnUpdateEmailTemplateId:
          json[r'loginIdInUseOnUpdateEmailTemplateId'] as String?,
      loginNewDeviceEmailTemplateId:
          json[r'loginNewDeviceEmailTemplateId'] as String?,
      loginSuspiciousEmailTemplateId:
          json[r'loginSuspiciousEmailTemplateId'] as String?,
      password: json[r'password'] as String?,
      passwordResetSuccessEmailTemplateId:
          json[r'passwordResetSuccessEmailTemplateId'] as String?,
      passwordUpdateEmailTemplateId:
          json[r'passwordUpdateEmailTemplateId'] as String?,
      passwordlessEmailTemplateId:
          json[r'passwordlessEmailTemplateId'] as String?,
      port: (json[r'port'] as num?)?.toInt(),
      properties: json[r'properties'] as String?,
      security: json[r'security'] != null
          ? EmailSecurityType.fromValue(json[r'security']! as String)
          : null,
      setPasswordEmailTemplateId:
          json[r'setPasswordEmailTemplateId'] as String?,
      twoFactorMethodAddEmailTemplateId:
          json[r'twoFactorMethodAddEmailTemplateId'] as String?,
      twoFactorMethodRemoveEmailTemplateId:
          json[r'twoFactorMethodRemoveEmailTemplateId'] as String?,
      unverified: json[r'unverified'] != null
          ? EmailUnverifiedOptions.fromJson(
              json[r'unverified']! as Map<String, Object?>)
          : null,
      username: json[r'username'] as String?,
      verificationEmailTemplateId:
          json[r'verificationEmailTemplateId'] as String?,
      verificationStrategy: json[r'verificationStrategy'] != null
          ? VerificationStrategy.fromValue(
              json[r'verificationStrategy']! as String)
          : null,
      verifyEmail: json[r'verifyEmail'] as bool? ?? false,
      verifyEmailWhenChanged: json[r'verifyEmailWhenChanged'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var additionalHeaders = this.additionalHeaders;
    var debug = this.debug;
    var defaultFromEmail = this.defaultFromEmail;
    var defaultFromName = this.defaultFromName;
    var emailUpdateEmailTemplateId = this.emailUpdateEmailTemplateId;
    var emailVerifiedEmailTemplateId = this.emailVerifiedEmailTemplateId;
    var forgotPasswordEmailTemplateId = this.forgotPasswordEmailTemplateId;
    var host = this.host;
    var implicitEmailVerificationAllowed =
        this.implicitEmailVerificationAllowed;
    var loginIdInUseOnCreateEmailTemplateId =
        this.loginIdInUseOnCreateEmailTemplateId;
    var loginIdInUseOnUpdateEmailTemplateId =
        this.loginIdInUseOnUpdateEmailTemplateId;
    var loginNewDeviceEmailTemplateId = this.loginNewDeviceEmailTemplateId;
    var loginSuspiciousEmailTemplateId = this.loginSuspiciousEmailTemplateId;
    var password = this.password;
    var passwordResetSuccessEmailTemplateId =
        this.passwordResetSuccessEmailTemplateId;
    var passwordUpdateEmailTemplateId = this.passwordUpdateEmailTemplateId;
    var passwordlessEmailTemplateId = this.passwordlessEmailTemplateId;
    var port = this.port;
    var properties = this.properties;
    var security = this.security;
    var setPasswordEmailTemplateId = this.setPasswordEmailTemplateId;
    var twoFactorMethodAddEmailTemplateId =
        this.twoFactorMethodAddEmailTemplateId;
    var twoFactorMethodRemoveEmailTemplateId =
        this.twoFactorMethodRemoveEmailTemplateId;
    var unverified = this.unverified;
    var username = this.username;
    var verificationEmailTemplateId = this.verificationEmailTemplateId;
    var verificationStrategy = this.verificationStrategy;
    var verifyEmail = this.verifyEmail;
    var verifyEmailWhenChanged = this.verifyEmailWhenChanged;

    final json = <String, Object?>{};
    json[r'additionalHeaders'] =
        additionalHeaders.map((i) => i.toJson()).toList();
    json[r'debug'] = debug;
    if (defaultFromEmail != null) {
      json[r'defaultFromEmail'] = defaultFromEmail;
    }
    if (defaultFromName != null) {
      json[r'defaultFromName'] = defaultFromName;
    }
    if (emailUpdateEmailTemplateId != null) {
      json[r'emailUpdateEmailTemplateId'] = emailUpdateEmailTemplateId;
    }
    if (emailVerifiedEmailTemplateId != null) {
      json[r'emailVerifiedEmailTemplateId'] = emailVerifiedEmailTemplateId;
    }
    if (forgotPasswordEmailTemplateId != null) {
      json[r'forgotPasswordEmailTemplateId'] = forgotPasswordEmailTemplateId;
    }
    if (host != null) {
      json[r'host'] = host;
    }
    json[r'implicitEmailVerificationAllowed'] =
        implicitEmailVerificationAllowed;
    if (loginIdInUseOnCreateEmailTemplateId != null) {
      json[r'loginIdInUseOnCreateEmailTemplateId'] =
          loginIdInUseOnCreateEmailTemplateId;
    }
    if (loginIdInUseOnUpdateEmailTemplateId != null) {
      json[r'loginIdInUseOnUpdateEmailTemplateId'] =
          loginIdInUseOnUpdateEmailTemplateId;
    }
    if (loginNewDeviceEmailTemplateId != null) {
      json[r'loginNewDeviceEmailTemplateId'] = loginNewDeviceEmailTemplateId;
    }
    if (loginSuspiciousEmailTemplateId != null) {
      json[r'loginSuspiciousEmailTemplateId'] = loginSuspiciousEmailTemplateId;
    }
    if (password != null) {
      json[r'password'] = password;
    }
    if (passwordResetSuccessEmailTemplateId != null) {
      json[r'passwordResetSuccessEmailTemplateId'] =
          passwordResetSuccessEmailTemplateId;
    }
    if (passwordUpdateEmailTemplateId != null) {
      json[r'passwordUpdateEmailTemplateId'] = passwordUpdateEmailTemplateId;
    }
    if (passwordlessEmailTemplateId != null) {
      json[r'passwordlessEmailTemplateId'] = passwordlessEmailTemplateId;
    }
    if (port != null) {
      json[r'port'] = port;
    }
    if (properties != null) {
      json[r'properties'] = properties;
    }
    if (security != null) {
      json[r'security'] = security.value;
    }
    if (setPasswordEmailTemplateId != null) {
      json[r'setPasswordEmailTemplateId'] = setPasswordEmailTemplateId;
    }
    if (twoFactorMethodAddEmailTemplateId != null) {
      json[r'twoFactorMethodAddEmailTemplateId'] =
          twoFactorMethodAddEmailTemplateId;
    }
    if (twoFactorMethodRemoveEmailTemplateId != null) {
      json[r'twoFactorMethodRemoveEmailTemplateId'] =
          twoFactorMethodRemoveEmailTemplateId;
    }
    if (unverified != null) {
      json[r'unverified'] = unverified.toJson();
    }
    if (username != null) {
      json[r'username'] = username;
    }
    if (verificationEmailTemplateId != null) {
      json[r'verificationEmailTemplateId'] = verificationEmailTemplateId;
    }
    if (verificationStrategy != null) {
      json[r'verificationStrategy'] = verificationStrategy.value;
    }
    json[r'verifyEmail'] = verifyEmail;
    json[r'verifyEmailWhenChanged'] = verifyEmailWhenChanged;
    return json;
  }

  EmailConfiguration copyWith(
      {List<EmailHeader>? additionalHeaders,
      bool? debug,
      String? defaultFromEmail,
      String? defaultFromName,
      String? emailUpdateEmailTemplateId,
      String? emailVerifiedEmailTemplateId,
      String? forgotPasswordEmailTemplateId,
      String? host,
      bool? implicitEmailVerificationAllowed,
      String? loginIdInUseOnCreateEmailTemplateId,
      String? loginIdInUseOnUpdateEmailTemplateId,
      String? loginNewDeviceEmailTemplateId,
      String? loginSuspiciousEmailTemplateId,
      String? password,
      String? passwordResetSuccessEmailTemplateId,
      String? passwordUpdateEmailTemplateId,
      String? passwordlessEmailTemplateId,
      int? port,
      String? properties,
      EmailSecurityType? security,
      String? setPasswordEmailTemplateId,
      String? twoFactorMethodAddEmailTemplateId,
      String? twoFactorMethodRemoveEmailTemplateId,
      EmailUnverifiedOptions? unverified,
      String? username,
      String? verificationEmailTemplateId,
      VerificationStrategy? verificationStrategy,
      bool? verifyEmail,
      bool? verifyEmailWhenChanged}) {
    return EmailConfiguration(
      additionalHeaders: additionalHeaders ?? this.additionalHeaders,
      debug: debug ?? this.debug,
      defaultFromEmail: defaultFromEmail ?? this.defaultFromEmail,
      defaultFromName: defaultFromName ?? this.defaultFromName,
      emailUpdateEmailTemplateId:
          emailUpdateEmailTemplateId ?? this.emailUpdateEmailTemplateId,
      emailVerifiedEmailTemplateId:
          emailVerifiedEmailTemplateId ?? this.emailVerifiedEmailTemplateId,
      forgotPasswordEmailTemplateId:
          forgotPasswordEmailTemplateId ?? this.forgotPasswordEmailTemplateId,
      host: host ?? this.host,
      implicitEmailVerificationAllowed: implicitEmailVerificationAllowed ??
          this.implicitEmailVerificationAllowed,
      loginIdInUseOnCreateEmailTemplateId:
          loginIdInUseOnCreateEmailTemplateId ??
              this.loginIdInUseOnCreateEmailTemplateId,
      loginIdInUseOnUpdateEmailTemplateId:
          loginIdInUseOnUpdateEmailTemplateId ??
              this.loginIdInUseOnUpdateEmailTemplateId,
      loginNewDeviceEmailTemplateId:
          loginNewDeviceEmailTemplateId ?? this.loginNewDeviceEmailTemplateId,
      loginSuspiciousEmailTemplateId:
          loginSuspiciousEmailTemplateId ?? this.loginSuspiciousEmailTemplateId,
      password: password ?? this.password,
      passwordResetSuccessEmailTemplateId:
          passwordResetSuccessEmailTemplateId ??
              this.passwordResetSuccessEmailTemplateId,
      passwordUpdateEmailTemplateId:
          passwordUpdateEmailTemplateId ?? this.passwordUpdateEmailTemplateId,
      passwordlessEmailTemplateId:
          passwordlessEmailTemplateId ?? this.passwordlessEmailTemplateId,
      port: port ?? this.port,
      properties: properties ?? this.properties,
      security: security ?? this.security,
      setPasswordEmailTemplateId:
          setPasswordEmailTemplateId ?? this.setPasswordEmailTemplateId,
      twoFactorMethodAddEmailTemplateId: twoFactorMethodAddEmailTemplateId ??
          this.twoFactorMethodAddEmailTemplateId,
      twoFactorMethodRemoveEmailTemplateId:
          twoFactorMethodRemoveEmailTemplateId ??
              this.twoFactorMethodRemoveEmailTemplateId,
      unverified: unverified ?? this.unverified,
      username: username ?? this.username,
      verificationEmailTemplateId:
          verificationEmailTemplateId ?? this.verificationEmailTemplateId,
      verificationStrategy: verificationStrategy ?? this.verificationStrategy,
      verifyEmail: verifyEmail ?? this.verifyEmail,
      verifyEmailWhenChanged:
          verifyEmailWhenChanged ?? this.verifyEmailWhenChanged,
    );
  }
}

class EmailHeader {
  final String? name;
  final String? value;

  EmailHeader({this.name, this.value});

  factory EmailHeader.fromJson(Map<String, Object?> json) {
    return EmailHeader(
      name: json[r'name'] as String?,
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var value = this.value;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  EmailHeader copyWith({String? name, String? value}) {
    return EmailHeader(
      name: name ?? this.name,
      value: value ?? this.value,
    );
  }
}

class EmailPlus {
  final String? emailTemplateId;
  final int? maximumTimeToSendEmailInHours;
  final int? minimumTimeToSendEmailInHours;
  final bool enabled;

  EmailPlus(
      {this.emailTemplateId,
      this.maximumTimeToSendEmailInHours,
      this.minimumTimeToSendEmailInHours,
      bool? enabled})
      : enabled = enabled ?? false;

  factory EmailPlus.fromJson(Map<String, Object?> json) {
    return EmailPlus(
      emailTemplateId: json[r'emailTemplateId'] as String?,
      maximumTimeToSendEmailInHours:
          (json[r'maximumTimeToSendEmailInHours'] as num?)?.toInt(),
      minimumTimeToSendEmailInHours:
          (json[r'minimumTimeToSendEmailInHours'] as num?)?.toInt(),
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var emailTemplateId = this.emailTemplateId;
    var maximumTimeToSendEmailInHours = this.maximumTimeToSendEmailInHours;
    var minimumTimeToSendEmailInHours = this.minimumTimeToSendEmailInHours;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (emailTemplateId != null) {
      json[r'emailTemplateId'] = emailTemplateId;
    }
    if (maximumTimeToSendEmailInHours != null) {
      json[r'maximumTimeToSendEmailInHours'] = maximumTimeToSendEmailInHours;
    }
    if (minimumTimeToSendEmailInHours != null) {
      json[r'minimumTimeToSendEmailInHours'] = minimumTimeToSendEmailInHours;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  EmailPlus copyWith(
      {String? emailTemplateId,
      int? maximumTimeToSendEmailInHours,
      int? minimumTimeToSendEmailInHours,
      bool? enabled}) {
    return EmailPlus(
      emailTemplateId: emailTemplateId ?? this.emailTemplateId,
      maximumTimeToSendEmailInHours:
          maximumTimeToSendEmailInHours ?? this.maximumTimeToSendEmailInHours,
      minimumTimeToSendEmailInHours:
          minimumTimeToSendEmailInHours ?? this.minimumTimeToSendEmailInHours,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Stores an email template used to send emails to users.
class EmailTemplate {
  final String? defaultFromName;
  final String? defaultHtmlTemplate;
  final String? defaultSubject;
  final String? defaultTextTemplate;
  final String? fromEmail;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final LocalizedStrings? localizedFromNames;
  final LocalizedStrings? localizedHtmlTemplates;
  final LocalizedStrings? localizedSubjects;
  final LocalizedStrings? localizedTextTemplates;
  final String? name;

  EmailTemplate(
      {this.defaultFromName,
      this.defaultHtmlTemplate,
      this.defaultSubject,
      this.defaultTextTemplate,
      this.fromEmail,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.localizedFromNames,
      this.localizedHtmlTemplates,
      this.localizedSubjects,
      this.localizedTextTemplates,
      this.name});

  factory EmailTemplate.fromJson(Map<String, Object?> json) {
    return EmailTemplate(
      defaultFromName: json[r'defaultFromName'] as String?,
      defaultHtmlTemplate: json[r'defaultHtmlTemplate'] as String?,
      defaultSubject: json[r'defaultSubject'] as String?,
      defaultTextTemplate: json[r'defaultTextTemplate'] as String?,
      fromEmail: json[r'fromEmail'] as String?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      localizedFromNames: json[r'localizedFromNames'] != null
          ? LocalizedStrings.fromJson(
              json[r'localizedFromNames']! as Map<String, Object?>)
          : null,
      localizedHtmlTemplates: json[r'localizedHtmlTemplates'] != null
          ? LocalizedStrings.fromJson(
              json[r'localizedHtmlTemplates']! as Map<String, Object?>)
          : null,
      localizedSubjects: json[r'localizedSubjects'] != null
          ? LocalizedStrings.fromJson(
              json[r'localizedSubjects']! as Map<String, Object?>)
          : null,
      localizedTextTemplates: json[r'localizedTextTemplates'] != null
          ? LocalizedStrings.fromJson(
              json[r'localizedTextTemplates']! as Map<String, Object?>)
          : null,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var defaultFromName = this.defaultFromName;
    var defaultHtmlTemplate = this.defaultHtmlTemplate;
    var defaultSubject = this.defaultSubject;
    var defaultTextTemplate = this.defaultTextTemplate;
    var fromEmail = this.fromEmail;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var localizedFromNames = this.localizedFromNames;
    var localizedHtmlTemplates = this.localizedHtmlTemplates;
    var localizedSubjects = this.localizedSubjects;
    var localizedTextTemplates = this.localizedTextTemplates;
    var name = this.name;

    final json = <String, Object?>{};
    if (defaultFromName != null) {
      json[r'defaultFromName'] = defaultFromName;
    }
    if (defaultHtmlTemplate != null) {
      json[r'defaultHtmlTemplate'] = defaultHtmlTemplate;
    }
    if (defaultSubject != null) {
      json[r'defaultSubject'] = defaultSubject;
    }
    if (defaultTextTemplate != null) {
      json[r'defaultTextTemplate'] = defaultTextTemplate;
    }
    if (fromEmail != null) {
      json[r'fromEmail'] = fromEmail;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (localizedFromNames != null) {
      json[r'localizedFromNames'] = localizedFromNames.toJson();
    }
    if (localizedHtmlTemplates != null) {
      json[r'localizedHtmlTemplates'] = localizedHtmlTemplates.toJson();
    }
    if (localizedSubjects != null) {
      json[r'localizedSubjects'] = localizedSubjects.toJson();
    }
    if (localizedTextTemplates != null) {
      json[r'localizedTextTemplates'] = localizedTextTemplates.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  EmailTemplate copyWith(
      {String? defaultFromName,
      String? defaultHtmlTemplate,
      String? defaultSubject,
      String? defaultTextTemplate,
      String? fromEmail,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      LocalizedStrings? localizedFromNames,
      LocalizedStrings? localizedHtmlTemplates,
      LocalizedStrings? localizedSubjects,
      LocalizedStrings? localizedTextTemplates,
      String? name}) {
    return EmailTemplate(
      defaultFromName: defaultFromName ?? this.defaultFromName,
      defaultHtmlTemplate: defaultHtmlTemplate ?? this.defaultHtmlTemplate,
      defaultSubject: defaultSubject ?? this.defaultSubject,
      defaultTextTemplate: defaultTextTemplate ?? this.defaultTextTemplate,
      fromEmail: fromEmail ?? this.fromEmail,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      localizedFromNames: localizedFromNames ?? this.localizedFromNames,
      localizedHtmlTemplates:
          localizedHtmlTemplates ?? this.localizedHtmlTemplates,
      localizedSubjects: localizedSubjects ?? this.localizedSubjects,
      localizedTextTemplates:
          localizedTextTemplates ?? this.localizedTextTemplates,
      name: name ?? this.name,
    );
  }
}

class EmailTemplateErrors {
  final Map<String, dynamic>? parseErrors;
  final Map<String, dynamic>? renderErrors;

  EmailTemplateErrors({this.parseErrors, this.renderErrors});

  factory EmailTemplateErrors.fromJson(Map<String, Object?> json) {
    return EmailTemplateErrors(
      parseErrors: json[r'parseErrors'] as Map<String, Object?>?,
      renderErrors: json[r'renderErrors'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var parseErrors = this.parseErrors;
    var renderErrors = this.renderErrors;

    final json = <String, Object?>{};
    if (parseErrors != null) {
      json[r'parseErrors'] = parseErrors;
    }
    if (renderErrors != null) {
      json[r'renderErrors'] = renderErrors;
    }
    return json;
  }

  EmailTemplateErrors copyWith(
      {Map<String, dynamic>? parseErrors, Map<String, dynamic>? renderErrors}) {
    return EmailTemplateErrors(
      parseErrors: parseErrors ?? this.parseErrors,
      renderErrors: renderErrors ?? this.renderErrors,
    );
  }
}

/// Email template request.
class EmailTemplateRequest {
  final EmailTemplate? emailTemplate;

  EmailTemplateRequest({this.emailTemplate});

  factory EmailTemplateRequest.fromJson(Map<String, Object?> json) {
    return EmailTemplateRequest(
      emailTemplate: json[r'emailTemplate'] != null
          ? EmailTemplate.fromJson(
              json[r'emailTemplate']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var emailTemplate = this.emailTemplate;

    final json = <String, Object?>{};
    if (emailTemplate != null) {
      json[r'emailTemplate'] = emailTemplate.toJson();
    }
    return json;
  }

  EmailTemplateRequest copyWith({EmailTemplate? emailTemplate}) {
    return EmailTemplateRequest(
      emailTemplate: emailTemplate ?? this.emailTemplate,
    );
  }
}

/// Email template response.
class EmailTemplateResponse {
  final EmailTemplate? emailTemplate;
  final List<EmailTemplate> emailTemplates;

  EmailTemplateResponse(
      {this.emailTemplate, List<EmailTemplate>? emailTemplates})
      : emailTemplates = emailTemplates ?? [];

  factory EmailTemplateResponse.fromJson(Map<String, Object?> json) {
    return EmailTemplateResponse(
      emailTemplate: json[r'emailTemplate'] != null
          ? EmailTemplate.fromJson(
              json[r'emailTemplate']! as Map<String, Object?>)
          : null,
      emailTemplates: (json[r'emailTemplates'] as List<Object?>?)
              ?.map((i) => EmailTemplate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var emailTemplate = this.emailTemplate;
    var emailTemplates = this.emailTemplates;

    final json = <String, Object?>{};
    if (emailTemplate != null) {
      json[r'emailTemplate'] = emailTemplate.toJson();
    }
    json[r'emailTemplates'] = emailTemplates.map((i) => i.toJson()).toList();
    return json;
  }

  EmailTemplateResponse copyWith(
      {EmailTemplate? emailTemplate, List<EmailTemplate>? emailTemplates}) {
    return EmailTemplateResponse(
      emailTemplate: emailTemplate ?? this.emailTemplate,
      emailTemplates: emailTemplates ?? this.emailTemplates,
    );
  }
}

/// Search criteria for Email templates
class EmailTemplateSearchCriteria {
  final String? name;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  EmailTemplateSearchCriteria(
      {this.name, this.numberOfResults, this.orderBy, this.startRow});

  factory EmailTemplateSearchCriteria.fromJson(Map<String, Object?> json) {
    return EmailTemplateSearchCriteria(
      name: json[r'name'] as String?,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  EmailTemplateSearchCriteria copyWith(
      {String? name, int? numberOfResults, String? orderBy, int? startRow}) {
    return EmailTemplateSearchCriteria(
      name: name ?? this.name,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Search request for email templates
class EmailTemplateSearchRequest {
  final EmailTemplateSearchCriteria? search;

  EmailTemplateSearchRequest({this.search});

  factory EmailTemplateSearchRequest.fromJson(Map<String, Object?> json) {
    return EmailTemplateSearchRequest(
      search: json[r'search'] != null
          ? EmailTemplateSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  EmailTemplateSearchRequest copyWith({EmailTemplateSearchCriteria? search}) {
    return EmailTemplateSearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Email template search response
class EmailTemplateSearchResponse {
  final List<EmailTemplate> emailTemplates;
  final int? total;

  EmailTemplateSearchResponse({List<EmailTemplate>? emailTemplates, this.total})
      : emailTemplates = emailTemplates ?? [];

  factory EmailTemplateSearchResponse.fromJson(Map<String, Object?> json) {
    return EmailTemplateSearchResponse(
      emailTemplates: (json[r'emailTemplates'] as List<Object?>?)
              ?.map((i) => EmailTemplate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var emailTemplates = this.emailTemplates;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'emailTemplates'] = emailTemplates.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  EmailTemplateSearchResponse copyWith(
      {List<EmailTemplate>? emailTemplates, int? total}) {
    return EmailTemplateSearchResponse(
      emailTemplates: emailTemplates ?? this.emailTemplates,
      total: total ?? this.total,
    );
  }
}

class EmailUnverifiedOptions {
  final bool allowEmailChangeWhenGated;
  final UnverifiedBehavior? behavior;

  EmailUnverifiedOptions({bool? allowEmailChangeWhenGated, this.behavior})
      : allowEmailChangeWhenGated = allowEmailChangeWhenGated ?? false;

  factory EmailUnverifiedOptions.fromJson(Map<String, Object?> json) {
    return EmailUnverifiedOptions(
      allowEmailChangeWhenGated:
          json[r'allowEmailChangeWhenGated'] as bool? ?? false,
      behavior: json[r'behavior'] != null
          ? UnverifiedBehavior.fromValue(json[r'behavior']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var allowEmailChangeWhenGated = this.allowEmailChangeWhenGated;
    var behavior = this.behavior;

    final json = <String, Object?>{};
    json[r'allowEmailChangeWhenGated'] = allowEmailChangeWhenGated;
    if (behavior != null) {
      json[r'behavior'] = behavior.value;
    }
    return json;
  }

  EmailUnverifiedOptions copyWith(
      {bool? allowEmailChangeWhenGated, UnverifiedBehavior? behavior}) {
    return EmailUnverifiedOptions(
      allowEmailChangeWhenGated:
          allowEmailChangeWhenGated ?? this.allowEmailChangeWhenGated,
      behavior: behavior ?? this.behavior,
    );
  }
}

/// Something that can be enabled and thus also disabled.
class Enableable {
  final bool enabled;

  Enableable({bool? enabled}) : enabled = enabled ?? false;

  factory Enableable.fromJson(Map<String, Object?> json) {
    return Enableable(
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var enabled = this.enabled;

    final json = <String, Object?>{};
    json[r'enabled'] = enabled;
    return json;
  }

  Enableable copyWith({bool? enabled}) {
    return Enableable(
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Models an entity that a user can be granted permissions to. Or an entity
/// that can be granted permissions to another entity.
class Entity {
  final Map<String, dynamic>? data;
  final String? clientId;
  final String? clientSecret;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final String? parentId;
  final String? tenantId;
  final EntityType? type;

  Entity(
      {this.data,
      this.clientId,
      this.clientSecret,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.name,
      this.parentId,
      this.tenantId,
      this.type});

  factory Entity.fromJson(Map<String, Object?> json) {
    return Entity(
      data: json[r'data'] as Map<String, Object?>?,
      clientId: json[r'clientId'] as String?,
      clientSecret: json[r'clientSecret'] as String?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      parentId: json[r'parentId'] as String?,
      tenantId: json[r'tenantId'] as String?,
      type: json[r'type'] != null
          ? EntityType.fromJson(json[r'type']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var parentId = this.parentId;
    var tenantId = this.tenantId;
    var type = this.type;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (clientId != null) {
      json[r'clientId'] = clientId;
    }
    if (clientSecret != null) {
      json[r'clientSecret'] = clientSecret;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (parentId != null) {
      json[r'parentId'] = parentId;
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (type != null) {
      json[r'type'] = type.toJson();
    }
    return json;
  }

  Entity copyWith(
      {Map<String, dynamic>? data,
      String? clientId,
      String? clientSecret,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      String? parentId,
      String? tenantId,
      EntityType? type}) {
    return Entity(
      data: data ?? this.data,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      parentId: parentId ?? this.parentId,
      tenantId: tenantId ?? this.tenantId,
      type: type ?? this.type,
    );
  }
}

/// A grant for an entity to a user or another entity.
class EntityGrant {
  final Map<String, dynamic>? data;
  final Entity? entity;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final List<dynamic> permissions;
  final String? recipientEntityId;
  final String? userId;

  EntityGrant(
      {this.data,
      this.entity,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      List<dynamic>? permissions,
      this.recipientEntityId,
      this.userId})
      : permissions = permissions ?? [];

  factory EntityGrant.fromJson(Map<String, Object?> json) {
    return EntityGrant(
      data: json[r'data'] as Map<String, Object?>?,
      entity: json[r'entity'] != null
          ? Entity.fromJson(json[r'entity']! as Map<String, Object?>)
          : null,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      permissions:
          (json[r'permissions'] as List<Object?>?)?.map((i) => i).toList() ??
              [],
      recipientEntityId: json[r'recipientEntityId'] as String?,
      userId: json[r'userId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var entity = this.entity;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var permissions = this.permissions;
    var recipientEntityId = this.recipientEntityId;
    var userId = this.userId;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (entity != null) {
      json[r'entity'] = entity.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    json[r'permissions'] = permissions;
    if (recipientEntityId != null) {
      json[r'recipientEntityId'] = recipientEntityId;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    return json;
  }

  EntityGrant copyWith(
      {Map<String, dynamic>? data,
      Entity? entity,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      List<dynamic>? permissions,
      String? recipientEntityId,
      String? userId}) {
    return EntityGrant(
      data: data ?? this.data,
      entity: entity ?? this.entity,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      permissions: permissions ?? this.permissions,
      recipientEntityId: recipientEntityId ?? this.recipientEntityId,
      userId: userId ?? this.userId,
    );
  }
}

/// Entity grant API request object.
class EntityGrantRequest {
  final EntityGrant? grant;

  EntityGrantRequest({this.grant});

  factory EntityGrantRequest.fromJson(Map<String, Object?> json) {
    return EntityGrantRequest(
      grant: json[r'grant'] != null
          ? EntityGrant.fromJson(json[r'grant']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var grant = this.grant;

    final json = <String, Object?>{};
    if (grant != null) {
      json[r'grant'] = grant.toJson();
    }
    return json;
  }

  EntityGrantRequest copyWith({EntityGrant? grant}) {
    return EntityGrantRequest(
      grant: grant ?? this.grant,
    );
  }
}

/// Entity grant API response object.
class EntityGrantResponse {
  final List<EntityGrant> grants;
  final EntityGrant? grant;

  EntityGrantResponse({List<EntityGrant>? grants, this.grant})
      : grants = grants ?? [];

  factory EntityGrantResponse.fromJson(Map<String, Object?> json) {
    return EntityGrantResponse(
      grants: (json[r'grants'] as List<Object?>?)
              ?.map((i) =>
                  EntityGrant.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      grant: json[r'grant'] != null
          ? EntityGrant.fromJson(json[r'grant']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var grants = this.grants;
    var grant = this.grant;

    final json = <String, Object?>{};
    json[r'grants'] = grants.map((i) => i.toJson()).toList();
    if (grant != null) {
      json[r'grant'] = grant.toJson();
    }
    return json;
  }

  EntityGrantResponse copyWith(
      {List<EntityGrant>? grants, EntityGrant? grant}) {
    return EntityGrantResponse(
      grants: grants ?? this.grants,
      grant: grant ?? this.grant,
    );
  }
}

/// Search criteria for entity grants.
class EntityGrantSearchCriteria {
  final String? entityId;
  final String? name;
  final String? userId;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  EntityGrantSearchCriteria(
      {this.entityId,
      this.name,
      this.userId,
      this.numberOfResults,
      this.orderBy,
      this.startRow});

  factory EntityGrantSearchCriteria.fromJson(Map<String, Object?> json) {
    return EntityGrantSearchCriteria(
      entityId: json[r'entityId'] as String?,
      name: json[r'name'] as String?,
      userId: json[r'userId'] as String?,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var entityId = this.entityId;
    var name = this.name;
    var userId = this.userId;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (entityId != null) {
      json[r'entityId'] = entityId;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  EntityGrantSearchCriteria copyWith(
      {String? entityId,
      String? name,
      String? userId,
      int? numberOfResults,
      String? orderBy,
      int? startRow}) {
    return EntityGrantSearchCriteria(
      entityId: entityId ?? this.entityId,
      name: name ?? this.name,
      userId: userId ?? this.userId,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Search request for entity grants.
class EntityGrantSearchRequest {
  final EntityGrantSearchCriteria? search;

  EntityGrantSearchRequest({this.search});

  factory EntityGrantSearchRequest.fromJson(Map<String, Object?> json) {
    return EntityGrantSearchRequest(
      search: json[r'search'] != null
          ? EntityGrantSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  EntityGrantSearchRequest copyWith({EntityGrantSearchCriteria? search}) {
    return EntityGrantSearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Search request for entity grants.
class EntityGrantSearchResponse {
  final List<EntityGrant> grants;
  final int? total;

  EntityGrantSearchResponse({List<EntityGrant>? grants, this.total})
      : grants = grants ?? [];

  factory EntityGrantSearchResponse.fromJson(Map<String, Object?> json) {
    return EntityGrantSearchResponse(
      grants: (json[r'grants'] as List<Object?>?)
              ?.map((i) =>
                  EntityGrant.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var grants = this.grants;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'grants'] = grants.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  EntityGrantSearchResponse copyWith({List<EntityGrant>? grants, int? total}) {
    return EntityGrantSearchResponse(
      grants: grants ?? this.grants,
      total: total ?? this.total,
    );
  }
}

/// JWT Configuration for entities.
class EntityJWTConfiguration {
  final String? accessTokenKeyId;
  final int? timeToLiveInSeconds;
  final bool enabled;

  EntityJWTConfiguration(
      {this.accessTokenKeyId, this.timeToLiveInSeconds, bool? enabled})
      : enabled = enabled ?? false;

  factory EntityJWTConfiguration.fromJson(Map<String, Object?> json) {
    return EntityJWTConfiguration(
      accessTokenKeyId: json[r'accessTokenKeyId'] as String?,
      timeToLiveInSeconds: (json[r'timeToLiveInSeconds'] as num?)?.toInt(),
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var accessTokenKeyId = this.accessTokenKeyId;
    var timeToLiveInSeconds = this.timeToLiveInSeconds;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (accessTokenKeyId != null) {
      json[r'accessTokenKeyId'] = accessTokenKeyId;
    }
    if (timeToLiveInSeconds != null) {
      json[r'timeToLiveInSeconds'] = timeToLiveInSeconds;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  EntityJWTConfiguration copyWith(
      {String? accessTokenKeyId, int? timeToLiveInSeconds, bool? enabled}) {
    return EntityJWTConfiguration(
      accessTokenKeyId: accessTokenKeyId ?? this.accessTokenKeyId,
      timeToLiveInSeconds: timeToLiveInSeconds ?? this.timeToLiveInSeconds,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Entity API request object.
class EntityRequest {
  final Entity? entity;

  EntityRequest({this.entity});

  factory EntityRequest.fromJson(Map<String, Object?> json) {
    return EntityRequest(
      entity: json[r'entity'] != null
          ? Entity.fromJson(json[r'entity']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var entity = this.entity;

    final json = <String, Object?>{};
    if (entity != null) {
      json[r'entity'] = entity.toJson();
    }
    return json;
  }

  EntityRequest copyWith({Entity? entity}) {
    return EntityRequest(
      entity: entity ?? this.entity,
    );
  }
}

/// Entity API response object.
class EntityResponse {
  final Entity? entity;

  EntityResponse({this.entity});

  factory EntityResponse.fromJson(Map<String, Object?> json) {
    return EntityResponse(
      entity: json[r'entity'] != null
          ? Entity.fromJson(json[r'entity']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var entity = this.entity;

    final json = <String, Object?>{};
    if (entity != null) {
      json[r'entity'] = entity.toJson();
    }
    return json;
  }

  EntityResponse copyWith({Entity? entity}) {
    return EntityResponse(
      entity: entity ?? this.entity,
    );
  }
}

/// This class is the entity query. It provides a build pattern as well as
/// public fields for use on forms and in actions.
class EntitySearchCriteria {
  final bool accurateTotal;
  final List<String> ids;
  final String? nextResults;
  final String? query;
  final String? queryString;
  final List<SortField> sortFields;

  EntitySearchCriteria(
      {bool? accurateTotal,
      List<String>? ids,
      this.nextResults,
      this.query,
      this.queryString,
      List<SortField>? sortFields})
      : accurateTotal = accurateTotal ?? false,
        ids = ids ?? [],
        sortFields = sortFields ?? [];

  factory EntitySearchCriteria.fromJson(Map<String, Object?> json) {
    return EntitySearchCriteria(
      accurateTotal: json[r'accurateTotal'] as bool? ?? false,
      ids: (json[r'ids'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      nextResults: json[r'nextResults'] as String?,
      query: json[r'query'] as String?,
      queryString: json[r'queryString'] as String?,
      sortFields: (json[r'sortFields'] as List<Object?>?)
              ?.map((i) =>
                  SortField.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var accurateTotal = this.accurateTotal;
    var ids = this.ids;
    var nextResults = this.nextResults;
    var query = this.query;
    var queryString = this.queryString;
    var sortFields = this.sortFields;

    final json = <String, Object?>{};
    json[r'accurateTotal'] = accurateTotal;
    json[r'ids'] = ids;
    if (nextResults != null) {
      json[r'nextResults'] = nextResults;
    }
    if (query != null) {
      json[r'query'] = query;
    }
    if (queryString != null) {
      json[r'queryString'] = queryString;
    }
    json[r'sortFields'] = sortFields.map((i) => i.toJson()).toList();
    return json;
  }

  EntitySearchCriteria copyWith(
      {bool? accurateTotal,
      List<String>? ids,
      String? nextResults,
      String? query,
      String? queryString,
      List<SortField>? sortFields}) {
    return EntitySearchCriteria(
      accurateTotal: accurateTotal ?? this.accurateTotal,
      ids: ids ?? this.ids,
      nextResults: nextResults ?? this.nextResults,
      query: query ?? this.query,
      queryString: queryString ?? this.queryString,
      sortFields: sortFields ?? this.sortFields,
    );
  }
}

/// Search request for entities
class EntitySearchRequest {
  final EntitySearchCriteria? search;

  EntitySearchRequest({this.search});

  factory EntitySearchRequest.fromJson(Map<String, Object?> json) {
    return EntitySearchRequest(
      search: json[r'search'] != null
          ? EntitySearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  EntitySearchRequest copyWith({EntitySearchCriteria? search}) {
    return EntitySearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Search request for entities
class EntitySearchResponse {
  final List<Entity> entities;
  final String? nextResults;
  final int? total;

  EntitySearchResponse({List<Entity>? entities, this.nextResults, this.total})
      : entities = entities ?? [];

  factory EntitySearchResponse.fromJson(Map<String, Object?> json) {
    return EntitySearchResponse(
      entities: (json[r'entities'] as List<Object?>?)
              ?.map((i) =>
                  Entity.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      nextResults: json[r'nextResults'] as String?,
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var entities = this.entities;
    var nextResults = this.nextResults;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'entities'] = entities.map((i) => i.toJson()).toList();
    if (nextResults != null) {
      json[r'nextResults'] = nextResults;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  EntitySearchResponse copyWith(
      {List<Entity>? entities, String? nextResults, int? total}) {
    return EntitySearchResponse(
      entities: entities ?? this.entities,
      nextResults: nextResults ?? this.nextResults,
      total: total ?? this.total,
    );
  }
}

/// Models an entity type that has a specific set of permissions. These are
/// global objects and can be used across tenants.
class EntityType {
  final Map<String, dynamic>? data;
  final String? id;
  final ZonedDateTime? insertInstant;
  final EntityJWTConfiguration? jwtConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final List<EntityTypePermission> permissions;

  EntityType(
      {this.data,
      this.id,
      this.insertInstant,
      this.jwtConfiguration,
      this.lastUpdateInstant,
      this.name,
      List<EntityTypePermission>? permissions})
      : permissions = permissions ?? [];

  factory EntityType.fromJson(Map<String, Object?> json) {
    return EntityType(
      data: json[r'data'] as Map<String, Object?>?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      jwtConfiguration: json[r'jwtConfiguration'] != null
          ? EntityJWTConfiguration.fromJson(
              json[r'jwtConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      permissions: (json[r'permissions'] as List<Object?>?)
              ?.map((i) => EntityTypePermission.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var jwtConfiguration = this.jwtConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var permissions = this.permissions;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (jwtConfiguration != null) {
      json[r'jwtConfiguration'] = jwtConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'permissions'] = permissions.map((i) => i.toJson()).toList();
    return json;
  }

  EntityType copyWith(
      {Map<String, dynamic>? data,
      String? id,
      ZonedDateTime? insertInstant,
      EntityJWTConfiguration? jwtConfiguration,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      List<EntityTypePermission>? permissions}) {
    return EntityType(
      data: data ?? this.data,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      jwtConfiguration: jwtConfiguration ?? this.jwtConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      permissions: permissions ?? this.permissions,
    );
  }
}

/// Models a specific entity type permission. This permission can be granted to
/// users or other entities.
class EntityTypePermission {
  final Map<String, dynamic>? data;
  final String? description;
  final String? id;
  final ZonedDateTime? insertInstant;
  final bool isDefault;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;

  EntityTypePermission(
      {this.data,
      this.description,
      this.id,
      this.insertInstant,
      bool? isDefault,
      this.lastUpdateInstant,
      this.name})
      : isDefault = isDefault ?? false;

  factory EntityTypePermission.fromJson(Map<String, Object?> json) {
    return EntityTypePermission(
      data: json[r'data'] as Map<String, Object?>?,
      description: json[r'description'] as String?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      isDefault: json[r'isDefault'] as bool? ?? false,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var description = this.description;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var isDefault = this.isDefault;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    json[r'isDefault'] = isDefault;
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  EntityTypePermission copyWith(
      {Map<String, dynamic>? data,
      String? description,
      String? id,
      ZonedDateTime? insertInstant,
      bool? isDefault,
      ZonedDateTime? lastUpdateInstant,
      String? name}) {
    return EntityTypePermission(
      data: data ?? this.data,
      description: description ?? this.description,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      isDefault: isDefault ?? this.isDefault,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
    );
  }
}

/// Entity Type API request object.
class EntityTypeRequest {
  final EntityType? entityType;
  final EntityTypePermission? permission;

  EntityTypeRequest({this.entityType, this.permission});

  factory EntityTypeRequest.fromJson(Map<String, Object?> json) {
    return EntityTypeRequest(
      entityType: json[r'entityType'] != null
          ? EntityType.fromJson(json[r'entityType']! as Map<String, Object?>)
          : null,
      permission: json[r'permission'] != null
          ? EntityTypePermission.fromJson(
              json[r'permission']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var entityType = this.entityType;
    var permission = this.permission;

    final json = <String, Object?>{};
    if (entityType != null) {
      json[r'entityType'] = entityType.toJson();
    }
    if (permission != null) {
      json[r'permission'] = permission.toJson();
    }
    return json;
  }

  EntityTypeRequest copyWith(
      {EntityType? entityType, EntityTypePermission? permission}) {
    return EntityTypeRequest(
      entityType: entityType ?? this.entityType,
      permission: permission ?? this.permission,
    );
  }
}

/// Entity Type API response object.
class EntityTypeResponse {
  final EntityType? entityType;
  final List<EntityType> entityTypes;
  final EntityTypePermission? permission;

  EntityTypeResponse(
      {this.entityType, List<EntityType>? entityTypes, this.permission})
      : entityTypes = entityTypes ?? [];

  factory EntityTypeResponse.fromJson(Map<String, Object?> json) {
    return EntityTypeResponse(
      entityType: json[r'entityType'] != null
          ? EntityType.fromJson(json[r'entityType']! as Map<String, Object?>)
          : null,
      entityTypes: (json[r'entityTypes'] as List<Object?>?)
              ?.map((i) =>
                  EntityType.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      permission: json[r'permission'] != null
          ? EntityTypePermission.fromJson(
              json[r'permission']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var entityType = this.entityType;
    var entityTypes = this.entityTypes;
    var permission = this.permission;

    final json = <String, Object?>{};
    if (entityType != null) {
      json[r'entityType'] = entityType.toJson();
    }
    json[r'entityTypes'] = entityTypes.map((i) => i.toJson()).toList();
    if (permission != null) {
      json[r'permission'] = permission.toJson();
    }
    return json;
  }

  EntityTypeResponse copyWith(
      {EntityType? entityType,
      List<EntityType>? entityTypes,
      EntityTypePermission? permission}) {
    return EntityTypeResponse(
      entityType: entityType ?? this.entityType,
      entityTypes: entityTypes ?? this.entityTypes,
      permission: permission ?? this.permission,
    );
  }
}

/// Search criteria for entity types.
class EntityTypeSearchCriteria {
  final String? name;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  EntityTypeSearchCriteria(
      {this.name, this.numberOfResults, this.orderBy, this.startRow});

  factory EntityTypeSearchCriteria.fromJson(Map<String, Object?> json) {
    return EntityTypeSearchCriteria(
      name: json[r'name'] as String?,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  EntityTypeSearchCriteria copyWith(
      {String? name, int? numberOfResults, String? orderBy, int? startRow}) {
    return EntityTypeSearchCriteria(
      name: name ?? this.name,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Search request for entity types.
class EntityTypeSearchRequest {
  final EntityTypeSearchCriteria? search;

  EntityTypeSearchRequest({this.search});

  factory EntityTypeSearchRequest.fromJson(Map<String, Object?> json) {
    return EntityTypeSearchRequest(
      search: json[r'search'] != null
          ? EntityTypeSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  EntityTypeSearchRequest copyWith({EntityTypeSearchCriteria? search}) {
    return EntityTypeSearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Search response for entity types.
class EntityTypeSearchResponse {
  final List<EntityType> entityTypes;
  final int? total;

  EntityTypeSearchResponse({List<EntityType>? entityTypes, this.total})
      : entityTypes = entityTypes ?? [];

  factory EntityTypeSearchResponse.fromJson(Map<String, Object?> json) {
    return EntityTypeSearchResponse(
      entityTypes: (json[r'entityTypes'] as List<Object?>?)
              ?.map((i) =>
                  EntityType.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var entityTypes = this.entityTypes;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'entityTypes'] = entityTypes.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  EntityTypeSearchResponse copyWith(
      {List<EntityType>? entityTypes, int? total}) {
    return EntityTypeSearchResponse(
      entityTypes: entityTypes ?? this.entityTypes,
      total: total ?? this.total,
    );
  }
}

class EpicGamesApplicationConfiguration {
  final String? buttonText;
  final String? clientId;
  final String? clientSecret;
  final String? scope;
  final Map<String, dynamic>? data;
  final bool createRegistration;

  EpicGamesApplicationConfiguration(
      {this.buttonText,
      this.clientId,
      this.clientSecret,
      this.scope,
      this.data,
      bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory EpicGamesApplicationConfiguration.fromJson(
      Map<String, Object?> json) {
    return EpicGamesApplicationConfiguration(
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      scope: json[r'scope'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var scope = this.scope;
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  EpicGamesApplicationConfiguration copyWith(
      {String? buttonText,
      String? clientId,
      String? clientSecret,
      String? scope,
      Map<String, dynamic>? data,
      bool? createRegistration}) {
    return EpicGamesApplicationConfiguration(
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      scope: scope ?? this.scope,
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

/// Epic gaming login provider.
class EpicGamesIdentityProvider {
  final String? buttonText;
  final String? clientId;
  final String? clientSecret;
  final String? scope;
  final Map<String, dynamic>? data;
  final Map<String, dynamic>? applicationConfiguration;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ProviderLambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final IdentityProviderLinkingStrategy? linkingStrategy;
  final String? name;
  final Map<String, dynamic>? tenantConfiguration;
  final IdentityProviderType? type;

  EpicGamesIdentityProvider(
      {this.buttonText,
      this.clientId,
      this.clientSecret,
      this.scope,
      this.data,
      this.applicationConfiguration,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.linkingStrategy,
      this.name,
      this.tenantConfiguration,
      this.type})
      : debug = debug ?? false;

  factory EpicGamesIdentityProvider.fromJson(Map<String, Object?> json) {
    return EpicGamesIdentityProvider(
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      scope: json[r'scope'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      applicationConfiguration:
          json[r'applicationConfiguration'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? ProviderLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      linkingStrategy: json[r'linkingStrategy'] != null
          ? IdentityProviderLinkingStrategy.fromValue(
              json[r'linkingStrategy']! as String)
          : null,
      name: json[r'name'] as String?,
      tenantConfiguration:
          json[r'tenantConfiguration'] as Map<String, Object?>?,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var scope = this.scope;
    var data = this.data;
    var applicationConfiguration = this.applicationConfiguration;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var linkingStrategy = this.linkingStrategy;
    var name = this.name;
    var tenantConfiguration = this.tenantConfiguration;
    var type = this.type;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (applicationConfiguration != null) {
      json[r'applicationConfiguration'] = applicationConfiguration;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (linkingStrategy != null) {
      json[r'linkingStrategy'] = linkingStrategy.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (tenantConfiguration != null) {
      json[r'tenantConfiguration'] = tenantConfiguration;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  EpicGamesIdentityProvider copyWith(
      {String? buttonText,
      String? clientId,
      String? clientSecret,
      String? scope,
      Map<String, dynamic>? data,
      Map<String, dynamic>? applicationConfiguration,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ProviderLambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      IdentityProviderLinkingStrategy? linkingStrategy,
      String? name,
      Map<String, dynamic>? tenantConfiguration,
      IdentityProviderType? type}) {
    return EpicGamesIdentityProvider(
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      scope: scope ?? this.scope,
      data: data ?? this.data,
      applicationConfiguration:
          applicationConfiguration ?? this.applicationConfiguration,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      linkingStrategy: linkingStrategy ?? this.linkingStrategy,
      name: name ?? this.name,
      tenantConfiguration: tenantConfiguration ?? this.tenantConfiguration,
      type: type ?? this.type,
    );
  }
}

/// Defines an error.
class Error {
  final String? code;
  final Map<String, dynamic>? data;
  final String? message;

  Error({this.code, this.data, this.message});

  factory Error.fromJson(Map<String, Object?> json) {
    return Error(
      code: json[r'code'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      message: json[r'message'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var code = this.code;
    var data = this.data;
    var message = this.message;

    final json = <String, Object?>{};
    if (code != null) {
      json[r'code'] = code;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (message != null) {
      json[r'message'] = message;
    }
    return json;
  }

  Error copyWith({String? code, Map<String, dynamic>? data, String? message}) {
    return Error(
      code: code ?? this.code,
      data: data ?? this.data,
      message: message ?? this.message,
    );
  }
}

/// Standard error domain object that can also be used as the response from an
/// API call.
class Errors {
  final List<Error> fieldErrors;
  final List<Error> generalErrors;

  Errors({List<Error>? fieldErrors, List<Error>? generalErrors})
      : fieldErrors = fieldErrors ?? [],
        generalErrors = generalErrors ?? [];

  factory Errors.fromJson(Map<String, Object?> json) {
    return Errors(
      fieldErrors: (json[r'fieldErrors'] as List<Object?>?)
              ?.map(
                  (i) => Error.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      generalErrors: (json[r'generalErrors'] as List<Object?>?)
              ?.map(
                  (i) => Error.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var fieldErrors = this.fieldErrors;
    var generalErrors = this.generalErrors;

    final json = <String, Object?>{};
    json[r'fieldErrors'] = fieldErrors.map((i) => i.toJson()).toList();
    json[r'generalErrors'] = generalErrors.map((i) => i.toJson()).toList();
    return json;
  }

  Errors copyWith({List<Error>? fieldErrors, List<Error>? generalErrors}) {
    return Errors(
      fieldErrors: fieldErrors ?? this.fieldErrors,
      generalErrors: generalErrors ?? this.generalErrors,
    );
  }
}

class EventConfiguration {
  final Map<String, dynamic>? events;

  EventConfiguration({this.events});

  factory EventConfiguration.fromJson(Map<String, Object?> json) {
    return EventConfiguration(
      events: json[r'events'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var events = this.events;

    final json = <String, Object?>{};
    if (events != null) {
      json[r'events'] = events;
    }
    return json;
  }

  EventConfiguration copyWith({Map<String, dynamic>? events}) {
    return EventConfiguration(
      events: events ?? this.events,
    );
  }
}

class EventConfigurationData {
  final TransactionType? transactionType;
  final bool enabled;

  EventConfigurationData({this.transactionType, bool? enabled})
      : enabled = enabled ?? false;

  factory EventConfigurationData.fromJson(Map<String, Object?> json) {
    return EventConfigurationData(
      transactionType: json[r'transactionType'] != null
          ? TransactionType.fromValue(json[r'transactionType']! as String)
          : null,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var transactionType = this.transactionType;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (transactionType != null) {
      json[r'transactionType'] = transactionType.value;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  EventConfigurationData copyWith(
      {TransactionType? transactionType, bool? enabled}) {
    return EventConfigurationData(
      transactionType: transactionType ?? this.transactionType,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Information about a user event (login, register, etc) that helps identify
/// the source of the event (location, device type, OS, etc).
class EventInfo {
  final Map<String, dynamic>? data;
  final String? deviceDescription;
  final String? deviceName;
  final String? deviceType;
  final String? ipAddress;
  final Location? location;
  final String? os;
  final String? userAgent;

  EventInfo(
      {this.data,
      this.deviceDescription,
      this.deviceName,
      this.deviceType,
      this.ipAddress,
      this.location,
      this.os,
      this.userAgent});

  factory EventInfo.fromJson(Map<String, Object?> json) {
    return EventInfo(
      data: json[r'data'] as Map<String, Object?>?,
      deviceDescription: json[r'deviceDescription'] as String?,
      deviceName: json[r'deviceName'] as String?,
      deviceType: json[r'deviceType'] as String?,
      ipAddress: json[r'ipAddress'] as String?,
      location: json[r'location'] != null
          ? Location.fromJson(json[r'location']! as Map<String, Object?>)
          : null,
      os: json[r'os'] as String?,
      userAgent: json[r'userAgent'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var deviceDescription = this.deviceDescription;
    var deviceName = this.deviceName;
    var deviceType = this.deviceType;
    var ipAddress = this.ipAddress;
    var location = this.location;
    var os = this.os;
    var userAgent = this.userAgent;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (deviceDescription != null) {
      json[r'deviceDescription'] = deviceDescription;
    }
    if (deviceName != null) {
      json[r'deviceName'] = deviceName;
    }
    if (deviceType != null) {
      json[r'deviceType'] = deviceType;
    }
    if (ipAddress != null) {
      json[r'ipAddress'] = ipAddress;
    }
    if (location != null) {
      json[r'location'] = location.toJson();
    }
    if (os != null) {
      json[r'os'] = os;
    }
    if (userAgent != null) {
      json[r'userAgent'] = userAgent;
    }
    return json;
  }

  EventInfo copyWith(
      {Map<String, dynamic>? data,
      String? deviceDescription,
      String? deviceName,
      String? deviceType,
      String? ipAddress,
      Location? location,
      String? os,
      String? userAgent}) {
    return EventInfo(
      data: data ?? this.data,
      deviceDescription: deviceDescription ?? this.deviceDescription,
      deviceName: deviceName ?? this.deviceName,
      deviceType: deviceType ?? this.deviceType,
      ipAddress: ipAddress ?? this.ipAddress,
      location: location ?? this.location,
      os: os ?? this.os,
      userAgent: userAgent ?? this.userAgent,
    );
  }
}

/// Event log used internally by FusionAuth to help developers debug hooks,
/// Webhooks, email templates, etc.
class EventLog {
  final int? id;
  final ZonedDateTime? insertInstant;
  final String? message;
  final EventLogType? type;

  EventLog({this.id, this.insertInstant, this.message, this.type});

  factory EventLog.fromJson(Map<String, Object?> json) {
    return EventLog(
      id: (json[r'id'] as num?)?.toInt(),
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      message: json[r'message'] as String?,
      type: json[r'type'] != null
          ? EventLogType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var insertInstant = this.insertInstant;
    var message = this.message;
    var type = this.type;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (message != null) {
      json[r'message'] = message;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  EventLog copyWith(
      {int? id,
      ZonedDateTime? insertInstant,
      String? message,
      EventLogType? type}) {
    return EventLog(
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      message: message ?? this.message,
      type: type ?? this.type,
    );
  }
}

class EventLogConfiguration {
  final int? numberToRetain;

  EventLogConfiguration({this.numberToRetain});

  factory EventLogConfiguration.fromJson(Map<String, Object?> json) {
    return EventLogConfiguration(
      numberToRetain: (json[r'numberToRetain'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var numberToRetain = this.numberToRetain;

    final json = <String, Object?>{};
    if (numberToRetain != null) {
      json[r'numberToRetain'] = numberToRetain;
    }
    return json;
  }

  EventLogConfiguration copyWith({int? numberToRetain}) {
    return EventLogConfiguration(
      numberToRetain: numberToRetain ?? this.numberToRetain,
    );
  }
}

/// An Event "event" to indicate an event log was created.
class EventLogCreateEvent {
  final EventLog? eventLog;
  final ZonedDateTime? createInstant;
  final String? id;
  final EventInfo? info;
  final String? tenantId;
  final EventType? type;

  EventLogCreateEvent(
      {this.eventLog,
      this.createInstant,
      this.id,
      this.info,
      this.tenantId,
      this.type});

  factory EventLogCreateEvent.fromJson(Map<String, Object?> json) {
    return EventLogCreateEvent(
      eventLog: json[r'eventLog'] != null
          ? EventLog.fromJson(json[r'eventLog']! as Map<String, Object?>)
          : null,
      createInstant:
          (json[r'createInstant'] as num?)?.toInt() as ZonedDateTime?,
      id: json[r'id'] as String?,
      info: json[r'info'] != null
          ? EventInfo.fromJson(json[r'info']! as Map<String, Object?>)
          : null,
      tenantId: json[r'tenantId'] as String?,
      type: json[r'type'] != null
          ? EventType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var eventLog = this.eventLog;
    var createInstant = this.createInstant;
    var id = this.id;
    var info = this.info;
    var tenantId = this.tenantId;
    var type = this.type;

    final json = <String, Object?>{};
    if (eventLog != null) {
      json[r'eventLog'] = eventLog.toJson();
    }
    if (createInstant != null) {
      json[r'createInstant'] = createInstant.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (info != null) {
      json[r'info'] = info.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  EventLogCreateEvent copyWith(
      {EventLog? eventLog,
      ZonedDateTime? createInstant,
      String? id,
      EventInfo? info,
      String? tenantId,
      EventType? type}) {
    return EventLogCreateEvent(
      eventLog: eventLog ?? this.eventLog,
      createInstant: createInstant ?? this.createInstant,
      id: id ?? this.id,
      info: info ?? this.info,
      tenantId: tenantId ?? this.tenantId,
      type: type ?? this.type,
    );
  }
}

/// Event log response.
class EventLogResponse {
  final EventLog? eventLog;

  EventLogResponse({this.eventLog});

  factory EventLogResponse.fromJson(Map<String, Object?> json) {
    return EventLogResponse(
      eventLog: json[r'eventLog'] != null
          ? EventLog.fromJson(json[r'eventLog']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var eventLog = this.eventLog;

    final json = <String, Object?>{};
    if (eventLog != null) {
      json[r'eventLog'] = eventLog.toJson();
    }
    return json;
  }

  EventLogResponse copyWith({EventLog? eventLog}) {
    return EventLogResponse(
      eventLog: eventLog ?? this.eventLog,
    );
  }
}

/// Search criteria for the event log.
class EventLogSearchCriteria {
  final ZonedDateTime? end;
  final String? message;
  final ZonedDateTime? start;
  final EventLogType? type;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  EventLogSearchCriteria(
      {this.end,
      this.message,
      this.start,
      this.type,
      this.numberOfResults,
      this.orderBy,
      this.startRow});

  factory EventLogSearchCriteria.fromJson(Map<String, Object?> json) {
    return EventLogSearchCriteria(
      end: (json[r'end'] as num?)?.toInt() as ZonedDateTime?,
      message: json[r'message'] as String?,
      start: (json[r'start'] as num?)?.toInt() as ZonedDateTime?,
      type: json[r'type'] != null
          ? EventLogType.fromValue(json[r'type']! as String)
          : null,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var end = this.end;
    var message = this.message;
    var start = this.start;
    var type = this.type;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (end != null) {
      json[r'end'] = end.toJson();
    }
    if (message != null) {
      json[r'message'] = message;
    }
    if (start != null) {
      json[r'start'] = start.toJson();
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  EventLogSearchCriteria copyWith(
      {ZonedDateTime? end,
      String? message,
      ZonedDateTime? start,
      EventLogType? type,
      int? numberOfResults,
      String? orderBy,
      int? startRow}) {
    return EventLogSearchCriteria(
      end: end ?? this.end,
      message: message ?? this.message,
      start: start ?? this.start,
      type: type ?? this.type,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

class EventLogSearchRequest {
  final EventLogSearchCriteria? search;

  EventLogSearchRequest({this.search});

  factory EventLogSearchRequest.fromJson(Map<String, Object?> json) {
    return EventLogSearchRequest(
      search: json[r'search'] != null
          ? EventLogSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  EventLogSearchRequest copyWith({EventLogSearchCriteria? search}) {
    return EventLogSearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Event log response.
class EventLogSearchResponse {
  final List<EventLog> eventLogs;
  final int? total;

  EventLogSearchResponse({List<EventLog>? eventLogs, this.total})
      : eventLogs = eventLogs ?? [];

  factory EventLogSearchResponse.fromJson(Map<String, Object?> json) {
    return EventLogSearchResponse(
      eventLogs: (json[r'eventLogs'] as List<Object?>?)
              ?.map((i) =>
                  EventLog.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var eventLogs = this.eventLogs;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'eventLogs'] = eventLogs.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  EventLogSearchResponse copyWith({List<EventLog>? eventLogs, int? total}) {
    return EventLogSearchResponse(
      eventLogs: eventLogs ?? this.eventLogs,
      total: total ?? this.total,
    );
  }
}

/// Container for the event information. This is the JSON that is sent from
/// FusionAuth to webhooks.
class EventRequest {
  final BaseEvent? event;

  EventRequest({this.event});

  factory EventRequest.fromJson(Map<String, Object?> json) {
    return EventRequest(
      event: json[r'event'] != null
          ? BaseEvent.fromJson(json[r'event']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var event = this.event;

    final json = <String, Object?>{};
    if (event != null) {
      json[r'event'] = event.toJson();
    }
    return json;
  }

  EventRequest copyWith({BaseEvent? event}) {
    return EventRequest(
      event: event ?? this.event,
    );
  }
}

/// An expandable API request.
class ExpandableRequest {
  final List<String> expand;

  ExpandableRequest({List<String>? expand}) : expand = expand ?? [];

  factory ExpandableRequest.fromJson(Map<String, Object?> json) {
    return ExpandableRequest(
      expand: (json[r'expand'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;

    final json = <String, Object?>{};
    json[r'expand'] = expand;
    return json;
  }

  ExpandableRequest copyWith({List<String>? expand}) {
    return ExpandableRequest(
      expand: expand ?? this.expand,
    );
  }
}

/// An expandable API response.
class ExpandableResponse {
  final List<String> expandable;

  ExpandableResponse({List<String>? expandable})
      : expandable = expandable ?? [];

  factory ExpandableResponse.fromJson(Map<String, Object?> json) {
    return ExpandableResponse(
      expandable: (json[r'expandable'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var expandable = this.expandable;

    final json = <String, Object?>{};
    json[r'expandable'] = expandable;
    return json;
  }

  ExpandableResponse copyWith({List<String>? expandable}) {
    return ExpandableResponse(
      expandable: expandable ?? this.expandable,
    );
  }
}

class ExternalIdentifierConfiguration {
  final int? authorizationGrantIdTimeToLiveInSeconds;
  final SecureGeneratorConfiguration? changePasswordIdGenerator;
  final int? changePasswordIdTimeToLiveInSeconds;
  final int? deviceCodeTimeToLiveInSeconds;
  final SecureGeneratorConfiguration? deviceUserCodeIdGenerator;
  final SecureGeneratorConfiguration? emailVerificationIdGenerator;
  final int? emailVerificationIdTimeToLiveInSeconds;
  final SecureGeneratorConfiguration? emailVerificationOneTimeCodeGenerator;
  final int? externalAuthenticationIdTimeToLiveInSeconds;
  final int? loginIntentTimeToLiveInSeconds;
  final int? oneTimePasswordTimeToLiveInSeconds;
  final SecureGeneratorConfiguration? passwordlessLoginGenerator;
  final int? passwordlessLoginTimeToLiveInSeconds;
  final int? pendingAccountLinkTimeToLiveInSeconds;
  final SecureGeneratorConfiguration? registrationVerificationIdGenerator;
  final int? registrationVerificationIdTimeToLiveInSeconds;
  final SecureGeneratorConfiguration?
      registrationVerificationOneTimeCodeGenerator;
  final int? rememberoAuthScopeConsentChoiceTimeToLiveInSeconds;
  final int? samlv2AuthnRequestIdTimeToLiveInSeconds;
  final SecureGeneratorConfiguration? setupPasswordIdGenerator;
  final int? setupPasswordIdTimeToLiveInSeconds;
  final int? trustTokenTimeToLiveInSeconds;
  final int? twoFactorIdTimeToLiveInSeconds;
  final SecureGeneratorConfiguration? twoFactorOneTimeCodeIdGenerator;
  final int? twoFactorOneTimeCodeIdTimeToLiveInSeconds;
  final int? twoFactorTrustIdTimeToLiveInSeconds;
  final int? webAuthnAuthenticationChallengeTimeToLiveInSeconds;
  final int? webAuthnRegistrationChallengeTimeToLiveInSeconds;

  ExternalIdentifierConfiguration(
      {this.authorizationGrantIdTimeToLiveInSeconds,
      this.changePasswordIdGenerator,
      this.changePasswordIdTimeToLiveInSeconds,
      this.deviceCodeTimeToLiveInSeconds,
      this.deviceUserCodeIdGenerator,
      this.emailVerificationIdGenerator,
      this.emailVerificationIdTimeToLiveInSeconds,
      this.emailVerificationOneTimeCodeGenerator,
      this.externalAuthenticationIdTimeToLiveInSeconds,
      this.loginIntentTimeToLiveInSeconds,
      this.oneTimePasswordTimeToLiveInSeconds,
      this.passwordlessLoginGenerator,
      this.passwordlessLoginTimeToLiveInSeconds,
      this.pendingAccountLinkTimeToLiveInSeconds,
      this.registrationVerificationIdGenerator,
      this.registrationVerificationIdTimeToLiveInSeconds,
      this.registrationVerificationOneTimeCodeGenerator,
      this.rememberoAuthScopeConsentChoiceTimeToLiveInSeconds,
      this.samlv2AuthnRequestIdTimeToLiveInSeconds,
      this.setupPasswordIdGenerator,
      this.setupPasswordIdTimeToLiveInSeconds,
      this.trustTokenTimeToLiveInSeconds,
      this.twoFactorIdTimeToLiveInSeconds,
      this.twoFactorOneTimeCodeIdGenerator,
      this.twoFactorOneTimeCodeIdTimeToLiveInSeconds,
      this.twoFactorTrustIdTimeToLiveInSeconds,
      this.webAuthnAuthenticationChallengeTimeToLiveInSeconds,
      this.webAuthnRegistrationChallengeTimeToLiveInSeconds});

  factory ExternalIdentifierConfiguration.fromJson(Map<String, Object?> json) {
    return ExternalIdentifierConfiguration(
      authorizationGrantIdTimeToLiveInSeconds:
          (json[r'authorizationGrantIdTimeToLiveInSeconds'] as num?)?.toInt(),
      changePasswordIdGenerator: json[r'changePasswordIdGenerator'] != null
          ? SecureGeneratorConfiguration.fromJson(
              json[r'changePasswordIdGenerator']! as Map<String, Object?>)
          : null,
      changePasswordIdTimeToLiveInSeconds:
          (json[r'changePasswordIdTimeToLiveInSeconds'] as num?)?.toInt(),
      deviceCodeTimeToLiveInSeconds:
          (json[r'deviceCodeTimeToLiveInSeconds'] as num?)?.toInt(),
      deviceUserCodeIdGenerator: json[r'deviceUserCodeIdGenerator'] != null
          ? SecureGeneratorConfiguration.fromJson(
              json[r'deviceUserCodeIdGenerator']! as Map<String, Object?>)
          : null,
      emailVerificationIdGenerator: json[r'emailVerificationIdGenerator'] !=
              null
          ? SecureGeneratorConfiguration.fromJson(
              json[r'emailVerificationIdGenerator']! as Map<String, Object?>)
          : null,
      emailVerificationIdTimeToLiveInSeconds:
          (json[r'emailVerificationIdTimeToLiveInSeconds'] as num?)?.toInt(),
      emailVerificationOneTimeCodeGenerator:
          json[r'emailVerificationOneTimeCodeGenerator'] != null
              ? SecureGeneratorConfiguration.fromJson(
                  json[r'emailVerificationOneTimeCodeGenerator']!
                      as Map<String, Object?>)
              : null,
      externalAuthenticationIdTimeToLiveInSeconds:
          (json[r'externalAuthenticationIdTimeToLiveInSeconds'] as num?)
              ?.toInt(),
      loginIntentTimeToLiveInSeconds:
          (json[r'loginIntentTimeToLiveInSeconds'] as num?)?.toInt(),
      oneTimePasswordTimeToLiveInSeconds:
          (json[r'oneTimePasswordTimeToLiveInSeconds'] as num?)?.toInt(),
      passwordlessLoginGenerator: json[r'passwordlessLoginGenerator'] != null
          ? SecureGeneratorConfiguration.fromJson(
              json[r'passwordlessLoginGenerator']! as Map<String, Object?>)
          : null,
      passwordlessLoginTimeToLiveInSeconds:
          (json[r'passwordlessLoginTimeToLiveInSeconds'] as num?)?.toInt(),
      pendingAccountLinkTimeToLiveInSeconds:
          (json[r'pendingAccountLinkTimeToLiveInSeconds'] as num?)?.toInt(),
      registrationVerificationIdGenerator:
          json[r'registrationVerificationIdGenerator'] != null
              ? SecureGeneratorConfiguration.fromJson(
                  json[r'registrationVerificationIdGenerator']!
                      as Map<String, Object?>)
              : null,
      registrationVerificationIdTimeToLiveInSeconds:
          (json[r'registrationVerificationIdTimeToLiveInSeconds'] as num?)
              ?.toInt(),
      registrationVerificationOneTimeCodeGenerator:
          json[r'registrationVerificationOneTimeCodeGenerator'] != null
              ? SecureGeneratorConfiguration.fromJson(
                  json[r'registrationVerificationOneTimeCodeGenerator']!
                      as Map<String, Object?>)
              : null,
      rememberoAuthScopeConsentChoiceTimeToLiveInSeconds:
          (json[r'rememberOAuthScopeConsentChoiceTimeToLiveInSeconds'] as num?)
              ?.toInt(),
      samlv2AuthnRequestIdTimeToLiveInSeconds:
          (json[r'samlv2AuthNRequestIdTimeToLiveInSeconds'] as num?)?.toInt(),
      setupPasswordIdGenerator: json[r'setupPasswordIdGenerator'] != null
          ? SecureGeneratorConfiguration.fromJson(
              json[r'setupPasswordIdGenerator']! as Map<String, Object?>)
          : null,
      setupPasswordIdTimeToLiveInSeconds:
          (json[r'setupPasswordIdTimeToLiveInSeconds'] as num?)?.toInt(),
      trustTokenTimeToLiveInSeconds:
          (json[r'trustTokenTimeToLiveInSeconds'] as num?)?.toInt(),
      twoFactorIdTimeToLiveInSeconds:
          (json[r'twoFactorIdTimeToLiveInSeconds'] as num?)?.toInt(),
      twoFactorOneTimeCodeIdGenerator:
          json[r'twoFactorOneTimeCodeIdGenerator'] != null
              ? SecureGeneratorConfiguration.fromJson(
                  json[r'twoFactorOneTimeCodeIdGenerator']!
                      as Map<String, Object?>)
              : null,
      twoFactorOneTimeCodeIdTimeToLiveInSeconds:
          (json[r'twoFactorOneTimeCodeIdTimeToLiveInSeconds'] as num?)?.toInt(),
      twoFactorTrustIdTimeToLiveInSeconds:
          (json[r'twoFactorTrustIdTimeToLiveInSeconds'] as num?)?.toInt(),
      webAuthnAuthenticationChallengeTimeToLiveInSeconds:
          (json[r'webAuthnAuthenticationChallengeTimeToLiveInSeconds'] as num?)
              ?.toInt(),
      webAuthnRegistrationChallengeTimeToLiveInSeconds:
          (json[r'webAuthnRegistrationChallengeTimeToLiveInSeconds'] as num?)
              ?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var authorizationGrantIdTimeToLiveInSeconds =
        this.authorizationGrantIdTimeToLiveInSeconds;
    var changePasswordIdGenerator = this.changePasswordIdGenerator;
    var changePasswordIdTimeToLiveInSeconds =
        this.changePasswordIdTimeToLiveInSeconds;
    var deviceCodeTimeToLiveInSeconds = this.deviceCodeTimeToLiveInSeconds;
    var deviceUserCodeIdGenerator = this.deviceUserCodeIdGenerator;
    var emailVerificationIdGenerator = this.emailVerificationIdGenerator;
    var emailVerificationIdTimeToLiveInSeconds =
        this.emailVerificationIdTimeToLiveInSeconds;
    var emailVerificationOneTimeCodeGenerator =
        this.emailVerificationOneTimeCodeGenerator;
    var externalAuthenticationIdTimeToLiveInSeconds =
        this.externalAuthenticationIdTimeToLiveInSeconds;
    var loginIntentTimeToLiveInSeconds = this.loginIntentTimeToLiveInSeconds;
    var oneTimePasswordTimeToLiveInSeconds =
        this.oneTimePasswordTimeToLiveInSeconds;
    var passwordlessLoginGenerator = this.passwordlessLoginGenerator;
    var passwordlessLoginTimeToLiveInSeconds =
        this.passwordlessLoginTimeToLiveInSeconds;
    var pendingAccountLinkTimeToLiveInSeconds =
        this.pendingAccountLinkTimeToLiveInSeconds;
    var registrationVerificationIdGenerator =
        this.registrationVerificationIdGenerator;
    var registrationVerificationIdTimeToLiveInSeconds =
        this.registrationVerificationIdTimeToLiveInSeconds;
    var registrationVerificationOneTimeCodeGenerator =
        this.registrationVerificationOneTimeCodeGenerator;
    var rememberoAuthScopeConsentChoiceTimeToLiveInSeconds =
        this.rememberoAuthScopeConsentChoiceTimeToLiveInSeconds;
    var samlv2AuthnRequestIdTimeToLiveInSeconds =
        this.samlv2AuthnRequestIdTimeToLiveInSeconds;
    var setupPasswordIdGenerator = this.setupPasswordIdGenerator;
    var setupPasswordIdTimeToLiveInSeconds =
        this.setupPasswordIdTimeToLiveInSeconds;
    var trustTokenTimeToLiveInSeconds = this.trustTokenTimeToLiveInSeconds;
    var twoFactorIdTimeToLiveInSeconds = this.twoFactorIdTimeToLiveInSeconds;
    var twoFactorOneTimeCodeIdGenerator = this.twoFactorOneTimeCodeIdGenerator;
    var twoFactorOneTimeCodeIdTimeToLiveInSeconds =
        this.twoFactorOneTimeCodeIdTimeToLiveInSeconds;
    var twoFactorTrustIdTimeToLiveInSeconds =
        this.twoFactorTrustIdTimeToLiveInSeconds;
    var webAuthnAuthenticationChallengeTimeToLiveInSeconds =
        this.webAuthnAuthenticationChallengeTimeToLiveInSeconds;
    var webAuthnRegistrationChallengeTimeToLiveInSeconds =
        this.webAuthnRegistrationChallengeTimeToLiveInSeconds;

    final json = <String, Object?>{};
    if (authorizationGrantIdTimeToLiveInSeconds != null) {
      json[r'authorizationGrantIdTimeToLiveInSeconds'] =
          authorizationGrantIdTimeToLiveInSeconds;
    }
    if (changePasswordIdGenerator != null) {
      json[r'changePasswordIdGenerator'] = changePasswordIdGenerator.toJson();
    }
    if (changePasswordIdTimeToLiveInSeconds != null) {
      json[r'changePasswordIdTimeToLiveInSeconds'] =
          changePasswordIdTimeToLiveInSeconds;
    }
    if (deviceCodeTimeToLiveInSeconds != null) {
      json[r'deviceCodeTimeToLiveInSeconds'] = deviceCodeTimeToLiveInSeconds;
    }
    if (deviceUserCodeIdGenerator != null) {
      json[r'deviceUserCodeIdGenerator'] = deviceUserCodeIdGenerator.toJson();
    }
    if (emailVerificationIdGenerator != null) {
      json[r'emailVerificationIdGenerator'] =
          emailVerificationIdGenerator.toJson();
    }
    if (emailVerificationIdTimeToLiveInSeconds != null) {
      json[r'emailVerificationIdTimeToLiveInSeconds'] =
          emailVerificationIdTimeToLiveInSeconds;
    }
    if (emailVerificationOneTimeCodeGenerator != null) {
      json[r'emailVerificationOneTimeCodeGenerator'] =
          emailVerificationOneTimeCodeGenerator.toJson();
    }
    if (externalAuthenticationIdTimeToLiveInSeconds != null) {
      json[r'externalAuthenticationIdTimeToLiveInSeconds'] =
          externalAuthenticationIdTimeToLiveInSeconds;
    }
    if (loginIntentTimeToLiveInSeconds != null) {
      json[r'loginIntentTimeToLiveInSeconds'] = loginIntentTimeToLiveInSeconds;
    }
    if (oneTimePasswordTimeToLiveInSeconds != null) {
      json[r'oneTimePasswordTimeToLiveInSeconds'] =
          oneTimePasswordTimeToLiveInSeconds;
    }
    if (passwordlessLoginGenerator != null) {
      json[r'passwordlessLoginGenerator'] = passwordlessLoginGenerator.toJson();
    }
    if (passwordlessLoginTimeToLiveInSeconds != null) {
      json[r'passwordlessLoginTimeToLiveInSeconds'] =
          passwordlessLoginTimeToLiveInSeconds;
    }
    if (pendingAccountLinkTimeToLiveInSeconds != null) {
      json[r'pendingAccountLinkTimeToLiveInSeconds'] =
          pendingAccountLinkTimeToLiveInSeconds;
    }
    if (registrationVerificationIdGenerator != null) {
      json[r'registrationVerificationIdGenerator'] =
          registrationVerificationIdGenerator.toJson();
    }
    if (registrationVerificationIdTimeToLiveInSeconds != null) {
      json[r'registrationVerificationIdTimeToLiveInSeconds'] =
          registrationVerificationIdTimeToLiveInSeconds;
    }
    if (registrationVerificationOneTimeCodeGenerator != null) {
      json[r'registrationVerificationOneTimeCodeGenerator'] =
          registrationVerificationOneTimeCodeGenerator.toJson();
    }
    if (rememberoAuthScopeConsentChoiceTimeToLiveInSeconds != null) {
      json[r'rememberOAuthScopeConsentChoiceTimeToLiveInSeconds'] =
          rememberoAuthScopeConsentChoiceTimeToLiveInSeconds;
    }
    if (samlv2AuthnRequestIdTimeToLiveInSeconds != null) {
      json[r'samlv2AuthNRequestIdTimeToLiveInSeconds'] =
          samlv2AuthnRequestIdTimeToLiveInSeconds;
    }
    if (setupPasswordIdGenerator != null) {
      json[r'setupPasswordIdGenerator'] = setupPasswordIdGenerator.toJson();
    }
    if (setupPasswordIdTimeToLiveInSeconds != null) {
      json[r'setupPasswordIdTimeToLiveInSeconds'] =
          setupPasswordIdTimeToLiveInSeconds;
    }
    if (trustTokenTimeToLiveInSeconds != null) {
      json[r'trustTokenTimeToLiveInSeconds'] = trustTokenTimeToLiveInSeconds;
    }
    if (twoFactorIdTimeToLiveInSeconds != null) {
      json[r'twoFactorIdTimeToLiveInSeconds'] = twoFactorIdTimeToLiveInSeconds;
    }
    if (twoFactorOneTimeCodeIdGenerator != null) {
      json[r'twoFactorOneTimeCodeIdGenerator'] =
          twoFactorOneTimeCodeIdGenerator.toJson();
    }
    if (twoFactorOneTimeCodeIdTimeToLiveInSeconds != null) {
      json[r'twoFactorOneTimeCodeIdTimeToLiveInSeconds'] =
          twoFactorOneTimeCodeIdTimeToLiveInSeconds;
    }
    if (twoFactorTrustIdTimeToLiveInSeconds != null) {
      json[r'twoFactorTrustIdTimeToLiveInSeconds'] =
          twoFactorTrustIdTimeToLiveInSeconds;
    }
    if (webAuthnAuthenticationChallengeTimeToLiveInSeconds != null) {
      json[r'webAuthnAuthenticationChallengeTimeToLiveInSeconds'] =
          webAuthnAuthenticationChallengeTimeToLiveInSeconds;
    }
    if (webAuthnRegistrationChallengeTimeToLiveInSeconds != null) {
      json[r'webAuthnRegistrationChallengeTimeToLiveInSeconds'] =
          webAuthnRegistrationChallengeTimeToLiveInSeconds;
    }
    return json;
  }

  ExternalIdentifierConfiguration copyWith(
      {int? authorizationGrantIdTimeToLiveInSeconds,
      SecureGeneratorConfiguration? changePasswordIdGenerator,
      int? changePasswordIdTimeToLiveInSeconds,
      int? deviceCodeTimeToLiveInSeconds,
      SecureGeneratorConfiguration? deviceUserCodeIdGenerator,
      SecureGeneratorConfiguration? emailVerificationIdGenerator,
      int? emailVerificationIdTimeToLiveInSeconds,
      SecureGeneratorConfiguration? emailVerificationOneTimeCodeGenerator,
      int? externalAuthenticationIdTimeToLiveInSeconds,
      int? loginIntentTimeToLiveInSeconds,
      int? oneTimePasswordTimeToLiveInSeconds,
      SecureGeneratorConfiguration? passwordlessLoginGenerator,
      int? passwordlessLoginTimeToLiveInSeconds,
      int? pendingAccountLinkTimeToLiveInSeconds,
      SecureGeneratorConfiguration? registrationVerificationIdGenerator,
      int? registrationVerificationIdTimeToLiveInSeconds,
      SecureGeneratorConfiguration?
          registrationVerificationOneTimeCodeGenerator,
      int? rememberoAuthScopeConsentChoiceTimeToLiveInSeconds,
      int? samlv2AuthnRequestIdTimeToLiveInSeconds,
      SecureGeneratorConfiguration? setupPasswordIdGenerator,
      int? setupPasswordIdTimeToLiveInSeconds,
      int? trustTokenTimeToLiveInSeconds,
      int? twoFactorIdTimeToLiveInSeconds,
      SecureGeneratorConfiguration? twoFactorOneTimeCodeIdGenerator,
      int? twoFactorOneTimeCodeIdTimeToLiveInSeconds,
      int? twoFactorTrustIdTimeToLiveInSeconds,
      int? webAuthnAuthenticationChallengeTimeToLiveInSeconds,
      int? webAuthnRegistrationChallengeTimeToLiveInSeconds}) {
    return ExternalIdentifierConfiguration(
      authorizationGrantIdTimeToLiveInSeconds:
          authorizationGrantIdTimeToLiveInSeconds ??
              this.authorizationGrantIdTimeToLiveInSeconds,
      changePasswordIdGenerator:
          changePasswordIdGenerator ?? this.changePasswordIdGenerator,
      changePasswordIdTimeToLiveInSeconds:
          changePasswordIdTimeToLiveInSeconds ??
              this.changePasswordIdTimeToLiveInSeconds,
      deviceCodeTimeToLiveInSeconds:
          deviceCodeTimeToLiveInSeconds ?? this.deviceCodeTimeToLiveInSeconds,
      deviceUserCodeIdGenerator:
          deviceUserCodeIdGenerator ?? this.deviceUserCodeIdGenerator,
      emailVerificationIdGenerator:
          emailVerificationIdGenerator ?? this.emailVerificationIdGenerator,
      emailVerificationIdTimeToLiveInSeconds:
          emailVerificationIdTimeToLiveInSeconds ??
              this.emailVerificationIdTimeToLiveInSeconds,
      emailVerificationOneTimeCodeGenerator:
          emailVerificationOneTimeCodeGenerator ??
              this.emailVerificationOneTimeCodeGenerator,
      externalAuthenticationIdTimeToLiveInSeconds:
          externalAuthenticationIdTimeToLiveInSeconds ??
              this.externalAuthenticationIdTimeToLiveInSeconds,
      loginIntentTimeToLiveInSeconds:
          loginIntentTimeToLiveInSeconds ?? this.loginIntentTimeToLiveInSeconds,
      oneTimePasswordTimeToLiveInSeconds: oneTimePasswordTimeToLiveInSeconds ??
          this.oneTimePasswordTimeToLiveInSeconds,
      passwordlessLoginGenerator:
          passwordlessLoginGenerator ?? this.passwordlessLoginGenerator,
      passwordlessLoginTimeToLiveInSeconds:
          passwordlessLoginTimeToLiveInSeconds ??
              this.passwordlessLoginTimeToLiveInSeconds,
      pendingAccountLinkTimeToLiveInSeconds:
          pendingAccountLinkTimeToLiveInSeconds ??
              this.pendingAccountLinkTimeToLiveInSeconds,
      registrationVerificationIdGenerator:
          registrationVerificationIdGenerator ??
              this.registrationVerificationIdGenerator,
      registrationVerificationIdTimeToLiveInSeconds:
          registrationVerificationIdTimeToLiveInSeconds ??
              this.registrationVerificationIdTimeToLiveInSeconds,
      registrationVerificationOneTimeCodeGenerator:
          registrationVerificationOneTimeCodeGenerator ??
              this.registrationVerificationOneTimeCodeGenerator,
      rememberoAuthScopeConsentChoiceTimeToLiveInSeconds:
          rememberoAuthScopeConsentChoiceTimeToLiveInSeconds ??
              this.rememberoAuthScopeConsentChoiceTimeToLiveInSeconds,
      samlv2AuthnRequestIdTimeToLiveInSeconds:
          samlv2AuthnRequestIdTimeToLiveInSeconds ??
              this.samlv2AuthnRequestIdTimeToLiveInSeconds,
      setupPasswordIdGenerator:
          setupPasswordIdGenerator ?? this.setupPasswordIdGenerator,
      setupPasswordIdTimeToLiveInSeconds: setupPasswordIdTimeToLiveInSeconds ??
          this.setupPasswordIdTimeToLiveInSeconds,
      trustTokenTimeToLiveInSeconds:
          trustTokenTimeToLiveInSeconds ?? this.trustTokenTimeToLiveInSeconds,
      twoFactorIdTimeToLiveInSeconds:
          twoFactorIdTimeToLiveInSeconds ?? this.twoFactorIdTimeToLiveInSeconds,
      twoFactorOneTimeCodeIdGenerator: twoFactorOneTimeCodeIdGenerator ??
          this.twoFactorOneTimeCodeIdGenerator,
      twoFactorOneTimeCodeIdTimeToLiveInSeconds:
          twoFactorOneTimeCodeIdTimeToLiveInSeconds ??
              this.twoFactorOneTimeCodeIdTimeToLiveInSeconds,
      twoFactorTrustIdTimeToLiveInSeconds:
          twoFactorTrustIdTimeToLiveInSeconds ??
              this.twoFactorTrustIdTimeToLiveInSeconds,
      webAuthnAuthenticationChallengeTimeToLiveInSeconds:
          webAuthnAuthenticationChallengeTimeToLiveInSeconds ??
              this.webAuthnAuthenticationChallengeTimeToLiveInSeconds,
      webAuthnRegistrationChallengeTimeToLiveInSeconds:
          webAuthnRegistrationChallengeTimeToLiveInSeconds ??
              this.webAuthnRegistrationChallengeTimeToLiveInSeconds,
    );
  }
}

class ExternalJWTApplicationConfiguration {
  final Map<String, dynamic>? data;
  final bool createRegistration;

  ExternalJWTApplicationConfiguration({this.data, bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory ExternalJWTApplicationConfiguration.fromJson(
      Map<String, Object?> json) {
    return ExternalJWTApplicationConfiguration(
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  ExternalJWTApplicationConfiguration copyWith(
      {Map<String, dynamic>? data, bool? createRegistration}) {
    return ExternalJWTApplicationConfiguration(
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

/// External JWT-only identity provider.
class ExternalJWTIdentityProvider {
  final Map<String, dynamic>? claimMap;
  final List<dynamic> domains;
  final String? defaultKeyId;
  final String? headerKeyParameter;
  final IdentityProviderOauth2Configuration? oauth2;
  final String? uniqueIdentityClaim;
  final Map<String, dynamic>? data;
  final Map<String, dynamic>? applicationConfiguration;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ProviderLambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final IdentityProviderLinkingStrategy? linkingStrategy;
  final String? name;
  final Map<String, dynamic>? tenantConfiguration;
  final IdentityProviderType? type;

  ExternalJWTIdentityProvider(
      {this.claimMap,
      List<dynamic>? domains,
      this.defaultKeyId,
      this.headerKeyParameter,
      this.oauth2,
      this.uniqueIdentityClaim,
      this.data,
      this.applicationConfiguration,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.linkingStrategy,
      this.name,
      this.tenantConfiguration,
      this.type})
      : domains = domains ?? [],
        debug = debug ?? false;

  factory ExternalJWTIdentityProvider.fromJson(Map<String, Object?> json) {
    return ExternalJWTIdentityProvider(
      claimMap: json[r'claimMap'] as Map<String, Object?>?,
      domains:
          (json[r'domains'] as List<Object?>?)?.map((i) => i).toList() ?? [],
      defaultKeyId: json[r'defaultKeyId'] as String?,
      headerKeyParameter: json[r'headerKeyParameter'] as String?,
      oauth2: json[r'oauth2'] != null
          ? IdentityProviderOauth2Configuration.fromJson(
              json[r'oauth2']! as Map<String, Object?>)
          : null,
      uniqueIdentityClaim: json[r'uniqueIdentityClaim'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      applicationConfiguration:
          json[r'applicationConfiguration'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? ProviderLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      linkingStrategy: json[r'linkingStrategy'] != null
          ? IdentityProviderLinkingStrategy.fromValue(
              json[r'linkingStrategy']! as String)
          : null,
      name: json[r'name'] as String?,
      tenantConfiguration:
          json[r'tenantConfiguration'] as Map<String, Object?>?,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var claimMap = this.claimMap;
    var domains = this.domains;
    var defaultKeyId = this.defaultKeyId;
    var headerKeyParameter = this.headerKeyParameter;
    var oauth2 = this.oauth2;
    var uniqueIdentityClaim = this.uniqueIdentityClaim;
    var data = this.data;
    var applicationConfiguration = this.applicationConfiguration;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var linkingStrategy = this.linkingStrategy;
    var name = this.name;
    var tenantConfiguration = this.tenantConfiguration;
    var type = this.type;

    final json = <String, Object?>{};
    if (claimMap != null) {
      json[r'claimMap'] = claimMap;
    }
    json[r'domains'] = domains;
    if (defaultKeyId != null) {
      json[r'defaultKeyId'] = defaultKeyId;
    }
    if (headerKeyParameter != null) {
      json[r'headerKeyParameter'] = headerKeyParameter;
    }
    if (oauth2 != null) {
      json[r'oauth2'] = oauth2.toJson();
    }
    if (uniqueIdentityClaim != null) {
      json[r'uniqueIdentityClaim'] = uniqueIdentityClaim;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (applicationConfiguration != null) {
      json[r'applicationConfiguration'] = applicationConfiguration;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (linkingStrategy != null) {
      json[r'linkingStrategy'] = linkingStrategy.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (tenantConfiguration != null) {
      json[r'tenantConfiguration'] = tenantConfiguration;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  ExternalJWTIdentityProvider copyWith(
      {Map<String, dynamic>? claimMap,
      List<dynamic>? domains,
      String? defaultKeyId,
      String? headerKeyParameter,
      IdentityProviderOauth2Configuration? oauth2,
      String? uniqueIdentityClaim,
      Map<String, dynamic>? data,
      Map<String, dynamic>? applicationConfiguration,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ProviderLambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      IdentityProviderLinkingStrategy? linkingStrategy,
      String? name,
      Map<String, dynamic>? tenantConfiguration,
      IdentityProviderType? type}) {
    return ExternalJWTIdentityProvider(
      claimMap: claimMap ?? this.claimMap,
      domains: domains ?? this.domains,
      defaultKeyId: defaultKeyId ?? this.defaultKeyId,
      headerKeyParameter: headerKeyParameter ?? this.headerKeyParameter,
      oauth2: oauth2 ?? this.oauth2,
      uniqueIdentityClaim: uniqueIdentityClaim ?? this.uniqueIdentityClaim,
      data: data ?? this.data,
      applicationConfiguration:
          applicationConfiguration ?? this.applicationConfiguration,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      linkingStrategy: linkingStrategy ?? this.linkingStrategy,
      name: name ?? this.name,
      tenantConfiguration: tenantConfiguration ?? this.tenantConfiguration,
      type: type ?? this.type,
    );
  }
}

class FacebookApplicationConfiguration {
  final String? appId;
  final String? buttonText;
  final String? clientSecret;
  final String? fields;
  final IdentityProviderLoginMethod? loginMethod;
  final String? permissions;
  final Map<String, dynamic>? data;
  final bool createRegistration;

  FacebookApplicationConfiguration(
      {this.appId,
      this.buttonText,
      this.clientSecret,
      this.fields,
      this.loginMethod,
      this.permissions,
      this.data,
      bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory FacebookApplicationConfiguration.fromJson(Map<String, Object?> json) {
    return FacebookApplicationConfiguration(
      appId: json[r'appId'] as String?,
      buttonText: json[r'buttonText'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      fields: json[r'fields'] as String?,
      loginMethod: json[r'loginMethod'] != null
          ? IdentityProviderLoginMethod.fromValue(
              json[r'loginMethod']! as String)
          : null,
      permissions: json[r'permissions'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var appId = this.appId;
    var buttonText = this.buttonText;
    var clientSecret = this.clientSecret;
    var fields = this.fields;
    var loginMethod = this.loginMethod;
    var permissions = this.permissions;
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (appId != null) {
      json[r'appId'] = appId;
    }
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (fields != null) {
      json[r'fields'] = fields;
    }
    if (loginMethod != null) {
      json[r'loginMethod'] = loginMethod.value;
    }
    if (permissions != null) {
      json[r'permissions'] = permissions;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  FacebookApplicationConfiguration copyWith(
      {String? appId,
      String? buttonText,
      String? clientSecret,
      String? fields,
      IdentityProviderLoginMethod? loginMethod,
      String? permissions,
      Map<String, dynamic>? data,
      bool? createRegistration}) {
    return FacebookApplicationConfiguration(
      appId: appId ?? this.appId,
      buttonText: buttonText ?? this.buttonText,
      clientSecret: clientSecret ?? this.clientSecret,
      fields: fields ?? this.fields,
      loginMethod: loginMethod ?? this.loginMethod,
      permissions: permissions ?? this.permissions,
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

/// Facebook social login provider.
class FacebookIdentityProvider {
  final String? appId;
  final String? buttonText;
  final String? clientSecret;
  final String? fields;
  final IdentityProviderLoginMethod? loginMethod;
  final String? permissions;
  final Map<String, dynamic>? data;
  final Map<String, dynamic>? applicationConfiguration;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ProviderLambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final IdentityProviderLinkingStrategy? linkingStrategy;
  final String? name;
  final Map<String, dynamic>? tenantConfiguration;
  final IdentityProviderType? type;

  FacebookIdentityProvider(
      {this.appId,
      this.buttonText,
      this.clientSecret,
      this.fields,
      this.loginMethod,
      this.permissions,
      this.data,
      this.applicationConfiguration,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.linkingStrategy,
      this.name,
      this.tenantConfiguration,
      this.type})
      : debug = debug ?? false;

  factory FacebookIdentityProvider.fromJson(Map<String, Object?> json) {
    return FacebookIdentityProvider(
      appId: json[r'appId'] as String?,
      buttonText: json[r'buttonText'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      fields: json[r'fields'] as String?,
      loginMethod: json[r'loginMethod'] != null
          ? IdentityProviderLoginMethod.fromValue(
              json[r'loginMethod']! as String)
          : null,
      permissions: json[r'permissions'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      applicationConfiguration:
          json[r'applicationConfiguration'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? ProviderLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      linkingStrategy: json[r'linkingStrategy'] != null
          ? IdentityProviderLinkingStrategy.fromValue(
              json[r'linkingStrategy']! as String)
          : null,
      name: json[r'name'] as String?,
      tenantConfiguration:
          json[r'tenantConfiguration'] as Map<String, Object?>?,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var appId = this.appId;
    var buttonText = this.buttonText;
    var clientSecret = this.clientSecret;
    var fields = this.fields;
    var loginMethod = this.loginMethod;
    var permissions = this.permissions;
    var data = this.data;
    var applicationConfiguration = this.applicationConfiguration;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var linkingStrategy = this.linkingStrategy;
    var name = this.name;
    var tenantConfiguration = this.tenantConfiguration;
    var type = this.type;

    final json = <String, Object?>{};
    if (appId != null) {
      json[r'appId'] = appId;
    }
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (fields != null) {
      json[r'fields'] = fields;
    }
    if (loginMethod != null) {
      json[r'loginMethod'] = loginMethod.value;
    }
    if (permissions != null) {
      json[r'permissions'] = permissions;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (applicationConfiguration != null) {
      json[r'applicationConfiguration'] = applicationConfiguration;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (linkingStrategy != null) {
      json[r'linkingStrategy'] = linkingStrategy.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (tenantConfiguration != null) {
      json[r'tenantConfiguration'] = tenantConfiguration;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  FacebookIdentityProvider copyWith(
      {String? appId,
      String? buttonText,
      String? clientSecret,
      String? fields,
      IdentityProviderLoginMethod? loginMethod,
      String? permissions,
      Map<String, dynamic>? data,
      Map<String, dynamic>? applicationConfiguration,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ProviderLambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      IdentityProviderLinkingStrategy? linkingStrategy,
      String? name,
      Map<String, dynamic>? tenantConfiguration,
      IdentityProviderType? type}) {
    return FacebookIdentityProvider(
      appId: appId ?? this.appId,
      buttonText: buttonText ?? this.buttonText,
      clientSecret: clientSecret ?? this.clientSecret,
      fields: fields ?? this.fields,
      loginMethod: loginMethod ?? this.loginMethod,
      permissions: permissions ?? this.permissions,
      data: data ?? this.data,
      applicationConfiguration:
          applicationConfiguration ?? this.applicationConfiguration,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      linkingStrategy: linkingStrategy ?? this.linkingStrategy,
      name: name ?? this.name,
      tenantConfiguration: tenantConfiguration ?? this.tenantConfiguration,
      type: type ?? this.type,
    );
  }
}

/// A policy to configure if and when the user-action is canceled prior to the
/// expiration of the action.
class FailedAuthenticationActionCancelPolicy {
  final bool onPasswordReset;

  FailedAuthenticationActionCancelPolicy({bool? onPasswordReset})
      : onPasswordReset = onPasswordReset ?? false;

  factory FailedAuthenticationActionCancelPolicy.fromJson(
      Map<String, Object?> json) {
    return FailedAuthenticationActionCancelPolicy(
      onPasswordReset: json[r'onPasswordReset'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var onPasswordReset = this.onPasswordReset;

    final json = <String, Object?>{};
    json[r'onPasswordReset'] = onPasswordReset;
    return json;
  }

  FailedAuthenticationActionCancelPolicy copyWith({bool? onPasswordReset}) {
    return FailedAuthenticationActionCancelPolicy(
      onPasswordReset: onPasswordReset ?? this.onPasswordReset,
    );
  }
}

/// Configuration for the behavior of failed login attempts. This helps us
/// protect against brute force password attacks.
class FailedAuthenticationConfiguration {
  final FailedAuthenticationActionCancelPolicy? actionCancelPolicy;
  final int? actionDuration;
  final ExpiryUnit? actionDurationUnit;
  final bool emailUser;
  final int? resetCountInSeconds;
  final int? tooManyAttempts;
  final String? userActionId;

  FailedAuthenticationConfiguration(
      {this.actionCancelPolicy,
      this.actionDuration,
      this.actionDurationUnit,
      bool? emailUser,
      this.resetCountInSeconds,
      this.tooManyAttempts,
      this.userActionId})
      : emailUser = emailUser ?? false;

  factory FailedAuthenticationConfiguration.fromJson(
      Map<String, Object?> json) {
    return FailedAuthenticationConfiguration(
      actionCancelPolicy: json[r'actionCancelPolicy'] != null
          ? FailedAuthenticationActionCancelPolicy.fromJson(
              json[r'actionCancelPolicy']! as Map<String, Object?>)
          : null,
      actionDuration: (json[r'actionDuration'] as num?)?.toInt(),
      actionDurationUnit: json[r'actionDurationUnit'] != null
          ? ExpiryUnit.fromValue(json[r'actionDurationUnit']! as String)
          : null,
      emailUser: json[r'emailUser'] as bool? ?? false,
      resetCountInSeconds: (json[r'resetCountInSeconds'] as num?)?.toInt(),
      tooManyAttempts: (json[r'tooManyAttempts'] as num?)?.toInt(),
      userActionId: json[r'userActionId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var actionCancelPolicy = this.actionCancelPolicy;
    var actionDuration = this.actionDuration;
    var actionDurationUnit = this.actionDurationUnit;
    var emailUser = this.emailUser;
    var resetCountInSeconds = this.resetCountInSeconds;
    var tooManyAttempts = this.tooManyAttempts;
    var userActionId = this.userActionId;

    final json = <String, Object?>{};
    if (actionCancelPolicy != null) {
      json[r'actionCancelPolicy'] = actionCancelPolicy.toJson();
    }
    if (actionDuration != null) {
      json[r'actionDuration'] = actionDuration;
    }
    if (actionDurationUnit != null) {
      json[r'actionDurationUnit'] = actionDurationUnit.value;
    }
    json[r'emailUser'] = emailUser;
    if (resetCountInSeconds != null) {
      json[r'resetCountInSeconds'] = resetCountInSeconds;
    }
    if (tooManyAttempts != null) {
      json[r'tooManyAttempts'] = tooManyAttempts;
    }
    if (userActionId != null) {
      json[r'userActionId'] = userActionId;
    }
    return json;
  }

  FailedAuthenticationConfiguration copyWith(
      {FailedAuthenticationActionCancelPolicy? actionCancelPolicy,
      int? actionDuration,
      ExpiryUnit? actionDurationUnit,
      bool? emailUser,
      int? resetCountInSeconds,
      int? tooManyAttempts,
      String? userActionId}) {
    return FailedAuthenticationConfiguration(
      actionCancelPolicy: actionCancelPolicy ?? this.actionCancelPolicy,
      actionDuration: actionDuration ?? this.actionDuration,
      actionDurationUnit: actionDurationUnit ?? this.actionDurationUnit,
      emailUser: emailUser ?? this.emailUser,
      resetCountInSeconds: resetCountInSeconds ?? this.resetCountInSeconds,
      tooManyAttempts: tooManyAttempts ?? this.tooManyAttempts,
      userActionId: userActionId ?? this.userActionId,
    );
  }
}

/// Models a family grouping of users.
class Family {
  final List<FamilyMember> members;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;

  Family(
      {List<FamilyMember>? members,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant})
      : members = members ?? [];

  factory Family.fromJson(Map<String, Object?> json) {
    return Family(
      members: (json[r'members'] as List<Object?>?)
              ?.map((i) =>
                  FamilyMember.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
    );
  }

  Map<String, Object?> toJson() {
    var members = this.members;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;

    final json = <String, Object?>{};
    json[r'members'] = members.map((i) => i.toJson()).toList();
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    return json;
  }

  Family copyWith(
      {List<FamilyMember>? members,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant}) {
    return Family(
      members: members ?? this.members,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
    );
  }
}

class FamilyConfiguration {
  final bool allowChildRegistrations;
  final String? confirmChildEmailTemplateId;
  final bool deleteOrphanedAccounts;
  final int? deleteOrphanedAccountsDays;
  final String? familyRequestEmailTemplateId;
  final int? maximumChildAge;
  final int? minimumOwnerAge;
  final bool parentEmailRequired;
  final String? parentRegistrationEmailTemplateId;
  final bool enabled;

  FamilyConfiguration(
      {bool? allowChildRegistrations,
      this.confirmChildEmailTemplateId,
      bool? deleteOrphanedAccounts,
      this.deleteOrphanedAccountsDays,
      this.familyRequestEmailTemplateId,
      this.maximumChildAge,
      this.minimumOwnerAge,
      bool? parentEmailRequired,
      this.parentRegistrationEmailTemplateId,
      bool? enabled})
      : allowChildRegistrations = allowChildRegistrations ?? false,
        deleteOrphanedAccounts = deleteOrphanedAccounts ?? false,
        parentEmailRequired = parentEmailRequired ?? false,
        enabled = enabled ?? false;

  factory FamilyConfiguration.fromJson(Map<String, Object?> json) {
    return FamilyConfiguration(
      allowChildRegistrations:
          json[r'allowChildRegistrations'] as bool? ?? false,
      confirmChildEmailTemplateId:
          json[r'confirmChildEmailTemplateId'] as String?,
      deleteOrphanedAccounts: json[r'deleteOrphanedAccounts'] as bool? ?? false,
      deleteOrphanedAccountsDays:
          (json[r'deleteOrphanedAccountsDays'] as num?)?.toInt(),
      familyRequestEmailTemplateId:
          json[r'familyRequestEmailTemplateId'] as String?,
      maximumChildAge: (json[r'maximumChildAge'] as num?)?.toInt(),
      minimumOwnerAge: (json[r'minimumOwnerAge'] as num?)?.toInt(),
      parentEmailRequired: json[r'parentEmailRequired'] as bool? ?? false,
      parentRegistrationEmailTemplateId:
          json[r'parentRegistrationEmailTemplateId'] as String?,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var allowChildRegistrations = this.allowChildRegistrations;
    var confirmChildEmailTemplateId = this.confirmChildEmailTemplateId;
    var deleteOrphanedAccounts = this.deleteOrphanedAccounts;
    var deleteOrphanedAccountsDays = this.deleteOrphanedAccountsDays;
    var familyRequestEmailTemplateId = this.familyRequestEmailTemplateId;
    var maximumChildAge = this.maximumChildAge;
    var minimumOwnerAge = this.minimumOwnerAge;
    var parentEmailRequired = this.parentEmailRequired;
    var parentRegistrationEmailTemplateId =
        this.parentRegistrationEmailTemplateId;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    json[r'allowChildRegistrations'] = allowChildRegistrations;
    if (confirmChildEmailTemplateId != null) {
      json[r'confirmChildEmailTemplateId'] = confirmChildEmailTemplateId;
    }
    json[r'deleteOrphanedAccounts'] = deleteOrphanedAccounts;
    if (deleteOrphanedAccountsDays != null) {
      json[r'deleteOrphanedAccountsDays'] = deleteOrphanedAccountsDays;
    }
    if (familyRequestEmailTemplateId != null) {
      json[r'familyRequestEmailTemplateId'] = familyRequestEmailTemplateId;
    }
    if (maximumChildAge != null) {
      json[r'maximumChildAge'] = maximumChildAge;
    }
    if (minimumOwnerAge != null) {
      json[r'minimumOwnerAge'] = minimumOwnerAge;
    }
    json[r'parentEmailRequired'] = parentEmailRequired;
    if (parentRegistrationEmailTemplateId != null) {
      json[r'parentRegistrationEmailTemplateId'] =
          parentRegistrationEmailTemplateId;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  FamilyConfiguration copyWith(
      {bool? allowChildRegistrations,
      String? confirmChildEmailTemplateId,
      bool? deleteOrphanedAccounts,
      int? deleteOrphanedAccountsDays,
      String? familyRequestEmailTemplateId,
      int? maximumChildAge,
      int? minimumOwnerAge,
      bool? parentEmailRequired,
      String? parentRegistrationEmailTemplateId,
      bool? enabled}) {
    return FamilyConfiguration(
      allowChildRegistrations:
          allowChildRegistrations ?? this.allowChildRegistrations,
      confirmChildEmailTemplateId:
          confirmChildEmailTemplateId ?? this.confirmChildEmailTemplateId,
      deleteOrphanedAccounts:
          deleteOrphanedAccounts ?? this.deleteOrphanedAccounts,
      deleteOrphanedAccountsDays:
          deleteOrphanedAccountsDays ?? this.deleteOrphanedAccountsDays,
      familyRequestEmailTemplateId:
          familyRequestEmailTemplateId ?? this.familyRequestEmailTemplateId,
      maximumChildAge: maximumChildAge ?? this.maximumChildAge,
      minimumOwnerAge: minimumOwnerAge ?? this.minimumOwnerAge,
      parentEmailRequired: parentEmailRequired ?? this.parentEmailRequired,
      parentRegistrationEmailTemplateId: parentRegistrationEmailTemplateId ??
          this.parentRegistrationEmailTemplateId,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// API request for sending out family requests to parent's.
class FamilyEmailRequest {
  final String? parentEmail;

  FamilyEmailRequest({this.parentEmail});

  factory FamilyEmailRequest.fromJson(Map<String, Object?> json) {
    return FamilyEmailRequest(
      parentEmail: json[r'parentEmail'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var parentEmail = this.parentEmail;

    final json = <String, Object?>{};
    if (parentEmail != null) {
      json[r'parentEmail'] = parentEmail;
    }
    return json;
  }

  FamilyEmailRequest copyWith({String? parentEmail}) {
    return FamilyEmailRequest(
      parentEmail: parentEmail ?? this.parentEmail,
    );
  }
}

/// Models a single family member.
class FamilyMember {
  final Map<String, dynamic>? data;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final bool owner;
  final FamilyRole? role;
  final String? userId;

  FamilyMember(
      {this.data,
      this.insertInstant,
      this.lastUpdateInstant,
      bool? owner,
      this.role,
      this.userId})
      : owner = owner ?? false;

  factory FamilyMember.fromJson(Map<String, Object?> json) {
    return FamilyMember(
      data: json[r'data'] as Map<String, Object?>?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      owner: json[r'owner'] as bool? ?? false,
      role: json[r'role'] != null
          ? FamilyRole.fromValue(json[r'role']! as String)
          : null,
      userId: json[r'userId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var owner = this.owner;
    var role = this.role;
    var userId = this.userId;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    json[r'owner'] = owner;
    if (role != null) {
      json[r'role'] = role.value;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    return json;
  }

  FamilyMember copyWith(
      {Map<String, dynamic>? data,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      bool? owner,
      FamilyRole? role,
      String? userId}) {
    return FamilyMember(
      data: data ?? this.data,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      owner: owner ?? this.owner,
      role: role ?? this.role,
      userId: userId ?? this.userId,
    );
  }
}

/// API request for managing families and members.
class FamilyRequest {
  final FamilyMember? familyMember;

  FamilyRequest({this.familyMember});

  factory FamilyRequest.fromJson(Map<String, Object?> json) {
    return FamilyRequest(
      familyMember: json[r'familyMember'] != null
          ? FamilyMember.fromJson(
              json[r'familyMember']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var familyMember = this.familyMember;

    final json = <String, Object?>{};
    if (familyMember != null) {
      json[r'familyMember'] = familyMember.toJson();
    }
    return json;
  }

  FamilyRequest copyWith({FamilyMember? familyMember}) {
    return FamilyRequest(
      familyMember: familyMember ?? this.familyMember,
    );
  }
}

/// API response for managing families and members.
class FamilyResponse {
  final List<Family> families;
  final Family? family;

  FamilyResponse({List<Family>? families, this.family})
      : families = families ?? [];

  factory FamilyResponse.fromJson(Map<String, Object?> json) {
    return FamilyResponse(
      families: (json[r'families'] as List<Object?>?)
              ?.map((i) =>
                  Family.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      family: json[r'family'] != null
          ? Family.fromJson(json[r'family']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var families = this.families;
    var family = this.family;

    final json = <String, Object?>{};
    json[r'families'] = families.map((i) => i.toJson()).toList();
    if (family != null) {
      json[r'family'] = family.toJson();
    }
    return json;
  }

  FamilyResponse copyWith({List<Family>? families, Family? family}) {
    return FamilyResponse(
      families: families ?? this.families,
      family: family ?? this.family,
    );
  }
}

/// Forgot password request object.
class ForgotPasswordRequest {
  final String? applicationId;
  final String? changePasswordId;
  final String? loginId;
  final bool sendForgotPasswordEmail;
  final Map<String, dynamic>? state;
  final String? email;
  final String? username;
  final EventInfo? eventInfo;

  ForgotPasswordRequest(
      {this.applicationId,
      this.changePasswordId,
      this.loginId,
      bool? sendForgotPasswordEmail,
      this.state,
      this.email,
      this.username,
      this.eventInfo})
      : sendForgotPasswordEmail = sendForgotPasswordEmail ?? false;

  factory ForgotPasswordRequest.fromJson(Map<String, Object?> json) {
    return ForgotPasswordRequest(
      applicationId: json[r'applicationId'] as String?,
      changePasswordId: json[r'changePasswordId'] as String?,
      loginId: json[r'loginId'] as String?,
      sendForgotPasswordEmail:
          json[r'sendForgotPasswordEmail'] as bool? ?? false,
      state: json[r'state'] as Map<String, Object?>?,
      email: json[r'email'] as String?,
      username: json[r'username'] as String?,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var changePasswordId = this.changePasswordId;
    var loginId = this.loginId;
    var sendForgotPasswordEmail = this.sendForgotPasswordEmail;
    var state = this.state;
    var email = this.email;
    var username = this.username;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (changePasswordId != null) {
      json[r'changePasswordId'] = changePasswordId;
    }
    if (loginId != null) {
      json[r'loginId'] = loginId;
    }
    json[r'sendForgotPasswordEmail'] = sendForgotPasswordEmail;
    if (state != null) {
      json[r'state'] = state;
    }
    if (email != null) {
      json[r'email'] = email;
    }
    if (username != null) {
      json[r'username'] = username;
    }
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  ForgotPasswordRequest copyWith(
      {String? applicationId,
      String? changePasswordId,
      String? loginId,
      bool? sendForgotPasswordEmail,
      Map<String, dynamic>? state,
      String? email,
      String? username,
      EventInfo? eventInfo}) {
    return ForgotPasswordRequest(
      applicationId: applicationId ?? this.applicationId,
      changePasswordId: changePasswordId ?? this.changePasswordId,
      loginId: loginId ?? this.loginId,
      sendForgotPasswordEmail:
          sendForgotPasswordEmail ?? this.sendForgotPasswordEmail,
      state: state ?? this.state,
      email: email ?? this.email,
      username: username ?? this.username,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

/// Forgot password response object.
class ForgotPasswordResponse {
  final String? changePasswordId;

  ForgotPasswordResponse({this.changePasswordId});

  factory ForgotPasswordResponse.fromJson(Map<String, Object?> json) {
    return ForgotPasswordResponse(
      changePasswordId: json[r'changePasswordId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var changePasswordId = this.changePasswordId;

    final json = <String, Object?>{};
    if (changePasswordId != null) {
      json[r'changePasswordId'] = changePasswordId;
    }
    return json;
  }

  ForgotPasswordResponse copyWith({String? changePasswordId}) {
    return ForgotPasswordResponse(
      changePasswordId: changePasswordId ?? this.changePasswordId,
    );
  }
}

class Form {
  final Map<String, dynamic>? data;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final List<FormStep> steps;
  final FormType? type;

  Form(
      {this.data,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.name,
      List<FormStep>? steps,
      this.type})
      : steps = steps ?? [];

  factory Form.fromJson(Map<String, Object?> json) {
    return Form(
      data: json[r'data'] as Map<String, Object?>?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      steps: (json[r'steps'] as List<Object?>?)
              ?.map((i) =>
                  FormStep.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      type: json[r'type'] != null
          ? FormType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var steps = this.steps;
    var type = this.type;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'steps'] = steps.map((i) => i.toJson()).toList();
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  Form copyWith(
      {Map<String, dynamic>? data,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      List<FormStep>? steps,
      FormType? type}) {
    return Form(
      data: data ?? this.data,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      steps: steps ?? this.steps,
      type: type ?? this.type,
    );
  }
}

class FormField {
  final bool confirm;
  final String? consentId;
  final FormControl? control;
  final Map<String, dynamic>? data;
  final String? description;
  final String? id;
  final ZonedDateTime? insertInstant;
  final String? key;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final List<String> options;
  final bool required;
  final FormDataType? type;
  final FormFieldValidator? validator;

  FormField(
      {bool? confirm,
      this.consentId,
      this.control,
      this.data,
      this.description,
      this.id,
      this.insertInstant,
      this.key,
      this.lastUpdateInstant,
      this.name,
      List<String>? options,
      bool? required,
      this.type,
      this.validator})
      : confirm = confirm ?? false,
        options = options ?? [],
        required = required ?? false;

  factory FormField.fromJson(Map<String, Object?> json) {
    return FormField(
      confirm: json[r'confirm'] as bool? ?? false,
      consentId: json[r'consentId'] as String?,
      control: json[r'control'] != null
          ? FormControl.fromValue(json[r'control']! as String)
          : null,
      data: json[r'data'] as Map<String, Object?>?,
      description: json[r'description'] as String?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      key: json[r'key'] as String?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      options: (json[r'options'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      required: json[r'required'] as bool? ?? false,
      type: json[r'type'] != null
          ? FormDataType.fromValue(json[r'type']! as String)
          : null,
      validator: json[r'validator'] != null
          ? FormFieldValidator.fromJson(
              json[r'validator']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var confirm = this.confirm;
    var consentId = this.consentId;
    var control = this.control;
    var data = this.data;
    var description = this.description;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var key = this.key;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var options = this.options;
    var required = this.required;
    var type = this.type;
    var validator = this.validator;

    final json = <String, Object?>{};
    json[r'confirm'] = confirm;
    if (consentId != null) {
      json[r'consentId'] = consentId;
    }
    if (control != null) {
      json[r'control'] = control.value;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'options'] = options;
    json[r'required'] = required;
    if (type != null) {
      json[r'type'] = type.value;
    }
    if (validator != null) {
      json[r'validator'] = validator.toJson();
    }
    return json;
  }

  FormField copyWith(
      {bool? confirm,
      String? consentId,
      FormControl? control,
      Map<String, dynamic>? data,
      String? description,
      String? id,
      ZonedDateTime? insertInstant,
      String? key,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      List<String>? options,
      bool? required,
      FormDataType? type,
      FormFieldValidator? validator}) {
    return FormField(
      confirm: confirm ?? this.confirm,
      consentId: consentId ?? this.consentId,
      control: control ?? this.control,
      data: data ?? this.data,
      description: description ?? this.description,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      key: key ?? this.key,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      options: options ?? this.options,
      required: required ?? this.required,
      type: type ?? this.type,
      validator: validator ?? this.validator,
    );
  }
}

/// The FormField API request object.
class FormFieldRequest {
  final FormField? field;
  final List<FormField> fields;

  FormFieldRequest({this.field, List<FormField>? fields})
      : fields = fields ?? [];

  factory FormFieldRequest.fromJson(Map<String, Object?> json) {
    return FormFieldRequest(
      field: json[r'field'] != null
          ? FormField.fromJson(json[r'field']! as Map<String, Object?>)
          : null,
      fields: (json[r'fields'] as List<Object?>?)
              ?.map((i) =>
                  FormField.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var field = this.field;
    var fields = this.fields;

    final json = <String, Object?>{};
    if (field != null) {
      json[r'field'] = field.toJson();
    }
    json[r'fields'] = fields.map((i) => i.toJson()).toList();
    return json;
  }

  FormFieldRequest copyWith({FormField? field, List<FormField>? fields}) {
    return FormFieldRequest(
      field: field ?? this.field,
      fields: fields ?? this.fields,
    );
  }
}

/// Form field response.
class FormFieldResponse {
  final FormField? field;
  final List<FormField> fields;

  FormFieldResponse({this.field, List<FormField>? fields})
      : fields = fields ?? [];

  factory FormFieldResponse.fromJson(Map<String, Object?> json) {
    return FormFieldResponse(
      field: json[r'field'] != null
          ? FormField.fromJson(json[r'field']! as Map<String, Object?>)
          : null,
      fields: (json[r'fields'] as List<Object?>?)
              ?.map((i) =>
                  FormField.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var field = this.field;
    var fields = this.fields;

    final json = <String, Object?>{};
    if (field != null) {
      json[r'field'] = field.toJson();
    }
    json[r'fields'] = fields.map((i) => i.toJson()).toList();
    return json;
  }

  FormFieldResponse copyWith({FormField? field, List<FormField>? fields}) {
    return FormFieldResponse(
      field: field ?? this.field,
      fields: fields ?? this.fields,
    );
  }
}

class FormFieldValidator {
  final String? expression;
  final bool enabled;

  FormFieldValidator({this.expression, bool? enabled})
      : enabled = enabled ?? false;

  factory FormFieldValidator.fromJson(Map<String, Object?> json) {
    return FormFieldValidator(
      expression: json[r'expression'] as String?,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var expression = this.expression;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (expression != null) {
      json[r'expression'] = expression;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  FormFieldValidator copyWith({String? expression, bool? enabled}) {
    return FormFieldValidator(
      expression: expression ?? this.expression,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Form response.
class FormRequest {
  final Form? form;

  FormRequest({this.form});

  factory FormRequest.fromJson(Map<String, Object?> json) {
    return FormRequest(
      form: json[r'form'] != null
          ? Form.fromJson(json[r'form']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var form = this.form;

    final json = <String, Object?>{};
    if (form != null) {
      json[r'form'] = form.toJson();
    }
    return json;
  }

  FormRequest copyWith({Form? form}) {
    return FormRequest(
      form: form ?? this.form,
    );
  }
}

/// Form response.
class FormResponse {
  final Form? form;
  final List<Form> forms;

  FormResponse({this.form, List<Form>? forms}) : forms = forms ?? [];

  factory FormResponse.fromJson(Map<String, Object?> json) {
    return FormResponse(
      form: json[r'form'] != null
          ? Form.fromJson(json[r'form']! as Map<String, Object?>)
          : null,
      forms: (json[r'forms'] as List<Object?>?)
              ?.map(
                  (i) => Form.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var form = this.form;
    var forms = this.forms;

    final json = <String, Object?>{};
    if (form != null) {
      json[r'form'] = form.toJson();
    }
    json[r'forms'] = forms.map((i) => i.toJson()).toList();
    return json;
  }

  FormResponse copyWith({Form? form, List<Form>? forms}) {
    return FormResponse(
      form: form ?? this.form,
      forms: forms ?? this.forms,
    );
  }
}

class FormStep {
  final List<String> fields;

  FormStep({List<String>? fields}) : fields = fields ?? [];

  factory FormStep.fromJson(Map<String, Object?> json) {
    return FormStep(
      fields: (json[r'fields'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var fields = this.fields;

    final json = <String, Object?>{};
    json[r'fields'] = fields;
    return json;
  }

  FormStep copyWith({List<String>? fields}) {
    return FormStep(
      fields: fields ?? this.fields,
    );
  }
}

/// Models the FusionAuth connector.
class FusionAuthConnectorConfiguration {
  final Map<String, dynamic>? data;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final ConnectorType? type;

  FusionAuthConnectorConfiguration(
      {this.data,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.name,
      this.type})
      : debug = debug ?? false;

  factory FusionAuthConnectorConfiguration.fromJson(Map<String, Object?> json) {
    return FusionAuthConnectorConfiguration(
      data: json[r'data'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      type: json[r'type'] != null
          ? ConnectorType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var type = this.type;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  FusionAuthConnectorConfiguration copyWith(
      {Map<String, dynamic>? data,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      ConnectorType? type}) {
    return FusionAuthConnectorConfiguration(
      data: data ?? this.data,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      type: type ?? this.type,
    );
  }
}

/// Models a generic connector.
class GenericConnectorConfiguration {
  final String? authenticationUrl;
  final int? connectTimeout;
  final HTTPHeaders? headers;
  final String? httpAuthenticationPassword;
  final String? httpAuthenticationUsername;
  final int? readTimeout;
  final String? sslCertificateKeyId;
  final Map<String, dynamic>? data;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final ConnectorType? type;

  GenericConnectorConfiguration(
      {this.authenticationUrl,
      this.connectTimeout,
      this.headers,
      this.httpAuthenticationPassword,
      this.httpAuthenticationUsername,
      this.readTimeout,
      this.sslCertificateKeyId,
      this.data,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.name,
      this.type})
      : debug = debug ?? false;

  factory GenericConnectorConfiguration.fromJson(Map<String, Object?> json) {
    return GenericConnectorConfiguration(
      authenticationUrl: json[r'authenticationURL'] as String?,
      connectTimeout: (json[r'connectTimeout'] as num?)?.toInt(),
      headers: json[r'headers'] != null
          ? HTTPHeaders.fromJson(json[r'headers']! as Map<String, Object?>)
          : null,
      httpAuthenticationPassword:
          json[r'httpAuthenticationPassword'] as String?,
      httpAuthenticationUsername:
          json[r'httpAuthenticationUsername'] as String?,
      readTimeout: (json[r'readTimeout'] as num?)?.toInt(),
      sslCertificateKeyId: json[r'sslCertificateKeyId'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      type: json[r'type'] != null
          ? ConnectorType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var authenticationUrl = this.authenticationUrl;
    var connectTimeout = this.connectTimeout;
    var headers = this.headers;
    var httpAuthenticationPassword = this.httpAuthenticationPassword;
    var httpAuthenticationUsername = this.httpAuthenticationUsername;
    var readTimeout = this.readTimeout;
    var sslCertificateKeyId = this.sslCertificateKeyId;
    var data = this.data;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var type = this.type;

    final json = <String, Object?>{};
    if (authenticationUrl != null) {
      json[r'authenticationURL'] = authenticationUrl;
    }
    if (connectTimeout != null) {
      json[r'connectTimeout'] = connectTimeout;
    }
    if (headers != null) {
      json[r'headers'] = headers.toJson();
    }
    if (httpAuthenticationPassword != null) {
      json[r'httpAuthenticationPassword'] = httpAuthenticationPassword;
    }
    if (httpAuthenticationUsername != null) {
      json[r'httpAuthenticationUsername'] = httpAuthenticationUsername;
    }
    if (readTimeout != null) {
      json[r'readTimeout'] = readTimeout;
    }
    if (sslCertificateKeyId != null) {
      json[r'sslCertificateKeyId'] = sslCertificateKeyId;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  GenericConnectorConfiguration copyWith(
      {String? authenticationUrl,
      int? connectTimeout,
      HTTPHeaders? headers,
      String? httpAuthenticationPassword,
      String? httpAuthenticationUsername,
      int? readTimeout,
      String? sslCertificateKeyId,
      Map<String, dynamic>? data,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      ConnectorType? type}) {
    return GenericConnectorConfiguration(
      authenticationUrl: authenticationUrl ?? this.authenticationUrl,
      connectTimeout: connectTimeout ?? this.connectTimeout,
      headers: headers ?? this.headers,
      httpAuthenticationPassword:
          httpAuthenticationPassword ?? this.httpAuthenticationPassword,
      httpAuthenticationUsername:
          httpAuthenticationUsername ?? this.httpAuthenticationUsername,
      readTimeout: readTimeout ?? this.readTimeout,
      sslCertificateKeyId: sslCertificateKeyId ?? this.sslCertificateKeyId,
      data: data ?? this.data,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      type: type ?? this.type,
    );
  }
}

class GenericMessengerConfiguration {
  final int? connectTimeout;
  final HTTPHeaders? headers;
  final String? httpAuthenticationPassword;
  final String? httpAuthenticationUsername;
  final int? readTimeout;
  final String? sslCertificate;
  final String? url;
  final Map<String, dynamic>? data;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final String? transport;
  final MessengerType? type;

  GenericMessengerConfiguration(
      {this.connectTimeout,
      this.headers,
      this.httpAuthenticationPassword,
      this.httpAuthenticationUsername,
      this.readTimeout,
      this.sslCertificate,
      this.url,
      this.data,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.name,
      this.transport,
      this.type})
      : debug = debug ?? false;

  factory GenericMessengerConfiguration.fromJson(Map<String, Object?> json) {
    return GenericMessengerConfiguration(
      connectTimeout: (json[r'connectTimeout'] as num?)?.toInt(),
      headers: json[r'headers'] != null
          ? HTTPHeaders.fromJson(json[r'headers']! as Map<String, Object?>)
          : null,
      httpAuthenticationPassword:
          json[r'httpAuthenticationPassword'] as String?,
      httpAuthenticationUsername:
          json[r'httpAuthenticationUsername'] as String?,
      readTimeout: (json[r'readTimeout'] as num?)?.toInt(),
      sslCertificate: json[r'sslCertificate'] as String?,
      url: json[r'url'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      transport: json[r'transport'] as String?,
      type: json[r'type'] != null
          ? MessengerType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var connectTimeout = this.connectTimeout;
    var headers = this.headers;
    var httpAuthenticationPassword = this.httpAuthenticationPassword;
    var httpAuthenticationUsername = this.httpAuthenticationUsername;
    var readTimeout = this.readTimeout;
    var sslCertificate = this.sslCertificate;
    var url = this.url;
    var data = this.data;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var transport = this.transport;
    var type = this.type;

    final json = <String, Object?>{};
    if (connectTimeout != null) {
      json[r'connectTimeout'] = connectTimeout;
    }
    if (headers != null) {
      json[r'headers'] = headers.toJson();
    }
    if (httpAuthenticationPassword != null) {
      json[r'httpAuthenticationPassword'] = httpAuthenticationPassword;
    }
    if (httpAuthenticationUsername != null) {
      json[r'httpAuthenticationUsername'] = httpAuthenticationUsername;
    }
    if (readTimeout != null) {
      json[r'readTimeout'] = readTimeout;
    }
    if (sslCertificate != null) {
      json[r'sslCertificate'] = sslCertificate;
    }
    if (url != null) {
      json[r'url'] = url;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (transport != null) {
      json[r'transport'] = transport;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  GenericMessengerConfiguration copyWith(
      {int? connectTimeout,
      HTTPHeaders? headers,
      String? httpAuthenticationPassword,
      String? httpAuthenticationUsername,
      int? readTimeout,
      String? sslCertificate,
      String? url,
      Map<String, dynamic>? data,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      String? transport,
      MessengerType? type}) {
    return GenericMessengerConfiguration(
      connectTimeout: connectTimeout ?? this.connectTimeout,
      headers: headers ?? this.headers,
      httpAuthenticationPassword:
          httpAuthenticationPassword ?? this.httpAuthenticationPassword,
      httpAuthenticationUsername:
          httpAuthenticationUsername ?? this.httpAuthenticationUsername,
      readTimeout: readTimeout ?? this.readTimeout,
      sslCertificate: sslCertificate ?? this.sslCertificate,
      url: url ?? this.url,
      data: data ?? this.data,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      transport: transport ?? this.transport,
      type: type ?? this.type,
    );
  }
}

class GoogleApplicationConfiguration {
  final String? buttonText;
  final String? clientId;
  final String? clientSecret;
  final IdentityProviderLoginMethod? loginMethod;
  final GoogleIdentityProviderProperties? properties;
  final String? scope;
  final Map<String, dynamic>? data;
  final bool createRegistration;

  GoogleApplicationConfiguration(
      {this.buttonText,
      this.clientId,
      this.clientSecret,
      this.loginMethod,
      this.properties,
      this.scope,
      this.data,
      bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory GoogleApplicationConfiguration.fromJson(Map<String, Object?> json) {
    return GoogleApplicationConfiguration(
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      loginMethod: json[r'loginMethod'] != null
          ? IdentityProviderLoginMethod.fromValue(
              json[r'loginMethod']! as String)
          : null,
      properties: json[r'properties'] != null
          ? GoogleIdentityProviderProperties.fromJson(
              json[r'properties']! as Map<String, Object?>)
          : null,
      scope: json[r'scope'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var loginMethod = this.loginMethod;
    var properties = this.properties;
    var scope = this.scope;
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (loginMethod != null) {
      json[r'loginMethod'] = loginMethod.value;
    }
    if (properties != null) {
      json[r'properties'] = properties.toJson();
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  GoogleApplicationConfiguration copyWith(
      {String? buttonText,
      String? clientId,
      String? clientSecret,
      IdentityProviderLoginMethod? loginMethod,
      GoogleIdentityProviderProperties? properties,
      String? scope,
      Map<String, dynamic>? data,
      bool? createRegistration}) {
    return GoogleApplicationConfiguration(
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      loginMethod: loginMethod ?? this.loginMethod,
      properties: properties ?? this.properties,
      scope: scope ?? this.scope,
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

/// Google social login provider.
class GoogleIdentityProvider {
  final String? buttonText;
  final String? clientId;
  final String? clientSecret;
  final IdentityProviderLoginMethod? loginMethod;
  final GoogleIdentityProviderProperties? properties;
  final String? scope;
  final Map<String, dynamic>? data;
  final Map<String, dynamic>? applicationConfiguration;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ProviderLambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final IdentityProviderLinkingStrategy? linkingStrategy;
  final String? name;
  final Map<String, dynamic>? tenantConfiguration;
  final IdentityProviderType? type;

  GoogleIdentityProvider(
      {this.buttonText,
      this.clientId,
      this.clientSecret,
      this.loginMethod,
      this.properties,
      this.scope,
      this.data,
      this.applicationConfiguration,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.linkingStrategy,
      this.name,
      this.tenantConfiguration,
      this.type})
      : debug = debug ?? false;

  factory GoogleIdentityProvider.fromJson(Map<String, Object?> json) {
    return GoogleIdentityProvider(
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      loginMethod: json[r'loginMethod'] != null
          ? IdentityProviderLoginMethod.fromValue(
              json[r'loginMethod']! as String)
          : null,
      properties: json[r'properties'] != null
          ? GoogleIdentityProviderProperties.fromJson(
              json[r'properties']! as Map<String, Object?>)
          : null,
      scope: json[r'scope'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      applicationConfiguration:
          json[r'applicationConfiguration'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? ProviderLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      linkingStrategy: json[r'linkingStrategy'] != null
          ? IdentityProviderLinkingStrategy.fromValue(
              json[r'linkingStrategy']! as String)
          : null,
      name: json[r'name'] as String?,
      tenantConfiguration:
          json[r'tenantConfiguration'] as Map<String, Object?>?,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var loginMethod = this.loginMethod;
    var properties = this.properties;
    var scope = this.scope;
    var data = this.data;
    var applicationConfiguration = this.applicationConfiguration;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var linkingStrategy = this.linkingStrategy;
    var name = this.name;
    var tenantConfiguration = this.tenantConfiguration;
    var type = this.type;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (loginMethod != null) {
      json[r'loginMethod'] = loginMethod.value;
    }
    if (properties != null) {
      json[r'properties'] = properties.toJson();
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (applicationConfiguration != null) {
      json[r'applicationConfiguration'] = applicationConfiguration;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (linkingStrategy != null) {
      json[r'linkingStrategy'] = linkingStrategy.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (tenantConfiguration != null) {
      json[r'tenantConfiguration'] = tenantConfiguration;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  GoogleIdentityProvider copyWith(
      {String? buttonText,
      String? clientId,
      String? clientSecret,
      IdentityProviderLoginMethod? loginMethod,
      GoogleIdentityProviderProperties? properties,
      String? scope,
      Map<String, dynamic>? data,
      Map<String, dynamic>? applicationConfiguration,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ProviderLambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      IdentityProviderLinkingStrategy? linkingStrategy,
      String? name,
      Map<String, dynamic>? tenantConfiguration,
      IdentityProviderType? type}) {
    return GoogleIdentityProvider(
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      loginMethod: loginMethod ?? this.loginMethod,
      properties: properties ?? this.properties,
      scope: scope ?? this.scope,
      data: data ?? this.data,
      applicationConfiguration:
          applicationConfiguration ?? this.applicationConfiguration,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      linkingStrategy: linkingStrategy ?? this.linkingStrategy,
      name: name ?? this.name,
      tenantConfiguration: tenantConfiguration ?? this.tenantConfiguration,
      type: type ?? this.type,
    );
  }
}

/// Google social login provider parameters.
class GoogleIdentityProviderProperties {
  final String? api;
  final String? button;

  GoogleIdentityProviderProperties({this.api, this.button});

  factory GoogleIdentityProviderProperties.fromJson(Map<String, Object?> json) {
    return GoogleIdentityProviderProperties(
      api: json[r'api'] as String?,
      button: json[r'button'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var api = this.api;
    var button = this.button;

    final json = <String, Object?>{};
    if (api != null) {
      json[r'api'] = api;
    }
    if (button != null) {
      json[r'button'] = button;
    }
    return json;
  }

  GoogleIdentityProviderProperties copyWith({String? api, String? button}) {
    return GoogleIdentityProviderProperties(
      api: api ?? this.api,
      button: button ?? this.button,
    );
  }
}

class Group {
  final Map<String, dynamic>? data;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final List<ApplicationRole> roles;
  final String? tenantId;

  Group(
      {this.data,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.name,
      List<ApplicationRole>? roles,
      this.tenantId})
      : roles = roles ?? [];

  factory Group.fromJson(Map<String, Object?> json) {
    return Group(
      data: json[r'data'] as Map<String, Object?>?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      roles: (json[r'roles'] as List<Object?>?)
              ?.map((i) => ApplicationRole.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      tenantId: json[r'tenantId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var roles = this.roles;
    var tenantId = this.tenantId;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'roles'] = roles.map((i) => i.toJson()).toList();
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    return json;
  }

  Group copyWith(
      {Map<String, dynamic>? data,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      List<ApplicationRole>? roles,
      String? tenantId}) {
    return Group(
      data: data ?? this.data,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      roles: roles ?? this.roles,
      tenantId: tenantId ?? this.tenantId,
    );
  }
}

/// Models the Group Created Event.
class GroupCreateCompleteEvent {
  final Group? group;

  GroupCreateCompleteEvent({this.group});

  factory GroupCreateCompleteEvent.fromJson(Map<String, Object?> json) {
    return GroupCreateCompleteEvent(
      group: json[r'group'] != null
          ? Group.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var group = this.group;

    final json = <String, Object?>{};
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    return json;
  }

  GroupCreateCompleteEvent copyWith({Group? group}) {
    return GroupCreateCompleteEvent(
      group: group ?? this.group,
    );
  }
}

/// Models the Group Create Event.
class GroupCreateEvent {
  final Group? group;

  GroupCreateEvent({this.group});

  factory GroupCreateEvent.fromJson(Map<String, Object?> json) {
    return GroupCreateEvent(
      group: json[r'group'] != null
          ? Group.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var group = this.group;

    final json = <String, Object?>{};
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    return json;
  }

  GroupCreateEvent copyWith({Group? group}) {
    return GroupCreateEvent(
      group: group ?? this.group,
    );
  }
}

/// Models the Group Create Complete Event.
class GroupDeleteCompleteEvent {
  final Group? group;

  GroupDeleteCompleteEvent({this.group});

  factory GroupDeleteCompleteEvent.fromJson(Map<String, Object?> json) {
    return GroupDeleteCompleteEvent(
      group: json[r'group'] != null
          ? Group.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var group = this.group;

    final json = <String, Object?>{};
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    return json;
  }

  GroupDeleteCompleteEvent copyWith({Group? group}) {
    return GroupDeleteCompleteEvent(
      group: group ?? this.group,
    );
  }
}

/// Models the Group Delete Event.
class GroupDeleteEvent {
  final Group? group;

  GroupDeleteEvent({this.group});

  factory GroupDeleteEvent.fromJson(Map<String, Object?> json) {
    return GroupDeleteEvent(
      group: json[r'group'] != null
          ? Group.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var group = this.group;

    final json = <String, Object?>{};
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    return json;
  }

  GroupDeleteEvent copyWith({Group? group}) {
    return GroupDeleteEvent(
      group: group ?? this.group,
    );
  }
}

/// A User's membership into a Group
class GroupMember {
  final Map<String, dynamic>? data;
  final String? groupId;
  final String? id;
  final ZonedDateTime? insertInstant;
  final User? user;
  final String? userId;

  GroupMember(
      {this.data,
      this.groupId,
      this.id,
      this.insertInstant,
      this.user,
      this.userId});

  factory GroupMember.fromJson(Map<String, Object?> json) {
    return GroupMember(
      data: json[r'data'] as Map<String, Object?>?,
      groupId: json[r'groupId'] as String?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
      userId: json[r'userId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var groupId = this.groupId;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var user = this.user;
    var userId = this.userId;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (groupId != null) {
      json[r'groupId'] = groupId;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    return json;
  }

  GroupMember copyWith(
      {Map<String, dynamic>? data,
      String? groupId,
      String? id,
      ZonedDateTime? insertInstant,
      User? user,
      String? userId}) {
    return GroupMember(
      data: data ?? this.data,
      groupId: groupId ?? this.groupId,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      user: user ?? this.user,
      userId: userId ?? this.userId,
    );
  }
}

/// Models the Group Member Add Complete Event.
class GroupMemberAddCompleteEvent {
  final List<GroupMember> members;
  final Group? group;

  GroupMemberAddCompleteEvent({List<GroupMember>? members, this.group})
      : members = members ?? [];

  factory GroupMemberAddCompleteEvent.fromJson(Map<String, Object?> json) {
    return GroupMemberAddCompleteEvent(
      members: (json[r'members'] as List<Object?>?)
              ?.map((i) =>
                  GroupMember.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      group: json[r'group'] != null
          ? Group.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var members = this.members;
    var group = this.group;

    final json = <String, Object?>{};
    json[r'members'] = members.map((i) => i.toJson()).toList();
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    return json;
  }

  GroupMemberAddCompleteEvent copyWith(
      {List<GroupMember>? members, Group? group}) {
    return GroupMemberAddCompleteEvent(
      members: members ?? this.members,
      group: group ?? this.group,
    );
  }
}

/// Models the Group Member Add Event.
class GroupMemberAddEvent {
  final List<GroupMember> members;
  final Group? group;

  GroupMemberAddEvent({List<GroupMember>? members, this.group})
      : members = members ?? [];

  factory GroupMemberAddEvent.fromJson(Map<String, Object?> json) {
    return GroupMemberAddEvent(
      members: (json[r'members'] as List<Object?>?)
              ?.map((i) =>
                  GroupMember.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      group: json[r'group'] != null
          ? Group.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var members = this.members;
    var group = this.group;

    final json = <String, Object?>{};
    json[r'members'] = members.map((i) => i.toJson()).toList();
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    return json;
  }

  GroupMemberAddEvent copyWith({List<GroupMember>? members, Group? group}) {
    return GroupMemberAddEvent(
      members: members ?? this.members,
      group: group ?? this.group,
    );
  }
}

/// Models the Group Member Remove Complete Event.
class GroupMemberRemoveCompleteEvent {
  final List<GroupMember> members;
  final Group? group;

  GroupMemberRemoveCompleteEvent({List<GroupMember>? members, this.group})
      : members = members ?? [];

  factory GroupMemberRemoveCompleteEvent.fromJson(Map<String, Object?> json) {
    return GroupMemberRemoveCompleteEvent(
      members: (json[r'members'] as List<Object?>?)
              ?.map((i) =>
                  GroupMember.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      group: json[r'group'] != null
          ? Group.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var members = this.members;
    var group = this.group;

    final json = <String, Object?>{};
    json[r'members'] = members.map((i) => i.toJson()).toList();
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    return json;
  }

  GroupMemberRemoveCompleteEvent copyWith(
      {List<GroupMember>? members, Group? group}) {
    return GroupMemberRemoveCompleteEvent(
      members: members ?? this.members,
      group: group ?? this.group,
    );
  }
}

/// Models the Group Member Remove Event.
class GroupMemberRemoveEvent {
  final List<GroupMember> members;
  final Group? group;

  GroupMemberRemoveEvent({List<GroupMember>? members, this.group})
      : members = members ?? [];

  factory GroupMemberRemoveEvent.fromJson(Map<String, Object?> json) {
    return GroupMemberRemoveEvent(
      members: (json[r'members'] as List<Object?>?)
              ?.map((i) =>
                  GroupMember.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      group: json[r'group'] != null
          ? Group.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var members = this.members;
    var group = this.group;

    final json = <String, Object?>{};
    json[r'members'] = members.map((i) => i.toJson()).toList();
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    return json;
  }

  GroupMemberRemoveEvent copyWith({List<GroupMember>? members, Group? group}) {
    return GroupMemberRemoveEvent(
      members: members ?? this.members,
      group: group ?? this.group,
    );
  }
}

/// Search criteria for Group Members
class GroupMemberSearchCriteria {
  final String? groupId;
  final String? tenantId;
  final String? userId;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  GroupMemberSearchCriteria(
      {this.groupId,
      this.tenantId,
      this.userId,
      this.numberOfResults,
      this.orderBy,
      this.startRow});

  factory GroupMemberSearchCriteria.fromJson(Map<String, Object?> json) {
    return GroupMemberSearchCriteria(
      groupId: json[r'groupId'] as String?,
      tenantId: json[r'tenantId'] as String?,
      userId: json[r'userId'] as String?,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var groupId = this.groupId;
    var tenantId = this.tenantId;
    var userId = this.userId;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (groupId != null) {
      json[r'groupId'] = groupId;
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  GroupMemberSearchCriteria copyWith(
      {String? groupId,
      String? tenantId,
      String? userId,
      int? numberOfResults,
      String? orderBy,
      int? startRow}) {
    return GroupMemberSearchCriteria(
      groupId: groupId ?? this.groupId,
      tenantId: tenantId ?? this.tenantId,
      userId: userId ?? this.userId,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Search request for Group Members.
class GroupMemberSearchRequest {
  final GroupMemberSearchCriteria? search;

  GroupMemberSearchRequest({this.search});

  factory GroupMemberSearchRequest.fromJson(Map<String, Object?> json) {
    return GroupMemberSearchRequest(
      search: json[r'search'] != null
          ? GroupMemberSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  GroupMemberSearchRequest copyWith({GroupMemberSearchCriteria? search}) {
    return GroupMemberSearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Search response for Group Members
class GroupMemberSearchResponse {
  final List<GroupMember> members;
  final int? total;

  GroupMemberSearchResponse({List<GroupMember>? members, this.total})
      : members = members ?? [];

  factory GroupMemberSearchResponse.fromJson(Map<String, Object?> json) {
    return GroupMemberSearchResponse(
      members: (json[r'members'] as List<Object?>?)
              ?.map((i) =>
                  GroupMember.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var members = this.members;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'members'] = members.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  GroupMemberSearchResponse copyWith({List<GroupMember>? members, int? total}) {
    return GroupMemberSearchResponse(
      members: members ?? this.members,
      total: total ?? this.total,
    );
  }
}

/// Models the Group Member Update Complete Event.
class GroupMemberUpdateCompleteEvent {
  final List<GroupMember> members;
  final Group? group;

  GroupMemberUpdateCompleteEvent({List<GroupMember>? members, this.group})
      : members = members ?? [];

  factory GroupMemberUpdateCompleteEvent.fromJson(Map<String, Object?> json) {
    return GroupMemberUpdateCompleteEvent(
      members: (json[r'members'] as List<Object?>?)
              ?.map((i) =>
                  GroupMember.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      group: json[r'group'] != null
          ? Group.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var members = this.members;
    var group = this.group;

    final json = <String, Object?>{};
    json[r'members'] = members.map((i) => i.toJson()).toList();
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    return json;
  }

  GroupMemberUpdateCompleteEvent copyWith(
      {List<GroupMember>? members, Group? group}) {
    return GroupMemberUpdateCompleteEvent(
      members: members ?? this.members,
      group: group ?? this.group,
    );
  }
}

/// Models the Group Member Update Event.
class GroupMemberUpdateEvent {
  final List<GroupMember> members;
  final Group? group;

  GroupMemberUpdateEvent({List<GroupMember>? members, this.group})
      : members = members ?? [];

  factory GroupMemberUpdateEvent.fromJson(Map<String, Object?> json) {
    return GroupMemberUpdateEvent(
      members: (json[r'members'] as List<Object?>?)
              ?.map((i) =>
                  GroupMember.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      group: json[r'group'] != null
          ? Group.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var members = this.members;
    var group = this.group;

    final json = <String, Object?>{};
    json[r'members'] = members.map((i) => i.toJson()).toList();
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    return json;
  }

  GroupMemberUpdateEvent copyWith({List<GroupMember>? members, Group? group}) {
    return GroupMemberUpdateEvent(
      members: members ?? this.members,
      group: group ?? this.group,
    );
  }
}

/// Group API request object.
class GroupRequest {
  final Group? group;
  final List<String> roleIds;

  GroupRequest({this.group, List<String>? roleIds}) : roleIds = roleIds ?? [];

  factory GroupRequest.fromJson(Map<String, Object?> json) {
    return GroupRequest(
      group: json[r'group'] != null
          ? Group.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
      roleIds: (json[r'roleIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var group = this.group;
    var roleIds = this.roleIds;

    final json = <String, Object?>{};
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    json[r'roleIds'] = roleIds;
    return json;
  }

  GroupRequest copyWith({Group? group, List<String>? roleIds}) {
    return GroupRequest(
      group: group ?? this.group,
      roleIds: roleIds ?? this.roleIds,
    );
  }
}

/// Group API response object.
class GroupResponse {
  final Group? group;
  final List<Group> groups;

  GroupResponse({this.group, List<Group>? groups}) : groups = groups ?? [];

  factory GroupResponse.fromJson(Map<String, Object?> json) {
    return GroupResponse(
      group: json[r'group'] != null
          ? Group.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
      groups: (json[r'groups'] as List<Object?>?)
              ?.map(
                  (i) => Group.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var group = this.group;
    var groups = this.groups;

    final json = <String, Object?>{};
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    json[r'groups'] = groups.map((i) => i.toJson()).toList();
    return json;
  }

  GroupResponse copyWith({Group? group, List<Group>? groups}) {
    return GroupResponse(
      group: group ?? this.group,
      groups: groups ?? this.groups,
    );
  }
}

/// Search criteria for Groups
class GroupSearchCriteria {
  final String? name;
  final String? tenantId;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  GroupSearchCriteria(
      {this.name,
      this.tenantId,
      this.numberOfResults,
      this.orderBy,
      this.startRow});

  factory GroupSearchCriteria.fromJson(Map<String, Object?> json) {
    return GroupSearchCriteria(
      name: json[r'name'] as String?,
      tenantId: json[r'tenantId'] as String?,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var tenantId = this.tenantId;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  GroupSearchCriteria copyWith(
      {String? name,
      String? tenantId,
      int? numberOfResults,
      String? orderBy,
      int? startRow}) {
    return GroupSearchCriteria(
      name: name ?? this.name,
      tenantId: tenantId ?? this.tenantId,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Search request for Groups.
class GroupSearchRequest {
  final GroupSearchCriteria? search;

  GroupSearchRequest({this.search});

  factory GroupSearchRequest.fromJson(Map<String, Object?> json) {
    return GroupSearchRequest(
      search: json[r'search'] != null
          ? GroupSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  GroupSearchRequest copyWith({GroupSearchCriteria? search}) {
    return GroupSearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Search response for Groups
class GroupSearchResponse {
  final List<Group> groups;
  final int? total;

  GroupSearchResponse({List<Group>? groups, this.total})
      : groups = groups ?? [];

  factory GroupSearchResponse.fromJson(Map<String, Object?> json) {
    return GroupSearchResponse(
      groups: (json[r'groups'] as List<Object?>?)
              ?.map(
                  (i) => Group.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var groups = this.groups;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'groups'] = groups.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  GroupSearchResponse copyWith({List<Group>? groups, int? total}) {
    return GroupSearchResponse(
      groups: groups ?? this.groups,
      total: total ?? this.total,
    );
  }
}

/// Models the Group Update Complete Event.
class GroupUpdateCompleteEvent {
  final Group? original;
  final Group? group;

  GroupUpdateCompleteEvent({this.original, this.group});

  factory GroupUpdateCompleteEvent.fromJson(Map<String, Object?> json) {
    return GroupUpdateCompleteEvent(
      original: json[r'original'] != null
          ? Group.fromJson(json[r'original']! as Map<String, Object?>)
          : null,
      group: json[r'group'] != null
          ? Group.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var original = this.original;
    var group = this.group;

    final json = <String, Object?>{};
    if (original != null) {
      json[r'original'] = original.toJson();
    }
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    return json;
  }

  GroupUpdateCompleteEvent copyWith({Group? original, Group? group}) {
    return GroupUpdateCompleteEvent(
      original: original ?? this.original,
      group: group ?? this.group,
    );
  }
}

/// Models the Group Update Event.
class GroupUpdateEvent {
  final Group? original;
  final Group? group;

  GroupUpdateEvent({this.original, this.group});

  factory GroupUpdateEvent.fromJson(Map<String, Object?> json) {
    return GroupUpdateEvent(
      original: json[r'original'] != null
          ? Group.fromJson(json[r'original']! as Map<String, Object?>)
          : null,
      group: json[r'group'] != null
          ? Group.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var original = this.original;
    var group = this.group;

    final json = <String, Object?>{};
    if (original != null) {
      json[r'original'] = original.toJson();
    }
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    return json;
  }

  GroupUpdateEvent copyWith({Group? original, Group? group}) {
    return GroupUpdateEvent(
      original: original ?? this.original,
      group: group ?? this.group,
    );
  }
}

/// Type for webhook headers.
class HTTPHeaders {
  HTTPHeaders();

  factory HTTPHeaders.fromJson(Map<String, Object?> json) {
    return HTTPHeaders();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class HYPRApplicationConfiguration {
  final String? relyingPartyApplicationId;
  final String? relyingPartyUrl;
  final Map<String, dynamic>? data;
  final bool createRegistration;

  HYPRApplicationConfiguration(
      {this.relyingPartyApplicationId,
      this.relyingPartyUrl,
      this.data,
      bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory HYPRApplicationConfiguration.fromJson(Map<String, Object?> json) {
    return HYPRApplicationConfiguration(
      relyingPartyApplicationId: json[r'relyingPartyApplicationId'] as String?,
      relyingPartyUrl: json[r'relyingPartyURL'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var relyingPartyApplicationId = this.relyingPartyApplicationId;
    var relyingPartyUrl = this.relyingPartyUrl;
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (relyingPartyApplicationId != null) {
      json[r'relyingPartyApplicationId'] = relyingPartyApplicationId;
    }
    if (relyingPartyUrl != null) {
      json[r'relyingPartyURL'] = relyingPartyUrl;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  HYPRApplicationConfiguration copyWith(
      {String? relyingPartyApplicationId,
      String? relyingPartyUrl,
      Map<String, dynamic>? data,
      bool? createRegistration}) {
    return HYPRApplicationConfiguration(
      relyingPartyApplicationId:
          relyingPartyApplicationId ?? this.relyingPartyApplicationId,
      relyingPartyUrl: relyingPartyUrl ?? this.relyingPartyUrl,
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

class HYPRIdentityProvider {
  final String? relyingPartyApplicationId;
  final String? relyingPartyUrl;
  final Map<String, dynamic>? data;
  final Map<String, dynamic>? applicationConfiguration;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ProviderLambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final IdentityProviderLinkingStrategy? linkingStrategy;
  final String? name;
  final Map<String, dynamic>? tenantConfiguration;
  final IdentityProviderType? type;

  HYPRIdentityProvider(
      {this.relyingPartyApplicationId,
      this.relyingPartyUrl,
      this.data,
      this.applicationConfiguration,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.linkingStrategy,
      this.name,
      this.tenantConfiguration,
      this.type})
      : debug = debug ?? false;

  factory HYPRIdentityProvider.fromJson(Map<String, Object?> json) {
    return HYPRIdentityProvider(
      relyingPartyApplicationId: json[r'relyingPartyApplicationId'] as String?,
      relyingPartyUrl: json[r'relyingPartyURL'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      applicationConfiguration:
          json[r'applicationConfiguration'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? ProviderLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      linkingStrategy: json[r'linkingStrategy'] != null
          ? IdentityProviderLinkingStrategy.fromValue(
              json[r'linkingStrategy']! as String)
          : null,
      name: json[r'name'] as String?,
      tenantConfiguration:
          json[r'tenantConfiguration'] as Map<String, Object?>?,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var relyingPartyApplicationId = this.relyingPartyApplicationId;
    var relyingPartyUrl = this.relyingPartyUrl;
    var data = this.data;
    var applicationConfiguration = this.applicationConfiguration;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var linkingStrategy = this.linkingStrategy;
    var name = this.name;
    var tenantConfiguration = this.tenantConfiguration;
    var type = this.type;

    final json = <String, Object?>{};
    if (relyingPartyApplicationId != null) {
      json[r'relyingPartyApplicationId'] = relyingPartyApplicationId;
    }
    if (relyingPartyUrl != null) {
      json[r'relyingPartyURL'] = relyingPartyUrl;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (applicationConfiguration != null) {
      json[r'applicationConfiguration'] = applicationConfiguration;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (linkingStrategy != null) {
      json[r'linkingStrategy'] = linkingStrategy.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (tenantConfiguration != null) {
      json[r'tenantConfiguration'] = tenantConfiguration;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  HYPRIdentityProvider copyWith(
      {String? relyingPartyApplicationId,
      String? relyingPartyUrl,
      Map<String, dynamic>? data,
      Map<String, dynamic>? applicationConfiguration,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ProviderLambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      IdentityProviderLinkingStrategy? linkingStrategy,
      String? name,
      Map<String, dynamic>? tenantConfiguration,
      IdentityProviderType? type}) {
    return HYPRIdentityProvider(
      relyingPartyApplicationId:
          relyingPartyApplicationId ?? this.relyingPartyApplicationId,
      relyingPartyUrl: relyingPartyUrl ?? this.relyingPartyUrl,
      data: data ?? this.data,
      applicationConfiguration:
          applicationConfiguration ?? this.applicationConfiguration,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      linkingStrategy: linkingStrategy ?? this.linkingStrategy,
      name: name ?? this.name,
      tenantConfiguration: tenantConfiguration ?? this.tenantConfiguration,
      type: type ?? this.type,
    );
  }
}

class HistoryItem {
  final String? actionerUserId;
  final String? comment;
  final ZonedDateTime? createInstant;
  final ZonedDateTime? expiry;

  HistoryItem(
      {this.actionerUserId, this.comment, this.createInstant, this.expiry});

  factory HistoryItem.fromJson(Map<String, Object?> json) {
    return HistoryItem(
      actionerUserId: json[r'actionerUserId'] as String?,
      comment: json[r'comment'] as String?,
      createInstant:
          (json[r'createInstant'] as num?)?.toInt() as ZonedDateTime?,
      expiry: (json[r'expiry'] as num?)?.toInt() as ZonedDateTime?,
    );
  }

  Map<String, Object?> toJson() {
    var actionerUserId = this.actionerUserId;
    var comment = this.comment;
    var createInstant = this.createInstant;
    var expiry = this.expiry;

    final json = <String, Object?>{};
    if (actionerUserId != null) {
      json[r'actionerUserId'] = actionerUserId;
    }
    if (comment != null) {
      json[r'comment'] = comment;
    }
    if (createInstant != null) {
      json[r'createInstant'] = createInstant.toJson();
    }
    if (expiry != null) {
      json[r'expiry'] = expiry.toJson();
    }
    return json;
  }

  HistoryItem copyWith(
      {String? actionerUserId,
      String? comment,
      ZonedDateTime? createInstant,
      ZonedDateTime? expiry}) {
    return HistoryItem(
      actionerUserId: actionerUserId ?? this.actionerUserId,
      comment: comment ?? this.comment,
      createInstant: createInstant ?? this.createInstant,
      expiry: expiry ?? this.expiry,
    );
  }
}

class IPAccessControlEntry {
  final IPAccessControlEntryAction? action;
  final String? endIpAddress;
  final String? startIpAddress;

  IPAccessControlEntry({this.action, this.endIpAddress, this.startIpAddress});

  factory IPAccessControlEntry.fromJson(Map<String, Object?> json) {
    return IPAccessControlEntry(
      action: json[r'action'] != null
          ? IPAccessControlEntryAction.fromValue(json[r'action']! as String)
          : null,
      endIpAddress: json[r'endIPAddress'] as String?,
      startIpAddress: json[r'startIPAddress'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var action = this.action;
    var endIpAddress = this.endIpAddress;
    var startIpAddress = this.startIpAddress;

    final json = <String, Object?>{};
    if (action != null) {
      json[r'action'] = action.value;
    }
    if (endIpAddress != null) {
      json[r'endIPAddress'] = endIpAddress;
    }
    if (startIpAddress != null) {
      json[r'startIPAddress'] = startIpAddress;
    }
    return json;
  }

  IPAccessControlEntry copyWith(
      {IPAccessControlEntryAction? action,
      String? endIpAddress,
      String? startIpAddress}) {
    return IPAccessControlEntry(
      action: action ?? this.action,
      endIpAddress: endIpAddress ?? this.endIpAddress,
      startIpAddress: startIpAddress ?? this.startIpAddress,
    );
  }
}

class IPAccessControlList {
  final Map<String, dynamic>? data;
  final List<IPAccessControlEntry> entries;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;

  IPAccessControlList(
      {this.data,
      List<IPAccessControlEntry>? entries,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.name})
      : entries = entries ?? [];

  factory IPAccessControlList.fromJson(Map<String, Object?> json) {
    return IPAccessControlList(
      data: json[r'data'] as Map<String, Object?>?,
      entries: (json[r'entries'] as List<Object?>?)
              ?.map((i) => IPAccessControlEntry.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var entries = this.entries;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'entries'] = entries.map((i) => i.toJson()).toList();
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  IPAccessControlList copyWith(
      {Map<String, dynamic>? data,
      List<IPAccessControlEntry>? entries,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      String? name}) {
    return IPAccessControlList(
      data: data ?? this.data,
      entries: entries ?? this.entries,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
    );
  }
}

class IPAccessControlListRequest {
  final IPAccessControlList? ipAccessControlList;

  IPAccessControlListRequest({this.ipAccessControlList});

  factory IPAccessControlListRequest.fromJson(Map<String, Object?> json) {
    return IPAccessControlListRequest(
      ipAccessControlList: json[r'ipAccessControlList'] != null
          ? IPAccessControlList.fromJson(
              json[r'ipAccessControlList']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var ipAccessControlList = this.ipAccessControlList;

    final json = <String, Object?>{};
    if (ipAccessControlList != null) {
      json[r'ipAccessControlList'] = ipAccessControlList.toJson();
    }
    return json;
  }

  IPAccessControlListRequest copyWith(
      {IPAccessControlList? ipAccessControlList}) {
    return IPAccessControlListRequest(
      ipAccessControlList: ipAccessControlList ?? this.ipAccessControlList,
    );
  }
}

class IPAccessControlListResponse {
  final IPAccessControlList? ipAccessControlList;
  final List<IPAccessControlList> ipAccessControlLists;

  IPAccessControlListResponse(
      {this.ipAccessControlList,
      List<IPAccessControlList>? ipAccessControlLists})
      : ipAccessControlLists = ipAccessControlLists ?? [];

  factory IPAccessControlListResponse.fromJson(Map<String, Object?> json) {
    return IPAccessControlListResponse(
      ipAccessControlList: json[r'ipAccessControlList'] != null
          ? IPAccessControlList.fromJson(
              json[r'ipAccessControlList']! as Map<String, Object?>)
          : null,
      ipAccessControlLists: (json[r'ipAccessControlLists'] as List<Object?>?)
              ?.map((i) => IPAccessControlList.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var ipAccessControlList = this.ipAccessControlList;
    var ipAccessControlLists = this.ipAccessControlLists;

    final json = <String, Object?>{};
    if (ipAccessControlList != null) {
      json[r'ipAccessControlList'] = ipAccessControlList.toJson();
    }
    json[r'ipAccessControlLists'] =
        ipAccessControlLists.map((i) => i.toJson()).toList();
    return json;
  }

  IPAccessControlListResponse copyWith(
      {IPAccessControlList? ipAccessControlList,
      List<IPAccessControlList>? ipAccessControlLists}) {
    return IPAccessControlListResponse(
      ipAccessControlList: ipAccessControlList ?? this.ipAccessControlList,
      ipAccessControlLists: ipAccessControlLists ?? this.ipAccessControlLists,
    );
  }
}

class IPAccessControlListSearchCriteria {
  final String? name;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  IPAccessControlListSearchCriteria(
      {this.name, this.numberOfResults, this.orderBy, this.startRow});

  factory IPAccessControlListSearchCriteria.fromJson(
      Map<String, Object?> json) {
    return IPAccessControlListSearchCriteria(
      name: json[r'name'] as String?,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  IPAccessControlListSearchCriteria copyWith(
      {String? name, int? numberOfResults, String? orderBy, int? startRow}) {
    return IPAccessControlListSearchCriteria(
      name: name ?? this.name,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Search request for IP ACLs .
class IPAccessControlListSearchRequest {
  final IPAccessControlListSearchCriteria? search;

  IPAccessControlListSearchRequest({this.search});

  factory IPAccessControlListSearchRequest.fromJson(Map<String, Object?> json) {
    return IPAccessControlListSearchRequest(
      search: json[r'search'] != null
          ? IPAccessControlListSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  IPAccessControlListSearchRequest copyWith(
      {IPAccessControlListSearchCriteria? search}) {
    return IPAccessControlListSearchRequest(
      search: search ?? this.search,
    );
  }
}

class IPAccessControlListSearchResponse {
  final List<IPAccessControlList> ipAccessControlLists;
  final int? total;

  IPAccessControlListSearchResponse(
      {List<IPAccessControlList>? ipAccessControlLists, this.total})
      : ipAccessControlLists = ipAccessControlLists ?? [];

  factory IPAccessControlListSearchResponse.fromJson(
      Map<String, Object?> json) {
    return IPAccessControlListSearchResponse(
      ipAccessControlLists: (json[r'ipAccessControlLists'] as List<Object?>?)
              ?.map((i) => IPAccessControlList.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var ipAccessControlLists = this.ipAccessControlLists;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'ipAccessControlLists'] =
        ipAccessControlLists.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  IPAccessControlListSearchResponse copyWith(
      {List<IPAccessControlList>? ipAccessControlLists, int? total}) {
    return IPAccessControlListSearchResponse(
      ipAccessControlLists: ipAccessControlLists ?? this.ipAccessControlLists,
      total: total ?? this.total,
    );
  }
}

class IdentityProviderDetails {
  final List<String> applicationIds;
  final String? id;
  final String? idpEndpoint;
  final String? name;
  final IdentityProviderOauth2Configuration? oauth2;
  final IdentityProviderType? type;

  IdentityProviderDetails(
      {List<String>? applicationIds,
      this.id,
      this.idpEndpoint,
      this.name,
      this.oauth2,
      this.type})
      : applicationIds = applicationIds ?? [];

  factory IdentityProviderDetails.fromJson(Map<String, Object?> json) {
    return IdentityProviderDetails(
      applicationIds: (json[r'applicationIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      id: json[r'id'] as String?,
      idpEndpoint: json[r'idpEndpoint'] as String?,
      name: json[r'name'] as String?,
      oauth2: json[r'oauth2'] != null
          ? IdentityProviderOauth2Configuration.fromJson(
              json[r'oauth2']! as Map<String, Object?>)
          : null,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationIds = this.applicationIds;
    var id = this.id;
    var idpEndpoint = this.idpEndpoint;
    var name = this.name;
    var oauth2 = this.oauth2;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'applicationIds'] = applicationIds;
    if (id != null) {
      json[r'id'] = id;
    }
    if (idpEndpoint != null) {
      json[r'idpEndpoint'] = idpEndpoint;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (oauth2 != null) {
      json[r'oauth2'] = oauth2.toJson();
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  IdentityProviderDetails copyWith(
      {List<String>? applicationIds,
      String? id,
      String? idpEndpoint,
      String? name,
      IdentityProviderOauth2Configuration? oauth2,
      IdentityProviderType? type}) {
    return IdentityProviderDetails(
      applicationIds: applicationIds ?? this.applicationIds,
      id: id ?? this.id,
      idpEndpoint: idpEndpoint ?? this.idpEndpoint,
      name: name ?? this.name,
      oauth2: oauth2 ?? this.oauth2,
      type: type ?? this.type,
    );
  }
}

class IdentityProviderField {
  IdentityProviderField();

  factory IdentityProviderField.fromJson(Map<String, Object?> json) {
    return IdentityProviderField();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class IdentityProviderLimitUserLinkingPolicy {
  final int? maximumLinks;
  final bool enabled;

  IdentityProviderLimitUserLinkingPolicy({this.maximumLinks, bool? enabled})
      : enabled = enabled ?? false;

  factory IdentityProviderLimitUserLinkingPolicy.fromJson(
      Map<String, Object?> json) {
    return IdentityProviderLimitUserLinkingPolicy(
      maximumLinks: (json[r'maximumLinks'] as num?)?.toInt(),
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var maximumLinks = this.maximumLinks;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (maximumLinks != null) {
      json[r'maximumLinks'] = maximumLinks;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  IdentityProviderLimitUserLinkingPolicy copyWith(
      {int? maximumLinks, bool? enabled}) {
    return IdentityProviderLimitUserLinkingPolicy(
      maximumLinks: maximumLinks ?? this.maximumLinks,
      enabled: enabled ?? this.enabled,
    );
  }
}

class IdentityProviderLink {
  final Map<String, dynamic>? data;
  final String? displayName;
  final String? identityProviderId;
  final String? identityProviderName;
  final IdentityProviderType? identityProviderType;
  final String? identityProviderUserId;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastLoginInstant;
  final String? tenantId;
  final String? token;
  final String? userId;

  IdentityProviderLink(
      {this.data,
      this.displayName,
      this.identityProviderId,
      this.identityProviderName,
      this.identityProviderType,
      this.identityProviderUserId,
      this.insertInstant,
      this.lastLoginInstant,
      this.tenantId,
      this.token,
      this.userId});

  factory IdentityProviderLink.fromJson(Map<String, Object?> json) {
    return IdentityProviderLink(
      data: json[r'data'] as Map<String, Object?>?,
      displayName: json[r'displayName'] as String?,
      identityProviderId: json[r'identityProviderId'] as String?,
      identityProviderName: json[r'identityProviderName'] as String?,
      identityProviderType: json[r'identityProviderType'] != null
          ? IdentityProviderType.fromValue(
              json[r'identityProviderType']! as String)
          : null,
      identityProviderUserId: json[r'identityProviderUserId'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastLoginInstant:
          (json[r'lastLoginInstant'] as num?)?.toInt() as ZonedDateTime?,
      tenantId: json[r'tenantId'] as String?,
      token: json[r'token'] as String?,
      userId: json[r'userId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var displayName = this.displayName;
    var identityProviderId = this.identityProviderId;
    var identityProviderName = this.identityProviderName;
    var identityProviderType = this.identityProviderType;
    var identityProviderUserId = this.identityProviderUserId;
    var insertInstant = this.insertInstant;
    var lastLoginInstant = this.lastLoginInstant;
    var tenantId = this.tenantId;
    var token = this.token;
    var userId = this.userId;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (identityProviderId != null) {
      json[r'identityProviderId'] = identityProviderId;
    }
    if (identityProviderName != null) {
      json[r'identityProviderName'] = identityProviderName;
    }
    if (identityProviderType != null) {
      json[r'identityProviderType'] = identityProviderType.value;
    }
    if (identityProviderUserId != null) {
      json[r'identityProviderUserId'] = identityProviderUserId;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastLoginInstant != null) {
      json[r'lastLoginInstant'] = lastLoginInstant.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (token != null) {
      json[r'token'] = token;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    return json;
  }

  IdentityProviderLink copyWith(
      {Map<String, dynamic>? data,
      String? displayName,
      String? identityProviderId,
      String? identityProviderName,
      IdentityProviderType? identityProviderType,
      String? identityProviderUserId,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastLoginInstant,
      String? tenantId,
      String? token,
      String? userId}) {
    return IdentityProviderLink(
      data: data ?? this.data,
      displayName: displayName ?? this.displayName,
      identityProviderId: identityProviderId ?? this.identityProviderId,
      identityProviderName: identityProviderName ?? this.identityProviderName,
      identityProviderType: identityProviderType ?? this.identityProviderType,
      identityProviderUserId:
          identityProviderUserId ?? this.identityProviderUserId,
      insertInstant: insertInstant ?? this.insertInstant,
      lastLoginInstant: lastLoginInstant ?? this.lastLoginInstant,
      tenantId: tenantId ?? this.tenantId,
      token: token ?? this.token,
      userId: userId ?? this.userId,
    );
  }
}

class IdentityProviderLinkRequest {
  final IdentityProviderLink? identityProviderLink;
  final String? pendingIdpLinkId;
  final EventInfo? eventInfo;

  IdentityProviderLinkRequest(
      {this.identityProviderLink, this.pendingIdpLinkId, this.eventInfo});

  factory IdentityProviderLinkRequest.fromJson(Map<String, Object?> json) {
    return IdentityProviderLinkRequest(
      identityProviderLink: json[r'identityProviderLink'] != null
          ? IdentityProviderLink.fromJson(
              json[r'identityProviderLink']! as Map<String, Object?>)
          : null,
      pendingIdpLinkId: json[r'pendingIdPLinkId'] as String?,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var identityProviderLink = this.identityProviderLink;
    var pendingIdpLinkId = this.pendingIdpLinkId;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (identityProviderLink != null) {
      json[r'identityProviderLink'] = identityProviderLink.toJson();
    }
    if (pendingIdpLinkId != null) {
      json[r'pendingIdPLinkId'] = pendingIdpLinkId;
    }
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  IdentityProviderLinkRequest copyWith(
      {IdentityProviderLink? identityProviderLink,
      String? pendingIdpLinkId,
      EventInfo? eventInfo}) {
    return IdentityProviderLinkRequest(
      identityProviderLink: identityProviderLink ?? this.identityProviderLink,
      pendingIdpLinkId: pendingIdpLinkId ?? this.pendingIdpLinkId,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

class IdentityProviderLinkResponse {
  final IdentityProviderLink? identityProviderLink;
  final List<IdentityProviderLink> identityProviderLinks;

  IdentityProviderLinkResponse(
      {this.identityProviderLink,
      List<IdentityProviderLink>? identityProviderLinks})
      : identityProviderLinks = identityProviderLinks ?? [];

  factory IdentityProviderLinkResponse.fromJson(Map<String, Object?> json) {
    return IdentityProviderLinkResponse(
      identityProviderLink: json[r'identityProviderLink'] != null
          ? IdentityProviderLink.fromJson(
              json[r'identityProviderLink']! as Map<String, Object?>)
          : null,
      identityProviderLinks: (json[r'identityProviderLinks'] as List<Object?>?)
              ?.map((i) => IdentityProviderLink.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var identityProviderLink = this.identityProviderLink;
    var identityProviderLinks = this.identityProviderLinks;

    final json = <String, Object?>{};
    if (identityProviderLink != null) {
      json[r'identityProviderLink'] = identityProviderLink.toJson();
    }
    json[r'identityProviderLinks'] =
        identityProviderLinks.map((i) => i.toJson()).toList();
    return json;
  }

  IdentityProviderLinkResponse copyWith(
      {IdentityProviderLink? identityProviderLink,
      List<IdentityProviderLink>? identityProviderLinks}) {
    return IdentityProviderLinkResponse(
      identityProviderLink: identityProviderLink ?? this.identityProviderLink,
      identityProviderLinks:
          identityProviderLinks ?? this.identityProviderLinks,
    );
  }
}

/// Login API request object used for login to third-party systems (i.e. Login
/// with Facebook).
class IdentityProviderLoginRequest {
  final Map<String, dynamic>? data;
  final String? identityProviderId;
  final bool noLink;
  final String? encodedJwt;
  final String? applicationId;
  final String? ipAddress;
  final MetaData? metaData;
  final bool newDevice;
  final bool noJwt;

  IdentityProviderLoginRequest(
      {this.data,
      this.identityProviderId,
      bool? noLink,
      this.encodedJwt,
      this.applicationId,
      this.ipAddress,
      this.metaData,
      bool? newDevice,
      bool? noJwt})
      : noLink = noLink ?? false,
        newDevice = newDevice ?? false,
        noJwt = noJwt ?? false;

  factory IdentityProviderLoginRequest.fromJson(Map<String, Object?> json) {
    return IdentityProviderLoginRequest(
      data: json[r'data'] as Map<String, Object?>?,
      identityProviderId: json[r'identityProviderId'] as String?,
      noLink: json[r'noLink'] as bool? ?? false,
      encodedJwt: json[r'encodedJWT'] as String?,
      applicationId: json[r'applicationId'] as String?,
      ipAddress: json[r'ipAddress'] as String?,
      metaData: json[r'metaData'] != null
          ? MetaData.fromJson(json[r'metaData']! as Map<String, Object?>)
          : null,
      newDevice: json[r'newDevice'] as bool? ?? false,
      noJwt: json[r'noJWT'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var identityProviderId = this.identityProviderId;
    var noLink = this.noLink;
    var encodedJwt = this.encodedJwt;
    var applicationId = this.applicationId;
    var ipAddress = this.ipAddress;
    var metaData = this.metaData;
    var newDevice = this.newDevice;
    var noJwt = this.noJwt;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (identityProviderId != null) {
      json[r'identityProviderId'] = identityProviderId;
    }
    json[r'noLink'] = noLink;
    if (encodedJwt != null) {
      json[r'encodedJWT'] = encodedJwt;
    }
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (ipAddress != null) {
      json[r'ipAddress'] = ipAddress;
    }
    if (metaData != null) {
      json[r'metaData'] = metaData.toJson();
    }
    json[r'newDevice'] = newDevice;
    json[r'noJWT'] = noJwt;
    return json;
  }

  IdentityProviderLoginRequest copyWith(
      {Map<String, dynamic>? data,
      String? identityProviderId,
      bool? noLink,
      String? encodedJwt,
      String? applicationId,
      String? ipAddress,
      MetaData? metaData,
      bool? newDevice,
      bool? noJwt}) {
    return IdentityProviderLoginRequest(
      data: data ?? this.data,
      identityProviderId: identityProviderId ?? this.identityProviderId,
      noLink: noLink ?? this.noLink,
      encodedJwt: encodedJwt ?? this.encodedJwt,
      applicationId: applicationId ?? this.applicationId,
      ipAddress: ipAddress ?? this.ipAddress,
      metaData: metaData ?? this.metaData,
      newDevice: newDevice ?? this.newDevice,
      noJwt: noJwt ?? this.noJwt,
    );
  }
}

class IdentityProviderOauth2Configuration {
  final String? authorizationEndpoint;
  final ClientAuthenticationMethod? clientAuthenticationMethod;
  final String? clientId;
  final String? clientSecret;
  final String? emailClaim;
  final String? emailVerifiedClaim;
  final String? issuer;
  final String? scope;
  final String? tokenEndpoint;
  final String? uniqueIdClaim;
  final String? userinfoEndpoint;
  final String? usernameClaim;

  IdentityProviderOauth2Configuration(
      {this.authorizationEndpoint,
      this.clientAuthenticationMethod,
      this.clientId,
      this.clientSecret,
      this.emailClaim,
      this.emailVerifiedClaim,
      this.issuer,
      this.scope,
      this.tokenEndpoint,
      this.uniqueIdClaim,
      this.userinfoEndpoint,
      this.usernameClaim});

  factory IdentityProviderOauth2Configuration.fromJson(
      Map<String, Object?> json) {
    return IdentityProviderOauth2Configuration(
      authorizationEndpoint: json[r'authorization_endpoint'] as String?,
      clientAuthenticationMethod: json[r'clientAuthenticationMethod'] != null
          ? ClientAuthenticationMethod.fromValue(
              json[r'clientAuthenticationMethod']! as String)
          : null,
      clientId: json[r'client_id'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      emailClaim: json[r'emailClaim'] as String?,
      emailVerifiedClaim: json[r'emailVerifiedClaim'] as String?,
      issuer: json[r'issuer'] as String?,
      scope: json[r'scope'] as String?,
      tokenEndpoint: json[r'token_endpoint'] as String?,
      uniqueIdClaim: json[r'uniqueIdClaim'] as String?,
      userinfoEndpoint: json[r'userinfo_endpoint'] as String?,
      usernameClaim: json[r'usernameClaim'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var authorizationEndpoint = this.authorizationEndpoint;
    var clientAuthenticationMethod = this.clientAuthenticationMethod;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var emailClaim = this.emailClaim;
    var emailVerifiedClaim = this.emailVerifiedClaim;
    var issuer = this.issuer;
    var scope = this.scope;
    var tokenEndpoint = this.tokenEndpoint;
    var uniqueIdClaim = this.uniqueIdClaim;
    var userinfoEndpoint = this.userinfoEndpoint;
    var usernameClaim = this.usernameClaim;

    final json = <String, Object?>{};
    if (authorizationEndpoint != null) {
      json[r'authorization_endpoint'] = authorizationEndpoint;
    }
    if (clientAuthenticationMethod != null) {
      json[r'clientAuthenticationMethod'] = clientAuthenticationMethod.value;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (emailClaim != null) {
      json[r'emailClaim'] = emailClaim;
    }
    if (emailVerifiedClaim != null) {
      json[r'emailVerifiedClaim'] = emailVerifiedClaim;
    }
    if (issuer != null) {
      json[r'issuer'] = issuer;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (tokenEndpoint != null) {
      json[r'token_endpoint'] = tokenEndpoint;
    }
    if (uniqueIdClaim != null) {
      json[r'uniqueIdClaim'] = uniqueIdClaim;
    }
    if (userinfoEndpoint != null) {
      json[r'userinfo_endpoint'] = userinfoEndpoint;
    }
    if (usernameClaim != null) {
      json[r'usernameClaim'] = usernameClaim;
    }
    return json;
  }

  IdentityProviderOauth2Configuration copyWith(
      {String? authorizationEndpoint,
      ClientAuthenticationMethod? clientAuthenticationMethod,
      String? clientId,
      String? clientSecret,
      String? emailClaim,
      String? emailVerifiedClaim,
      String? issuer,
      String? scope,
      String? tokenEndpoint,
      String? uniqueIdClaim,
      String? userinfoEndpoint,
      String? usernameClaim}) {
    return IdentityProviderOauth2Configuration(
      authorizationEndpoint:
          authorizationEndpoint ?? this.authorizationEndpoint,
      clientAuthenticationMethod:
          clientAuthenticationMethod ?? this.clientAuthenticationMethod,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      emailClaim: emailClaim ?? this.emailClaim,
      emailVerifiedClaim: emailVerifiedClaim ?? this.emailVerifiedClaim,
      issuer: issuer ?? this.issuer,
      scope: scope ?? this.scope,
      tokenEndpoint: tokenEndpoint ?? this.tokenEndpoint,
      uniqueIdClaim: uniqueIdClaim ?? this.uniqueIdClaim,
      userinfoEndpoint: userinfoEndpoint ?? this.userinfoEndpoint,
      usernameClaim: usernameClaim ?? this.usernameClaim,
    );
  }
}

class IdentityProviderPendingLinkResponse {
  final IdentityProviderTenantConfiguration?
      identityProviderTenantConfiguration;
  final int? linkCount;
  final PendingIdPLink? pendingIdpLink;

  IdentityProviderPendingLinkResponse(
      {this.identityProviderTenantConfiguration,
      this.linkCount,
      this.pendingIdpLink});

  factory IdentityProviderPendingLinkResponse.fromJson(
      Map<String, Object?> json) {
    return IdentityProviderPendingLinkResponse(
      identityProviderTenantConfiguration:
          json[r'identityProviderTenantConfiguration'] != null
              ? IdentityProviderTenantConfiguration.fromJson(
                  json[r'identityProviderTenantConfiguration']!
                      as Map<String, Object?>)
              : null,
      linkCount: (json[r'linkCount'] as num?)?.toInt(),
      pendingIdpLink: json[r'pendingIdPLink'] != null
          ? PendingIdPLink.fromJson(
              json[r'pendingIdPLink']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var identityProviderTenantConfiguration =
        this.identityProviderTenantConfiguration;
    var linkCount = this.linkCount;
    var pendingIdpLink = this.pendingIdpLink;

    final json = <String, Object?>{};
    if (identityProviderTenantConfiguration != null) {
      json[r'identityProviderTenantConfiguration'] =
          identityProviderTenantConfiguration.toJson();
    }
    if (linkCount != null) {
      json[r'linkCount'] = linkCount;
    }
    if (pendingIdpLink != null) {
      json[r'pendingIdPLink'] = pendingIdpLink.toJson();
    }
    return json;
  }

  IdentityProviderPendingLinkResponse copyWith(
      {IdentityProviderTenantConfiguration? identityProviderTenantConfiguration,
      int? linkCount,
      PendingIdPLink? pendingIdpLink}) {
    return IdentityProviderPendingLinkResponse(
      identityProviderTenantConfiguration:
          identityProviderTenantConfiguration ??
              this.identityProviderTenantConfiguration,
      linkCount: linkCount ?? this.linkCount,
      pendingIdpLink: pendingIdpLink ?? this.pendingIdpLink,
    );
  }
}

class IdentityProviderRequest {
  final IdentityProviderField? identityProvider;

  IdentityProviderRequest({this.identityProvider});

  factory IdentityProviderRequest.fromJson(Map<String, Object?> json) {
    return IdentityProviderRequest(
      identityProvider: json[r'identityProvider'] != null
          ? IdentityProviderField.fromJson(
              json[r'identityProvider']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var identityProvider = this.identityProvider;

    final json = <String, Object?>{};
    if (identityProvider != null) {
      json[r'identityProvider'] = identityProvider.toJson();
    }
    return json;
  }

  IdentityProviderRequest copyWith({IdentityProviderField? identityProvider}) {
    return IdentityProviderRequest(
      identityProvider: identityProvider ?? this.identityProvider,
    );
  }
}

class IdentityProviderResponse {
  final IdentityProviderField? identityProvider;
  final List<IdentityProviderField> identityProviders;

  IdentityProviderResponse(
      {this.identityProvider, List<IdentityProviderField>? identityProviders})
      : identityProviders = identityProviders ?? [];

  factory IdentityProviderResponse.fromJson(Map<String, Object?> json) {
    return IdentityProviderResponse(
      identityProvider: json[r'identityProvider'] != null
          ? IdentityProviderField.fromJson(
              json[r'identityProvider']! as Map<String, Object?>)
          : null,
      identityProviders: (json[r'identityProviders'] as List<Object?>?)
              ?.map((i) => IdentityProviderField.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var identityProvider = this.identityProvider;
    var identityProviders = this.identityProviders;

    final json = <String, Object?>{};
    if (identityProvider != null) {
      json[r'identityProvider'] = identityProvider.toJson();
    }
    json[r'identityProviders'] =
        identityProviders.map((i) => i.toJson()).toList();
    return json;
  }

  IdentityProviderResponse copyWith(
      {IdentityProviderField? identityProvider,
      List<IdentityProviderField>? identityProviders}) {
    return IdentityProviderResponse(
      identityProvider: identityProvider ?? this.identityProvider,
      identityProviders: identityProviders ?? this.identityProviders,
    );
  }
}

/// Search criteria for Identity Providers.
class IdentityProviderSearchCriteria {
  final String? applicationId;
  final String? name;
  final IdentityProviderType? type;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  IdentityProviderSearchCriteria(
      {this.applicationId,
      this.name,
      this.type,
      this.numberOfResults,
      this.orderBy,
      this.startRow});

  factory IdentityProviderSearchCriteria.fromJson(Map<String, Object?> json) {
    return IdentityProviderSearchCriteria(
      applicationId: json[r'applicationId'] as String?,
      name: json[r'name'] as String?,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var name = this.name;
    var type = this.type;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  IdentityProviderSearchCriteria copyWith(
      {String? applicationId,
      String? name,
      IdentityProviderType? type,
      int? numberOfResults,
      String? orderBy,
      int? startRow}) {
    return IdentityProviderSearchCriteria(
      applicationId: applicationId ?? this.applicationId,
      name: name ?? this.name,
      type: type ?? this.type,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Search request for Identity Providers
class IdentityProviderSearchRequest {
  final IdentityProviderSearchCriteria? search;

  IdentityProviderSearchRequest({this.search});

  factory IdentityProviderSearchRequest.fromJson(Map<String, Object?> json) {
    return IdentityProviderSearchRequest(
      search: json[r'search'] != null
          ? IdentityProviderSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  IdentityProviderSearchRequest copyWith(
      {IdentityProviderSearchCriteria? search}) {
    return IdentityProviderSearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Identity Provider response.
class IdentityProviderSearchResponse {
  final List<IdentityProviderField> identityProviders;
  final int? total;

  IdentityProviderSearchResponse(
      {List<IdentityProviderField>? identityProviders, this.total})
      : identityProviders = identityProviders ?? [];

  factory IdentityProviderSearchResponse.fromJson(Map<String, Object?> json) {
    return IdentityProviderSearchResponse(
      identityProviders: (json[r'identityProviders'] as List<Object?>?)
              ?.map((i) => IdentityProviderField.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var identityProviders = this.identityProviders;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'identityProviders'] =
        identityProviders.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  IdentityProviderSearchResponse copyWith(
      {List<IdentityProviderField>? identityProviders, int? total}) {
    return IdentityProviderSearchResponse(
      identityProviders: identityProviders ?? this.identityProviders,
      total: total ?? this.total,
    );
  }
}

class IdentityProviderStartLoginRequest {
  final Map<String, dynamic>? data;
  final String? identityProviderId;
  final String? loginId;
  final Map<String, dynamic>? state;
  final String? applicationId;
  final String? ipAddress;
  final MetaData? metaData;
  final bool newDevice;
  final bool noJwt;

  IdentityProviderStartLoginRequest(
      {this.data,
      this.identityProviderId,
      this.loginId,
      this.state,
      this.applicationId,
      this.ipAddress,
      this.metaData,
      bool? newDevice,
      bool? noJwt})
      : newDevice = newDevice ?? false,
        noJwt = noJwt ?? false;

  factory IdentityProviderStartLoginRequest.fromJson(
      Map<String, Object?> json) {
    return IdentityProviderStartLoginRequest(
      data: json[r'data'] as Map<String, Object?>?,
      identityProviderId: json[r'identityProviderId'] as String?,
      loginId: json[r'loginId'] as String?,
      state: json[r'state'] as Map<String, Object?>?,
      applicationId: json[r'applicationId'] as String?,
      ipAddress: json[r'ipAddress'] as String?,
      metaData: json[r'metaData'] != null
          ? MetaData.fromJson(json[r'metaData']! as Map<String, Object?>)
          : null,
      newDevice: json[r'newDevice'] as bool? ?? false,
      noJwt: json[r'noJWT'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var identityProviderId = this.identityProviderId;
    var loginId = this.loginId;
    var state = this.state;
    var applicationId = this.applicationId;
    var ipAddress = this.ipAddress;
    var metaData = this.metaData;
    var newDevice = this.newDevice;
    var noJwt = this.noJwt;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (identityProviderId != null) {
      json[r'identityProviderId'] = identityProviderId;
    }
    if (loginId != null) {
      json[r'loginId'] = loginId;
    }
    if (state != null) {
      json[r'state'] = state;
    }
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (ipAddress != null) {
      json[r'ipAddress'] = ipAddress;
    }
    if (metaData != null) {
      json[r'metaData'] = metaData.toJson();
    }
    json[r'newDevice'] = newDevice;
    json[r'noJWT'] = noJwt;
    return json;
  }

  IdentityProviderStartLoginRequest copyWith(
      {Map<String, dynamic>? data,
      String? identityProviderId,
      String? loginId,
      Map<String, dynamic>? state,
      String? applicationId,
      String? ipAddress,
      MetaData? metaData,
      bool? newDevice,
      bool? noJwt}) {
    return IdentityProviderStartLoginRequest(
      data: data ?? this.data,
      identityProviderId: identityProviderId ?? this.identityProviderId,
      loginId: loginId ?? this.loginId,
      state: state ?? this.state,
      applicationId: applicationId ?? this.applicationId,
      ipAddress: ipAddress ?? this.ipAddress,
      metaData: metaData ?? this.metaData,
      newDevice: newDevice ?? this.newDevice,
      noJwt: noJwt ?? this.noJwt,
    );
  }
}

class IdentityProviderStartLoginResponse {
  final String? code;

  IdentityProviderStartLoginResponse({this.code});

  factory IdentityProviderStartLoginResponse.fromJson(
      Map<String, Object?> json) {
    return IdentityProviderStartLoginResponse(
      code: json[r'code'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var code = this.code;

    final json = <String, Object?>{};
    if (code != null) {
      json[r'code'] = code;
    }
    return json;
  }

  IdentityProviderStartLoginResponse copyWith({String? code}) {
    return IdentityProviderStartLoginResponse(
      code: code ?? this.code,
    );
  }
}

class IdentityProviderTenantConfiguration {
  final Map<String, dynamic>? data;
  final IdentityProviderLimitUserLinkingPolicy? limitUserLinkCount;

  IdentityProviderTenantConfiguration({this.data, this.limitUserLinkCount});

  factory IdentityProviderTenantConfiguration.fromJson(
      Map<String, Object?> json) {
    return IdentityProviderTenantConfiguration(
      data: json[r'data'] as Map<String, Object?>?,
      limitUserLinkCount: json[r'limitUserLinkCount'] != null
          ? IdentityProviderLimitUserLinkingPolicy.fromJson(
              json[r'limitUserLinkCount']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var limitUserLinkCount = this.limitUserLinkCount;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (limitUserLinkCount != null) {
      json[r'limitUserLinkCount'] = limitUserLinkCount.toJson();
    }
    return json;
  }

  IdentityProviderTenantConfiguration copyWith(
      {Map<String, dynamic>? data,
      IdentityProviderLimitUserLinkingPolicy? limitUserLinkCount}) {
    return IdentityProviderTenantConfiguration(
      data: data ?? this.data,
      limitUserLinkCount: limitUserLinkCount ?? this.limitUserLinkCount,
    );
  }
}

/// Import request.
class ImportRequest {
  final String? encryptionScheme;
  final int? factor;
  final List<User> users;
  final bool validateDbConstraints;
  final EventInfo? eventInfo;

  ImportRequest(
      {this.encryptionScheme,
      this.factor,
      List<User>? users,
      bool? validateDbConstraints,
      this.eventInfo})
      : users = users ?? [],
        validateDbConstraints = validateDbConstraints ?? false;

  factory ImportRequest.fromJson(Map<String, Object?> json) {
    return ImportRequest(
      encryptionScheme: json[r'encryptionScheme'] as String?,
      factor: (json[r'factor'] as num?)?.toInt(),
      users: (json[r'users'] as List<Object?>?)
              ?.map(
                  (i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      validateDbConstraints: json[r'validateDbConstraints'] as bool? ?? false,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var encryptionScheme = this.encryptionScheme;
    var factor = this.factor;
    var users = this.users;
    var validateDbConstraints = this.validateDbConstraints;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (encryptionScheme != null) {
      json[r'encryptionScheme'] = encryptionScheme;
    }
    if (factor != null) {
      json[r'factor'] = factor;
    }
    json[r'users'] = users.map((i) => i.toJson()).toList();
    json[r'validateDbConstraints'] = validateDbConstraints;
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  ImportRequest copyWith(
      {String? encryptionScheme,
      int? factor,
      List<User>? users,
      bool? validateDbConstraints,
      EventInfo? eventInfo}) {
    return ImportRequest(
      encryptionScheme: encryptionScheme ?? this.encryptionScheme,
      factor: factor ?? this.factor,
      users: users ?? this.users,
      validateDbConstraints:
          validateDbConstraints ?? this.validateDbConstraints,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

/// A marker interface indicating this event is not scoped to a tenant and will
/// be sent to all webhooks.
class InstanceEvent {
  InstanceEvent();

  factory InstanceEvent.fromJson(Map<String, Object?> json) {
    return InstanceEvent();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// The Integration Request
class IntegrationRequest {
  final Integrations? integrations;

  IntegrationRequest({this.integrations});

  factory IntegrationRequest.fromJson(Map<String, Object?> json) {
    return IntegrationRequest(
      integrations: json[r'integrations'] != null
          ? Integrations.fromJson(
              json[r'integrations']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var integrations = this.integrations;

    final json = <String, Object?>{};
    if (integrations != null) {
      json[r'integrations'] = integrations.toJson();
    }
    return json;
  }

  IntegrationRequest copyWith({Integrations? integrations}) {
    return IntegrationRequest(
      integrations: integrations ?? this.integrations,
    );
  }
}

/// The Integration Response
class IntegrationResponse {
  final Integrations? integrations;

  IntegrationResponse({this.integrations});

  factory IntegrationResponse.fromJson(Map<String, Object?> json) {
    return IntegrationResponse(
      integrations: json[r'integrations'] != null
          ? Integrations.fromJson(
              json[r'integrations']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var integrations = this.integrations;

    final json = <String, Object?>{};
    if (integrations != null) {
      json[r'integrations'] = integrations.toJson();
    }
    return json;
  }

  IntegrationResponse copyWith({Integrations? integrations}) {
    return IntegrationResponse(
      integrations: integrations ?? this.integrations,
    );
  }
}

/// Available Integrations
class Integrations {
  final CleanSpeakConfiguration? cleanspeak;
  final KafkaConfiguration? kafka;

  Integrations({this.cleanspeak, this.kafka});

  factory Integrations.fromJson(Map<String, Object?> json) {
    return Integrations(
      cleanspeak: json[r'cleanspeak'] != null
          ? CleanSpeakConfiguration.fromJson(
              json[r'cleanspeak']! as Map<String, Object?>)
          : null,
      kafka: json[r'kafka'] != null
          ? KafkaConfiguration.fromJson(json[r'kafka']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var cleanspeak = this.cleanspeak;
    var kafka = this.kafka;

    final json = <String, Object?>{};
    if (cleanspeak != null) {
      json[r'cleanspeak'] = cleanspeak.toJson();
    }
    if (kafka != null) {
      json[r'kafka'] = kafka.toJson();
    }
    return json;
  }

  Integrations copyWith(
      {CleanSpeakConfiguration? cleanspeak, KafkaConfiguration? kafka}) {
    return Integrations(
      cleanspeak: cleanspeak ?? this.cleanspeak,
      kafka: kafka ?? this.kafka,
    );
  }
}

class IntrospectResponse {
  IntrospectResponse();

  factory IntrospectResponse.fromJson(Map<String, Object?> json) {
    return IntrospectResponse();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class IssueResponse {
  final String? refreshToken;
  final String? token;

  IssueResponse({this.refreshToken, this.token});

  factory IssueResponse.fromJson(Map<String, Object?> json) {
    return IssueResponse(
      refreshToken: json[r'refreshToken'] as String?,
      token: json[r'token'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var refreshToken = this.refreshToken;
    var token = this.token;

    final json = <String, Object?>{};
    if (refreshToken != null) {
      json[r'refreshToken'] = refreshToken;
    }
    if (token != null) {
      json[r'token'] = token;
    }
    return json;
  }

  IssueResponse copyWith({String? refreshToken, String? token}) {
    return IssueResponse(
      refreshToken: refreshToken ?? this.refreshToken,
      token: token ?? this.token,
    );
  }
}

/// A JSON Web Key as defined by <a
/// href="https:tools.ietf.orghtmlrfc7517#section-4">RFC 7517 JSON Web Key (JWK)
///  Section 4<a> and <a href="https:tools.ietf.orghtmlrfc7518">RFC 7518 JSON
/// Web Algorithms (JWA)<a>.
class JSONWebKey {
  final Algorithm? alg;
  final String? crv;
  final String? d;
  final String? dp;
  final String? dq;
  final String? e;
  final String? kid;
  final KeyType? kty;
  final String? n;
  final Map<String, dynamic>? other;
  final String? p;
  final String? q;
  final String? qi;
  final String? use;
  final String? x;
  final List<String> x5c;
  final String? x5t;
  final String? x5tS256;
  final String? y;

  JSONWebKey(
      {this.alg,
      this.crv,
      this.d,
      this.dp,
      this.dq,
      this.e,
      this.kid,
      this.kty,
      this.n,
      this.other,
      this.p,
      this.q,
      this.qi,
      this.use,
      this.x,
      List<String>? x5c,
      this.x5t,
      this.x5tS256,
      this.y})
      : x5c = x5c ?? [];

  factory JSONWebKey.fromJson(Map<String, Object?> json) {
    return JSONWebKey(
      alg: json[r'alg'] != null
          ? Algorithm.fromValue(json[r'alg']! as String)
          : null,
      crv: json[r'crv'] as String?,
      d: json[r'd'] as String?,
      dp: json[r'dp'] as String?,
      dq: json[r'dq'] as String?,
      e: json[r'e'] as String?,
      kid: json[r'kid'] as String?,
      kty: json[r'kty'] != null
          ? KeyType.fromValue(json[r'kty']! as String)
          : null,
      n: json[r'n'] as String?,
      other: json[r'other'] as Map<String, Object?>?,
      p: json[r'p'] as String?,
      q: json[r'q'] as String?,
      qi: json[r'qi'] as String?,
      use: json[r'use'] as String?,
      x: json[r'x'] as String?,
      x5c: (json[r'x5c'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      x5t: json[r'x5t'] as String?,
      x5tS256: json[r'x5t#S256'] as String?,
      y: json[r'y'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var alg = this.alg;
    var crv = this.crv;
    var d = this.d;
    var dp = this.dp;
    var dq = this.dq;
    var e = this.e;
    var kid = this.kid;
    var kty = this.kty;
    var n = this.n;
    var other = this.other;
    var p = this.p;
    var q = this.q;
    var qi = this.qi;
    var use = this.use;
    var x = this.x;
    var x5c = this.x5c;
    var x5t = this.x5t;
    var x5tS256 = this.x5tS256;
    var y = this.y;

    final json = <String, Object?>{};
    if (alg != null) {
      json[r'alg'] = alg.value;
    }
    if (crv != null) {
      json[r'crv'] = crv;
    }
    if (d != null) {
      json[r'd'] = d;
    }
    if (dp != null) {
      json[r'dp'] = dp;
    }
    if (dq != null) {
      json[r'dq'] = dq;
    }
    if (e != null) {
      json[r'e'] = e;
    }
    if (kid != null) {
      json[r'kid'] = kid;
    }
    if (kty != null) {
      json[r'kty'] = kty.value;
    }
    if (n != null) {
      json[r'n'] = n;
    }
    if (other != null) {
      json[r'other'] = other;
    }
    if (p != null) {
      json[r'p'] = p;
    }
    if (q != null) {
      json[r'q'] = q;
    }
    if (qi != null) {
      json[r'qi'] = qi;
    }
    if (use != null) {
      json[r'use'] = use;
    }
    if (x != null) {
      json[r'x'] = x;
    }
    json[r'x5c'] = x5c;
    if (x5t != null) {
      json[r'x5t'] = x5t;
    }
    if (x5tS256 != null) {
      json[r'x5t#S256'] = x5tS256;
    }
    if (y != null) {
      json[r'y'] = y;
    }
    return json;
  }

  JSONWebKey copyWith(
      {Algorithm? alg,
      String? crv,
      String? d,
      String? dp,
      String? dq,
      String? e,
      String? kid,
      KeyType? kty,
      String? n,
      Map<String, dynamic>? other,
      String? p,
      String? q,
      String? qi,
      String? use,
      String? x,
      List<String>? x5c,
      String? x5t,
      String? x5tS256,
      String? y}) {
    return JSONWebKey(
      alg: alg ?? this.alg,
      crv: crv ?? this.crv,
      d: d ?? this.d,
      dp: dp ?? this.dp,
      dq: dq ?? this.dq,
      e: e ?? this.e,
      kid: kid ?? this.kid,
      kty: kty ?? this.kty,
      n: n ?? this.n,
      other: other ?? this.other,
      p: p ?? this.p,
      q: q ?? this.q,
      qi: qi ?? this.qi,
      use: use ?? this.use,
      x: x ?? this.x,
      x5c: x5c ?? this.x5c,
      x5t: x5t ?? this.x5t,
      x5tS256: x5tS256 ?? this.x5tS256,
      y: y ?? this.y,
    );
  }
}

/// Interface for any object that can provide JSON Web key Information.
class JSONWebKeyInfoProvider {
  JSONWebKeyInfoProvider();

  factory JSONWebKeyInfoProvider.fromJson(Map<String, Object?> json) {
    return JSONWebKeyInfoProvider();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class JWKSResponse {
  final List<JSONWebKey> keys;

  JWKSResponse({List<JSONWebKey>? keys}) : keys = keys ?? [];

  factory JWKSResponse.fromJson(Map<String, Object?> json) {
    return JWKSResponse(
      keys: (json[r'keys'] as List<Object?>?)
              ?.map((i) =>
                  JSONWebKey.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var keys = this.keys;

    final json = <String, Object?>{};
    json[r'keys'] = keys.map((i) => i.toJson()).toList();
    return json;
  }

  JWKSResponse copyWith({List<JSONWebKey>? keys}) {
    return JWKSResponse(
      keys: keys ?? this.keys,
    );
  }
}

/// JSON Web Token (JWT) as defined by RFC 7519.  <pre>  From RFC 7519 Section
/// 1. Introduction:     The suggested pronunciation of JWT is the same as the
/// English word "jot".  <pre>  The JWT is not Thread-Safe and should not be
/// re-used.
class JWT {
  final Map<String, dynamic>? aud;
  final ZonedDateTime? exp;
  final ZonedDateTime? iat;
  final String? iss;
  final ZonedDateTime? nbf;
  final Map<String, dynamic>? otherClaims;
  final String? sub;
  final String? jti;

  JWT(
      {this.aud,
      this.exp,
      this.iat,
      this.iss,
      this.nbf,
      this.otherClaims,
      this.sub,
      this.jti});

  factory JWT.fromJson(Map<String, Object?> json) {
    return JWT(
      aud: json[r'aud'] as Map<String, Object?>?,
      exp: (json[r'exp'] as num?)?.toInt() as ZonedDateTime?,
      iat: (json[r'iat'] as num?)?.toInt() as ZonedDateTime?,
      iss: json[r'iss'] as String?,
      nbf: (json[r'nbf'] as num?)?.toInt() as ZonedDateTime?,
      otherClaims: json[r'otherClaims'] as Map<String, Object?>?,
      sub: json[r'sub'] as String?,
      jti: json[r'jti'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var aud = this.aud;
    var exp = this.exp;
    var iat = this.iat;
    var iss = this.iss;
    var nbf = this.nbf;
    var otherClaims = this.otherClaims;
    var sub = this.sub;
    var jti = this.jti;

    final json = <String, Object?>{};
    if (aud != null) {
      json[r'aud'] = aud;
    }
    if (exp != null) {
      json[r'exp'] = exp.toJson();
    }
    if (iat != null) {
      json[r'iat'] = iat.toJson();
    }
    if (iss != null) {
      json[r'iss'] = iss;
    }
    if (nbf != null) {
      json[r'nbf'] = nbf.toJson();
    }
    if (otherClaims != null) {
      json[r'otherClaims'] = otherClaims;
    }
    if (sub != null) {
      json[r'sub'] = sub;
    }
    if (jti != null) {
      json[r'jti'] = jti;
    }
    return json;
  }

  JWT copyWith(
      {Map<String, dynamic>? aud,
      ZonedDateTime? exp,
      ZonedDateTime? iat,
      String? iss,
      ZonedDateTime? nbf,
      Map<String, dynamic>? otherClaims,
      String? sub,
      String? jti}) {
    return JWT(
      aud: aud ?? this.aud,
      exp: exp ?? this.exp,
      iat: iat ?? this.iat,
      iss: iss ?? this.iss,
      nbf: nbf ?? this.nbf,
      otherClaims: otherClaims ?? this.otherClaims,
      sub: sub ?? this.sub,
      jti: jti ?? this.jti,
    );
  }
}

/// JWT Configuration. A JWT Configuration for an Application may not be active
/// if it is using the global configuration, the configuration  may be `enabled
/// = false`.
class JWTConfiguration {
  final String? accessTokenKeyId;
  final String? idTokenKeyId;
  final RefreshTokenExpirationPolicy? refreshTokenExpirationPolicy;
  final RefreshTokenRevocationPolicy? refreshTokenRevocationPolicy;
  final RefreshTokenSlidingWindowConfiguration?
      refreshTokenSlidingWindowConfiguration;
  final int? refreshTokenTimeToLiveInMinutes;
  final RefreshTokenUsagePolicy? refreshTokenUsagePolicy;
  final int? timeToLiveInSeconds;
  final bool enabled;

  JWTConfiguration(
      {this.accessTokenKeyId,
      this.idTokenKeyId,
      this.refreshTokenExpirationPolicy,
      this.refreshTokenRevocationPolicy,
      this.refreshTokenSlidingWindowConfiguration,
      this.refreshTokenTimeToLiveInMinutes,
      this.refreshTokenUsagePolicy,
      this.timeToLiveInSeconds,
      bool? enabled})
      : enabled = enabled ?? false;

  factory JWTConfiguration.fromJson(Map<String, Object?> json) {
    return JWTConfiguration(
      accessTokenKeyId: json[r'accessTokenKeyId'] as String?,
      idTokenKeyId: json[r'idTokenKeyId'] as String?,
      refreshTokenExpirationPolicy:
          json[r'refreshTokenExpirationPolicy'] != null
              ? RefreshTokenExpirationPolicy.fromValue(
                  json[r'refreshTokenExpirationPolicy']! as String)
              : null,
      refreshTokenRevocationPolicy: json[r'refreshTokenRevocationPolicy'] !=
              null
          ? RefreshTokenRevocationPolicy.fromJson(
              json[r'refreshTokenRevocationPolicy']! as Map<String, Object?>)
          : null,
      refreshTokenSlidingWindowConfiguration:
          json[r'refreshTokenSlidingWindowConfiguration'] != null
              ? RefreshTokenSlidingWindowConfiguration.fromJson(
                  json[r'refreshTokenSlidingWindowConfiguration']!
                      as Map<String, Object?>)
              : null,
      refreshTokenTimeToLiveInMinutes:
          (json[r'refreshTokenTimeToLiveInMinutes'] as num?)?.toInt(),
      refreshTokenUsagePolicy: json[r'refreshTokenUsagePolicy'] != null
          ? RefreshTokenUsagePolicy.fromValue(
              json[r'refreshTokenUsagePolicy']! as String)
          : null,
      timeToLiveInSeconds: (json[r'timeToLiveInSeconds'] as num?)?.toInt(),
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var accessTokenKeyId = this.accessTokenKeyId;
    var idTokenKeyId = this.idTokenKeyId;
    var refreshTokenExpirationPolicy = this.refreshTokenExpirationPolicy;
    var refreshTokenRevocationPolicy = this.refreshTokenRevocationPolicy;
    var refreshTokenSlidingWindowConfiguration =
        this.refreshTokenSlidingWindowConfiguration;
    var refreshTokenTimeToLiveInMinutes = this.refreshTokenTimeToLiveInMinutes;
    var refreshTokenUsagePolicy = this.refreshTokenUsagePolicy;
    var timeToLiveInSeconds = this.timeToLiveInSeconds;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (accessTokenKeyId != null) {
      json[r'accessTokenKeyId'] = accessTokenKeyId;
    }
    if (idTokenKeyId != null) {
      json[r'idTokenKeyId'] = idTokenKeyId;
    }
    if (refreshTokenExpirationPolicy != null) {
      json[r'refreshTokenExpirationPolicy'] =
          refreshTokenExpirationPolicy.value;
    }
    if (refreshTokenRevocationPolicy != null) {
      json[r'refreshTokenRevocationPolicy'] =
          refreshTokenRevocationPolicy.toJson();
    }
    if (refreshTokenSlidingWindowConfiguration != null) {
      json[r'refreshTokenSlidingWindowConfiguration'] =
          refreshTokenSlidingWindowConfiguration.toJson();
    }
    if (refreshTokenTimeToLiveInMinutes != null) {
      json[r'refreshTokenTimeToLiveInMinutes'] =
          refreshTokenTimeToLiveInMinutes;
    }
    if (refreshTokenUsagePolicy != null) {
      json[r'refreshTokenUsagePolicy'] = refreshTokenUsagePolicy.value;
    }
    if (timeToLiveInSeconds != null) {
      json[r'timeToLiveInSeconds'] = timeToLiveInSeconds;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  JWTConfiguration copyWith(
      {String? accessTokenKeyId,
      String? idTokenKeyId,
      RefreshTokenExpirationPolicy? refreshTokenExpirationPolicy,
      RefreshTokenRevocationPolicy? refreshTokenRevocationPolicy,
      RefreshTokenSlidingWindowConfiguration?
          refreshTokenSlidingWindowConfiguration,
      int? refreshTokenTimeToLiveInMinutes,
      RefreshTokenUsagePolicy? refreshTokenUsagePolicy,
      int? timeToLiveInSeconds,
      bool? enabled}) {
    return JWTConfiguration(
      accessTokenKeyId: accessTokenKeyId ?? this.accessTokenKeyId,
      idTokenKeyId: idTokenKeyId ?? this.idTokenKeyId,
      refreshTokenExpirationPolicy:
          refreshTokenExpirationPolicy ?? this.refreshTokenExpirationPolicy,
      refreshTokenRevocationPolicy:
          refreshTokenRevocationPolicy ?? this.refreshTokenRevocationPolicy,
      refreshTokenSlidingWindowConfiguration:
          refreshTokenSlidingWindowConfiguration ??
              this.refreshTokenSlidingWindowConfiguration,
      refreshTokenTimeToLiveInMinutes: refreshTokenTimeToLiveInMinutes ??
          this.refreshTokenTimeToLiveInMinutes,
      refreshTokenUsagePolicy:
          refreshTokenUsagePolicy ?? this.refreshTokenUsagePolicy,
      timeToLiveInSeconds: timeToLiveInSeconds ?? this.timeToLiveInSeconds,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Models the JWT public key Refresh Token Revoke Event. This event might be
/// for a single  token, a user or an entire application.
class JWTPublicKeyUpdateEvent {
  final List<dynamic> applicationIds;
  final ZonedDateTime? createInstant;
  final String? id;
  final EventInfo? info;
  final String? tenantId;
  final EventType? type;

  JWTPublicKeyUpdateEvent(
      {List<dynamic>? applicationIds,
      this.createInstant,
      this.id,
      this.info,
      this.tenantId,
      this.type})
      : applicationIds = applicationIds ?? [];

  factory JWTPublicKeyUpdateEvent.fromJson(Map<String, Object?> json) {
    return JWTPublicKeyUpdateEvent(
      applicationIds:
          (json[r'applicationIds'] as List<Object?>?)?.map((i) => i).toList() ??
              [],
      createInstant:
          (json[r'createInstant'] as num?)?.toInt() as ZonedDateTime?,
      id: json[r'id'] as String?,
      info: json[r'info'] != null
          ? EventInfo.fromJson(json[r'info']! as Map<String, Object?>)
          : null,
      tenantId: json[r'tenantId'] as String?,
      type: json[r'type'] != null
          ? EventType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationIds = this.applicationIds;
    var createInstant = this.createInstant;
    var id = this.id;
    var info = this.info;
    var tenantId = this.tenantId;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'applicationIds'] = applicationIds;
    if (createInstant != null) {
      json[r'createInstant'] = createInstant.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (info != null) {
      json[r'info'] = info.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  JWTPublicKeyUpdateEvent copyWith(
      {List<dynamic>? applicationIds,
      ZonedDateTime? createInstant,
      String? id,
      EventInfo? info,
      String? tenantId,
      EventType? type}) {
    return JWTPublicKeyUpdateEvent(
      applicationIds: applicationIds ?? this.applicationIds,
      createInstant: createInstant ?? this.createInstant,
      id: id ?? this.id,
      info: info ?? this.info,
      tenantId: tenantId ?? this.tenantId,
      type: type ?? this.type,
    );
  }
}

/// Models the JWT Refresh Event. This event will be fired when a JWT is
/// "refreshed" (generated) using a Refresh Token.
class JWTRefreshEvent {
  final String? applicationId;
  final String? original;
  final String? refreshToken;
  final String? token;
  final String? userId;
  final ZonedDateTime? createInstant;
  final String? id;
  final EventInfo? info;
  final String? tenantId;
  final EventType? type;

  JWTRefreshEvent(
      {this.applicationId,
      this.original,
      this.refreshToken,
      this.token,
      this.userId,
      this.createInstant,
      this.id,
      this.info,
      this.tenantId,
      this.type});

  factory JWTRefreshEvent.fromJson(Map<String, Object?> json) {
    return JWTRefreshEvent(
      applicationId: json[r'applicationId'] as String?,
      original: json[r'original'] as String?,
      refreshToken: json[r'refreshToken'] as String?,
      token: json[r'token'] as String?,
      userId: json[r'userId'] as String?,
      createInstant:
          (json[r'createInstant'] as num?)?.toInt() as ZonedDateTime?,
      id: json[r'id'] as String?,
      info: json[r'info'] != null
          ? EventInfo.fromJson(json[r'info']! as Map<String, Object?>)
          : null,
      tenantId: json[r'tenantId'] as String?,
      type: json[r'type'] != null
          ? EventType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var original = this.original;
    var refreshToken = this.refreshToken;
    var token = this.token;
    var userId = this.userId;
    var createInstant = this.createInstant;
    var id = this.id;
    var info = this.info;
    var tenantId = this.tenantId;
    var type = this.type;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (original != null) {
      json[r'original'] = original;
    }
    if (refreshToken != null) {
      json[r'refreshToken'] = refreshToken;
    }
    if (token != null) {
      json[r'token'] = token;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    if (createInstant != null) {
      json[r'createInstant'] = createInstant.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (info != null) {
      json[r'info'] = info.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  JWTRefreshEvent copyWith(
      {String? applicationId,
      String? original,
      String? refreshToken,
      String? token,
      String? userId,
      ZonedDateTime? createInstant,
      String? id,
      EventInfo? info,
      String? tenantId,
      EventType? type}) {
    return JWTRefreshEvent(
      applicationId: applicationId ?? this.applicationId,
      original: original ?? this.original,
      refreshToken: refreshToken ?? this.refreshToken,
      token: token ?? this.token,
      userId: userId ?? this.userId,
      createInstant: createInstant ?? this.createInstant,
      id: id ?? this.id,
      info: info ?? this.info,
      tenantId: tenantId ?? this.tenantId,
      type: type ?? this.type,
    );
  }
}

/// API response for refreshing a JWT with a Refresh Token.  <p>  Using a
/// different response object from RefreshTokenResponse because the retrieve
/// response will return an object for refreshToken, and this is a  string.
class JWTRefreshResponse {
  final String? refreshToken;
  final String? refreshTokenId;
  final String? token;

  JWTRefreshResponse({this.refreshToken, this.refreshTokenId, this.token});

  factory JWTRefreshResponse.fromJson(Map<String, Object?> json) {
    return JWTRefreshResponse(
      refreshToken: json[r'refreshToken'] as String?,
      refreshTokenId: json[r'refreshTokenId'] as String?,
      token: json[r'token'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var refreshToken = this.refreshToken;
    var refreshTokenId = this.refreshTokenId;
    var token = this.token;

    final json = <String, Object?>{};
    if (refreshToken != null) {
      json[r'refreshToken'] = refreshToken;
    }
    if (refreshTokenId != null) {
      json[r'refreshTokenId'] = refreshTokenId;
    }
    if (token != null) {
      json[r'token'] = token;
    }
    return json;
  }

  JWTRefreshResponse copyWith(
      {String? refreshToken, String? refreshTokenId, String? token}) {
    return JWTRefreshResponse(
      refreshToken: refreshToken ?? this.refreshToken,
      refreshTokenId: refreshTokenId ?? this.refreshTokenId,
      token: token ?? this.token,
    );
  }
}

/// Models the Refresh Token Revoke Event. This event might be for a single
/// token, a user  or an entire application.
class JWTRefreshTokenRevokeEvent {
  final String? applicationId;
  final Map<String, dynamic>? applicationTimeToLiveInSeconds;
  final RefreshToken? refreshToken;
  final User? user;
  final String? userId;
  final ZonedDateTime? createInstant;
  final String? id;
  final EventInfo? info;
  final String? tenantId;
  final EventType? type;

  JWTRefreshTokenRevokeEvent(
      {this.applicationId,
      this.applicationTimeToLiveInSeconds,
      this.refreshToken,
      this.user,
      this.userId,
      this.createInstant,
      this.id,
      this.info,
      this.tenantId,
      this.type});

  factory JWTRefreshTokenRevokeEvent.fromJson(Map<String, Object?> json) {
    return JWTRefreshTokenRevokeEvent(
      applicationId: json[r'applicationId'] as String?,
      applicationTimeToLiveInSeconds:
          json[r'applicationTimeToLiveInSeconds'] as Map<String, Object?>?,
      refreshToken: json[r'refreshToken'] != null
          ? RefreshToken.fromJson(
              json[r'refreshToken']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
      userId: json[r'userId'] as String?,
      createInstant:
          (json[r'createInstant'] as num?)?.toInt() as ZonedDateTime?,
      id: json[r'id'] as String?,
      info: json[r'info'] != null
          ? EventInfo.fromJson(json[r'info']! as Map<String, Object?>)
          : null,
      tenantId: json[r'tenantId'] as String?,
      type: json[r'type'] != null
          ? EventType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var applicationTimeToLiveInSeconds = this.applicationTimeToLiveInSeconds;
    var refreshToken = this.refreshToken;
    var user = this.user;
    var userId = this.userId;
    var createInstant = this.createInstant;
    var id = this.id;
    var info = this.info;
    var tenantId = this.tenantId;
    var type = this.type;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (applicationTimeToLiveInSeconds != null) {
      json[r'applicationTimeToLiveInSeconds'] = applicationTimeToLiveInSeconds;
    }
    if (refreshToken != null) {
      json[r'refreshToken'] = refreshToken.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    if (createInstant != null) {
      json[r'createInstant'] = createInstant.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (info != null) {
      json[r'info'] = info.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  JWTRefreshTokenRevokeEvent copyWith(
      {String? applicationId,
      Map<String, dynamic>? applicationTimeToLiveInSeconds,
      RefreshToken? refreshToken,
      User? user,
      String? userId,
      ZonedDateTime? createInstant,
      String? id,
      EventInfo? info,
      String? tenantId,
      EventType? type}) {
    return JWTRefreshTokenRevokeEvent(
      applicationId: applicationId ?? this.applicationId,
      applicationTimeToLiveInSeconds:
          applicationTimeToLiveInSeconds ?? this.applicationTimeToLiveInSeconds,
      refreshToken: refreshToken ?? this.refreshToken,
      user: user ?? this.user,
      userId: userId ?? this.userId,
      createInstant: createInstant ?? this.createInstant,
      id: id ?? this.id,
      info: info ?? this.info,
      tenantId: tenantId ?? this.tenantId,
      type: type ?? this.type,
    );
  }
}

class JWTVendRequest {
  final Map<String, dynamic>? claims;
  final String? keyId;
  final int? timeToLiveInSeconds;

  JWTVendRequest({this.claims, this.keyId, this.timeToLiveInSeconds});

  factory JWTVendRequest.fromJson(Map<String, Object?> json) {
    return JWTVendRequest(
      claims: json[r'claims'] as Map<String, Object?>?,
      keyId: json[r'keyId'] as String?,
      timeToLiveInSeconds: (json[r'timeToLiveInSeconds'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var claims = this.claims;
    var keyId = this.keyId;
    var timeToLiveInSeconds = this.timeToLiveInSeconds;

    final json = <String, Object?>{};
    if (claims != null) {
      json[r'claims'] = claims;
    }
    if (keyId != null) {
      json[r'keyId'] = keyId;
    }
    if (timeToLiveInSeconds != null) {
      json[r'timeToLiveInSeconds'] = timeToLiveInSeconds;
    }
    return json;
  }

  JWTVendRequest copyWith(
      {Map<String, dynamic>? claims, String? keyId, int? timeToLiveInSeconds}) {
    return JWTVendRequest(
      claims: claims ?? this.claims,
      keyId: keyId ?? this.keyId,
      timeToLiveInSeconds: timeToLiveInSeconds ?? this.timeToLiveInSeconds,
    );
  }
}

class JWTVendResponse {
  final String? token;

  JWTVendResponse({this.token});

  factory JWTVendResponse.fromJson(Map<String, Object?> json) {
    return JWTVendResponse(
      token: json[r'token'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var token = this.token;

    final json = <String, Object?>{};
    if (token != null) {
      json[r'token'] = token;
    }
    return json;
  }

  JWTVendResponse copyWith({String? token}) {
    return JWTVendResponse(
      token: token ?? this.token,
    );
  }
}

class KafkaConfiguration {
  final String? defaultTopic;
  final Map<String, dynamic>? producer;
  final bool enabled;

  KafkaConfiguration({this.defaultTopic, this.producer, bool? enabled})
      : enabled = enabled ?? false;

  factory KafkaConfiguration.fromJson(Map<String, Object?> json) {
    return KafkaConfiguration(
      defaultTopic: json[r'defaultTopic'] as String?,
      producer: json[r'producer'] as Map<String, Object?>?,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var defaultTopic = this.defaultTopic;
    var producer = this.producer;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (defaultTopic != null) {
      json[r'defaultTopic'] = defaultTopic;
    }
    if (producer != null) {
      json[r'producer'] = producer;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  KafkaConfiguration copyWith(
      {String? defaultTopic, Map<String, dynamic>? producer, bool? enabled}) {
    return KafkaConfiguration(
      defaultTopic: defaultTopic ?? this.defaultTopic,
      producer: producer ?? this.producer,
      enabled: enabled ?? this.enabled,
    );
  }
}

class KafkaMessengerConfiguration {
  final String? defaultTopic;
  final Map<String, dynamic>? producer;
  final Map<String, dynamic>? data;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final String? transport;
  final MessengerType? type;

  KafkaMessengerConfiguration(
      {this.defaultTopic,
      this.producer,
      this.data,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.name,
      this.transport,
      this.type})
      : debug = debug ?? false;

  factory KafkaMessengerConfiguration.fromJson(Map<String, Object?> json) {
    return KafkaMessengerConfiguration(
      defaultTopic: json[r'defaultTopic'] as String?,
      producer: json[r'producer'] as Map<String, Object?>?,
      data: json[r'data'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      transport: json[r'transport'] as String?,
      type: json[r'type'] != null
          ? MessengerType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var defaultTopic = this.defaultTopic;
    var producer = this.producer;
    var data = this.data;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var transport = this.transport;
    var type = this.type;

    final json = <String, Object?>{};
    if (defaultTopic != null) {
      json[r'defaultTopic'] = defaultTopic;
    }
    if (producer != null) {
      json[r'producer'] = producer;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (transport != null) {
      json[r'transport'] = transport;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  KafkaMessengerConfiguration copyWith(
      {String? defaultTopic,
      Map<String, dynamic>? producer,
      Map<String, dynamic>? data,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      String? transport,
      MessengerType? type}) {
    return KafkaMessengerConfiguration(
      defaultTopic: defaultTopic ?? this.defaultTopic,
      producer: producer ?? this.producer,
      data: data ?? this.data,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      transport: transport ?? this.transport,
      type: type ?? this.type,
    );
  }
}

/// Domain for a public key, key pair or an HMAC secret. This is used by
/// KeyMaster to manage keys for JWTs, SAML, etc.
class Key {
  final KeyAlgorithm? algorithm;
  final String? certificate;
  final CertificateInformation? certificateInformation;
  final ZonedDateTime? expirationInstant;
  final bool hasPrivateKey;
  final String? id;
  final ZonedDateTime? insertInstant;
  final String? issuer;
  final String? kid;
  final ZonedDateTime? lastUpdateInstant;
  final int? length;
  final String? name;
  final String? privateKey;
  final String? publicKey;
  final String? secret;
  final KeyType? type;

  Key(
      {this.algorithm,
      this.certificate,
      this.certificateInformation,
      this.expirationInstant,
      bool? hasPrivateKey,
      this.id,
      this.insertInstant,
      this.issuer,
      this.kid,
      this.lastUpdateInstant,
      this.length,
      this.name,
      this.privateKey,
      this.publicKey,
      this.secret,
      this.type})
      : hasPrivateKey = hasPrivateKey ?? false;

  factory Key.fromJson(Map<String, Object?> json) {
    return Key(
      algorithm: json[r'algorithm'] != null
          ? KeyAlgorithm.fromValue(json[r'algorithm']! as String)
          : null,
      certificate: json[r'certificate'] as String?,
      certificateInformation: json[r'certificateInformation'] != null
          ? CertificateInformation.fromJson(
              json[r'certificateInformation']! as Map<String, Object?>)
          : null,
      expirationInstant:
          (json[r'expirationInstant'] as num?)?.toInt() as ZonedDateTime?,
      hasPrivateKey: json[r'hasPrivateKey'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      issuer: json[r'issuer'] as String?,
      kid: json[r'kid'] as String?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      length: (json[r'length'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      privateKey: json[r'privateKey'] as String?,
      publicKey: json[r'publicKey'] as String?,
      secret: json[r'secret'] as String?,
      type: json[r'type'] != null
          ? KeyType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var algorithm = this.algorithm;
    var certificate = this.certificate;
    var certificateInformation = this.certificateInformation;
    var expirationInstant = this.expirationInstant;
    var hasPrivateKey = this.hasPrivateKey;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var issuer = this.issuer;
    var kid = this.kid;
    var lastUpdateInstant = this.lastUpdateInstant;
    var length = this.length;
    var name = this.name;
    var privateKey = this.privateKey;
    var publicKey = this.publicKey;
    var secret = this.secret;
    var type = this.type;

    final json = <String, Object?>{};
    if (algorithm != null) {
      json[r'algorithm'] = algorithm.value;
    }
    if (certificate != null) {
      json[r'certificate'] = certificate;
    }
    if (certificateInformation != null) {
      json[r'certificateInformation'] = certificateInformation.toJson();
    }
    if (expirationInstant != null) {
      json[r'expirationInstant'] = expirationInstant.toJson();
    }
    json[r'hasPrivateKey'] = hasPrivateKey;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (issuer != null) {
      json[r'issuer'] = issuer;
    }
    if (kid != null) {
      json[r'kid'] = kid;
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (length != null) {
      json[r'length'] = length;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (privateKey != null) {
      json[r'privateKey'] = privateKey;
    }
    if (publicKey != null) {
      json[r'publicKey'] = publicKey;
    }
    if (secret != null) {
      json[r'secret'] = secret;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  Key copyWith(
      {KeyAlgorithm? algorithm,
      String? certificate,
      CertificateInformation? certificateInformation,
      ZonedDateTime? expirationInstant,
      bool? hasPrivateKey,
      String? id,
      ZonedDateTime? insertInstant,
      String? issuer,
      String? kid,
      ZonedDateTime? lastUpdateInstant,
      int? length,
      String? name,
      String? privateKey,
      String? publicKey,
      String? secret,
      KeyType? type}) {
    return Key(
      algorithm: algorithm ?? this.algorithm,
      certificate: certificate ?? this.certificate,
      certificateInformation:
          certificateInformation ?? this.certificateInformation,
      expirationInstant: expirationInstant ?? this.expirationInstant,
      hasPrivateKey: hasPrivateKey ?? this.hasPrivateKey,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      issuer: issuer ?? this.issuer,
      kid: kid ?? this.kid,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      length: length ?? this.length,
      name: name ?? this.name,
      privateKey: privateKey ?? this.privateKey,
      publicKey: publicKey ?? this.publicKey,
      secret: secret ?? this.secret,
      type: type ?? this.type,
    );
  }
}

/// Key API request object.
class KeyRequest {
  final Key? key;

  KeyRequest({this.key});

  factory KeyRequest.fromJson(Map<String, Object?> json) {
    return KeyRequest(
      key: json[r'key'] != null
          ? Key.fromJson(json[r'key']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var key = this.key;

    final json = <String, Object?>{};
    if (key != null) {
      json[r'key'] = key.toJson();
    }
    return json;
  }

  KeyRequest copyWith({Key? key}) {
    return KeyRequest(
      key: key ?? this.key,
    );
  }
}

/// Key API response object.
class KeyResponse {
  final Key? key;
  final List<Key> keys;

  KeyResponse({this.key, List<Key>? keys}) : keys = keys ?? [];

  factory KeyResponse.fromJson(Map<String, Object?> json) {
    return KeyResponse(
      key: json[r'key'] != null
          ? Key.fromJson(json[r'key']! as Map<String, Object?>)
          : null,
      keys: (json[r'keys'] as List<Object?>?)
              ?.map((i) => Key.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var key = this.key;
    var keys = this.keys;

    final json = <String, Object?>{};
    if (key != null) {
      json[r'key'] = key.toJson();
    }
    json[r'keys'] = keys.map((i) => i.toJson()).toList();
    return json;
  }

  KeyResponse copyWith({Key? key, List<Key>? keys}) {
    return KeyResponse(
      key: key ?? this.key,
      keys: keys ?? this.keys,
    );
  }
}

/// Search criteria for Keys
class KeySearchCriteria {
  final KeyAlgorithm? algorithm;
  final String? name;
  final KeyType? type;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  KeySearchCriteria(
      {this.algorithm,
      this.name,
      this.type,
      this.numberOfResults,
      this.orderBy,
      this.startRow});

  factory KeySearchCriteria.fromJson(Map<String, Object?> json) {
    return KeySearchCriteria(
      algorithm: json[r'algorithm'] != null
          ? KeyAlgorithm.fromValue(json[r'algorithm']! as String)
          : null,
      name: json[r'name'] as String?,
      type: json[r'type'] != null
          ? KeyType.fromValue(json[r'type']! as String)
          : null,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var algorithm = this.algorithm;
    var name = this.name;
    var type = this.type;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (algorithm != null) {
      json[r'algorithm'] = algorithm.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  KeySearchCriteria copyWith(
      {KeyAlgorithm? algorithm,
      String? name,
      KeyType? type,
      int? numberOfResults,
      String? orderBy,
      int? startRow}) {
    return KeySearchCriteria(
      algorithm: algorithm ?? this.algorithm,
      name: name ?? this.name,
      type: type ?? this.type,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Search request for Keys
class KeySearchRequest {
  final KeySearchCriteria? search;

  KeySearchRequest({this.search});

  factory KeySearchRequest.fromJson(Map<String, Object?> json) {
    return KeySearchRequest(
      search: json[r'search'] != null
          ? KeySearchCriteria.fromJson(json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  KeySearchRequest copyWith({KeySearchCriteria? search}) {
    return KeySearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Key search response
class KeySearchResponse {
  final List<Key> keys;
  final int? total;

  KeySearchResponse({List<Key>? keys, this.total}) : keys = keys ?? [];

  factory KeySearchResponse.fromJson(Map<String, Object?> json) {
    return KeySearchResponse(
      keys: (json[r'keys'] as List<Object?>?)
              ?.map((i) => Key.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var keys = this.keys;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'keys'] = keys.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  KeySearchResponse copyWith({List<Key>? keys, int? total}) {
    return KeySearchResponse(
      keys: keys ?? this.keys,
      total: total ?? this.total,
    );
  }
}

/// Event to indicate kickstart has been successfully completed.
class KickstartSuccessEvent {
  final String? instanceId;
  final ZonedDateTime? createInstant;
  final String? id;
  final EventInfo? info;
  final String? tenantId;
  final EventType? type;

  KickstartSuccessEvent(
      {this.instanceId,
      this.createInstant,
      this.id,
      this.info,
      this.tenantId,
      this.type});

  factory KickstartSuccessEvent.fromJson(Map<String, Object?> json) {
    return KickstartSuccessEvent(
      instanceId: json[r'instanceId'] as String?,
      createInstant:
          (json[r'createInstant'] as num?)?.toInt() as ZonedDateTime?,
      id: json[r'id'] as String?,
      info: json[r'info'] != null
          ? EventInfo.fromJson(json[r'info']! as Map<String, Object?>)
          : null,
      tenantId: json[r'tenantId'] as String?,
      type: json[r'type'] != null
          ? EventType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var instanceId = this.instanceId;
    var createInstant = this.createInstant;
    var id = this.id;
    var info = this.info;
    var tenantId = this.tenantId;
    var type = this.type;

    final json = <String, Object?>{};
    if (instanceId != null) {
      json[r'instanceId'] = instanceId;
    }
    if (createInstant != null) {
      json[r'createInstant'] = createInstant.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (info != null) {
      json[r'info'] = info.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  KickstartSuccessEvent copyWith(
      {String? instanceId,
      ZonedDateTime? createInstant,
      String? id,
      EventInfo? info,
      String? tenantId,
      EventType? type}) {
    return KickstartSuccessEvent(
      instanceId: instanceId ?? this.instanceId,
      createInstant: createInstant ?? this.createInstant,
      id: id ?? this.id,
      info: info ?? this.info,
      tenantId: tenantId ?? this.tenantId,
      type: type ?? this.type,
    );
  }
}

/// Models an LDAP connector.
class LDAPConnectorConfiguration {
  final String? authenticationUrl;
  final String? baseStructure;
  final int? connectTimeout;
  final String? identifyingAttribute;
  final ConnectorLambdaConfiguration? lambdaConfiguration;
  final String? loginIdAttribute;
  final int? readTimeout;
  final List<String> requestedAttributes;
  final LDAPSecurityMethod? securityMethod;
  final String? systemAccountDn;
  final String? systemAccountPassword;
  final Map<String, dynamic>? data;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final ConnectorType? type;

  LDAPConnectorConfiguration(
      {this.authenticationUrl,
      this.baseStructure,
      this.connectTimeout,
      this.identifyingAttribute,
      this.lambdaConfiguration,
      this.loginIdAttribute,
      this.readTimeout,
      List<String>? requestedAttributes,
      this.securityMethod,
      this.systemAccountDn,
      this.systemAccountPassword,
      this.data,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.name,
      this.type})
      : requestedAttributes = requestedAttributes ?? [],
        debug = debug ?? false;

  factory LDAPConnectorConfiguration.fromJson(Map<String, Object?> json) {
    return LDAPConnectorConfiguration(
      authenticationUrl: json[r'authenticationURL'] as String?,
      baseStructure: json[r'baseStructure'] as String?,
      connectTimeout: (json[r'connectTimeout'] as num?)?.toInt(),
      identifyingAttribute: json[r'identifyingAttribute'] as String?,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? ConnectorLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      loginIdAttribute: json[r'loginIdAttribute'] as String?,
      readTimeout: (json[r'readTimeout'] as num?)?.toInt(),
      requestedAttributes: (json[r'requestedAttributes'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      securityMethod: json[r'securityMethod'] != null
          ? LDAPSecurityMethod.fromValue(json[r'securityMethod']! as String)
          : null,
      systemAccountDn: json[r'systemAccountDN'] as String?,
      systemAccountPassword: json[r'systemAccountPassword'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      type: json[r'type'] != null
          ? ConnectorType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var authenticationUrl = this.authenticationUrl;
    var baseStructure = this.baseStructure;
    var connectTimeout = this.connectTimeout;
    var identifyingAttribute = this.identifyingAttribute;
    var lambdaConfiguration = this.lambdaConfiguration;
    var loginIdAttribute = this.loginIdAttribute;
    var readTimeout = this.readTimeout;
    var requestedAttributes = this.requestedAttributes;
    var securityMethod = this.securityMethod;
    var systemAccountDn = this.systemAccountDn;
    var systemAccountPassword = this.systemAccountPassword;
    var data = this.data;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var type = this.type;

    final json = <String, Object?>{};
    if (authenticationUrl != null) {
      json[r'authenticationURL'] = authenticationUrl;
    }
    if (baseStructure != null) {
      json[r'baseStructure'] = baseStructure;
    }
    if (connectTimeout != null) {
      json[r'connectTimeout'] = connectTimeout;
    }
    if (identifyingAttribute != null) {
      json[r'identifyingAttribute'] = identifyingAttribute;
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (loginIdAttribute != null) {
      json[r'loginIdAttribute'] = loginIdAttribute;
    }
    if (readTimeout != null) {
      json[r'readTimeout'] = readTimeout;
    }
    json[r'requestedAttributes'] = requestedAttributes;
    if (securityMethod != null) {
      json[r'securityMethod'] = securityMethod.value;
    }
    if (systemAccountDn != null) {
      json[r'systemAccountDN'] = systemAccountDn;
    }
    if (systemAccountPassword != null) {
      json[r'systemAccountPassword'] = systemAccountPassword;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  LDAPConnectorConfiguration copyWith(
      {String? authenticationUrl,
      String? baseStructure,
      int? connectTimeout,
      String? identifyingAttribute,
      ConnectorLambdaConfiguration? lambdaConfiguration,
      String? loginIdAttribute,
      int? readTimeout,
      List<String>? requestedAttributes,
      LDAPSecurityMethod? securityMethod,
      String? systemAccountDn,
      String? systemAccountPassword,
      Map<String, dynamic>? data,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      ConnectorType? type}) {
    return LDAPConnectorConfiguration(
      authenticationUrl: authenticationUrl ?? this.authenticationUrl,
      baseStructure: baseStructure ?? this.baseStructure,
      connectTimeout: connectTimeout ?? this.connectTimeout,
      identifyingAttribute: identifyingAttribute ?? this.identifyingAttribute,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      loginIdAttribute: loginIdAttribute ?? this.loginIdAttribute,
      readTimeout: readTimeout ?? this.readTimeout,
      requestedAttributes: requestedAttributes ?? this.requestedAttributes,
      securityMethod: securityMethod ?? this.securityMethod,
      systemAccountDn: systemAccountDn ?? this.systemAccountDn,
      systemAccountPassword:
          systemAccountPassword ?? this.systemAccountPassword,
      data: data ?? this.data,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      type: type ?? this.type,
    );
  }
}

/// A JavaScript lambda function that is executed during certain events inside
/// FusionAuth.
class Lambda {
  final String? body;
  final bool debug;
  final LambdaEngineType? engineType;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final LambdaType? type;

  Lambda(
      {this.body,
      bool? debug,
      this.engineType,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.name,
      this.type})
      : debug = debug ?? false;

  factory Lambda.fromJson(Map<String, Object?> json) {
    return Lambda(
      body: json[r'body'] as String?,
      debug: json[r'debug'] as bool? ?? false,
      engineType: json[r'engineType'] != null
          ? LambdaEngineType.fromValue(json[r'engineType']! as String)
          : null,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      type: json[r'type'] != null
          ? LambdaType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var body = this.body;
    var debug = this.debug;
    var engineType = this.engineType;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var type = this.type;

    final json = <String, Object?>{};
    if (body != null) {
      json[r'body'] = body;
    }
    json[r'debug'] = debug;
    if (engineType != null) {
      json[r'engineType'] = engineType.value;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  Lambda copyWith(
      {String? body,
      bool? debug,
      LambdaEngineType? engineType,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      LambdaType? type}) {
    return Lambda(
      body: body ?? this.body,
      debug: debug ?? this.debug,
      engineType: engineType ?? this.engineType,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      type: type ?? this.type,
    );
  }
}

class LambdaConfiguration {
  final String? accessTokenPopulateId;
  final String? idTokenPopulateId;
  final String? samlv2PopulateId;
  final String? selfServiceRegistrationValidationId;
  final String? userinfoPopulateId;

  LambdaConfiguration(
      {this.accessTokenPopulateId,
      this.idTokenPopulateId,
      this.samlv2PopulateId,
      this.selfServiceRegistrationValidationId,
      this.userinfoPopulateId});

  factory LambdaConfiguration.fromJson(Map<String, Object?> json) {
    return LambdaConfiguration(
      accessTokenPopulateId: json[r'accessTokenPopulateId'] as String?,
      idTokenPopulateId: json[r'idTokenPopulateId'] as String?,
      samlv2PopulateId: json[r'samlv2PopulateId'] as String?,
      selfServiceRegistrationValidationId:
          json[r'selfServiceRegistrationValidationId'] as String?,
      userinfoPopulateId: json[r'userinfoPopulateId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var accessTokenPopulateId = this.accessTokenPopulateId;
    var idTokenPopulateId = this.idTokenPopulateId;
    var samlv2PopulateId = this.samlv2PopulateId;
    var selfServiceRegistrationValidationId =
        this.selfServiceRegistrationValidationId;
    var userinfoPopulateId = this.userinfoPopulateId;

    final json = <String, Object?>{};
    if (accessTokenPopulateId != null) {
      json[r'accessTokenPopulateId'] = accessTokenPopulateId;
    }
    if (idTokenPopulateId != null) {
      json[r'idTokenPopulateId'] = idTokenPopulateId;
    }
    if (samlv2PopulateId != null) {
      json[r'samlv2PopulateId'] = samlv2PopulateId;
    }
    if (selfServiceRegistrationValidationId != null) {
      json[r'selfServiceRegistrationValidationId'] =
          selfServiceRegistrationValidationId;
    }
    if (userinfoPopulateId != null) {
      json[r'userinfoPopulateId'] = userinfoPopulateId;
    }
    return json;
  }

  LambdaConfiguration copyWith(
      {String? accessTokenPopulateId,
      String? idTokenPopulateId,
      String? samlv2PopulateId,
      String? selfServiceRegistrationValidationId,
      String? userinfoPopulateId}) {
    return LambdaConfiguration(
      accessTokenPopulateId:
          accessTokenPopulateId ?? this.accessTokenPopulateId,
      idTokenPopulateId: idTokenPopulateId ?? this.idTokenPopulateId,
      samlv2PopulateId: samlv2PopulateId ?? this.samlv2PopulateId,
      selfServiceRegistrationValidationId:
          selfServiceRegistrationValidationId ??
              this.selfServiceRegistrationValidationId,
      userinfoPopulateId: userinfoPopulateId ?? this.userinfoPopulateId,
    );
  }
}

/// Lambda API request object.
class LambdaRequest {
  final Lambda? lambda;

  LambdaRequest({this.lambda});

  factory LambdaRequest.fromJson(Map<String, Object?> json) {
    return LambdaRequest(
      lambda: json[r'lambda'] != null
          ? Lambda.fromJson(json[r'lambda']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var lambda = this.lambda;

    final json = <String, Object?>{};
    if (lambda != null) {
      json[r'lambda'] = lambda.toJson();
    }
    return json;
  }

  LambdaRequest copyWith({Lambda? lambda}) {
    return LambdaRequest(
      lambda: lambda ?? this.lambda,
    );
  }
}

/// Lambda API response object.
class LambdaResponse {
  final Lambda? lambda;
  final List<Lambda> lambdas;

  LambdaResponse({this.lambda, List<Lambda>? lambdas})
      : lambdas = lambdas ?? [];

  factory LambdaResponse.fromJson(Map<String, Object?> json) {
    return LambdaResponse(
      lambda: json[r'lambda'] != null
          ? Lambda.fromJson(json[r'lambda']! as Map<String, Object?>)
          : null,
      lambdas: (json[r'lambdas'] as List<Object?>?)
              ?.map((i) =>
                  Lambda.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var lambda = this.lambda;
    var lambdas = this.lambdas;

    final json = <String, Object?>{};
    if (lambda != null) {
      json[r'lambda'] = lambda.toJson();
    }
    json[r'lambdas'] = lambdas.map((i) => i.toJson()).toList();
    return json;
  }

  LambdaResponse copyWith({Lambda? lambda, List<Lambda>? lambdas}) {
    return LambdaResponse(
      lambda: lambda ?? this.lambda,
      lambdas: lambdas ?? this.lambdas,
    );
  }
}

/// Search criteria for Lambdas
class LambdaSearchCriteria {
  final String? body;
  final String? name;
  final LambdaType? type;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  LambdaSearchCriteria(
      {this.body,
      this.name,
      this.type,
      this.numberOfResults,
      this.orderBy,
      this.startRow});

  factory LambdaSearchCriteria.fromJson(Map<String, Object?> json) {
    return LambdaSearchCriteria(
      body: json[r'body'] as String?,
      name: json[r'name'] as String?,
      type: json[r'type'] != null
          ? LambdaType.fromValue(json[r'type']! as String)
          : null,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var body = this.body;
    var name = this.name;
    var type = this.type;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (body != null) {
      json[r'body'] = body;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  LambdaSearchCriteria copyWith(
      {String? body,
      String? name,
      LambdaType? type,
      int? numberOfResults,
      String? orderBy,
      int? startRow}) {
    return LambdaSearchCriteria(
      body: body ?? this.body,
      name: name ?? this.name,
      type: type ?? this.type,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Search request for Lambdas
class LambdaSearchRequest {
  final LambdaSearchCriteria? search;

  LambdaSearchRequest({this.search});

  factory LambdaSearchRequest.fromJson(Map<String, Object?> json) {
    return LambdaSearchRequest(
      search: json[r'search'] != null
          ? LambdaSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  LambdaSearchRequest copyWith({LambdaSearchCriteria? search}) {
    return LambdaSearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Lambda search response
class LambdaSearchResponse {
  final List<Lambda> lambdas;
  final int? total;

  LambdaSearchResponse({List<Lambda>? lambdas, this.total})
      : lambdas = lambdas ?? [];

  factory LambdaSearchResponse.fromJson(Map<String, Object?> json) {
    return LambdaSearchResponse(
      lambdas: (json[r'lambdas'] as List<Object?>?)
              ?.map((i) =>
                  Lambda.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var lambdas = this.lambdas;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'lambdas'] = lambdas.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  LambdaSearchResponse copyWith({List<Lambda>? lambdas, int? total}) {
    return LambdaSearchResponse(
      lambdas: lambdas ?? this.lambdas,
      total: total ?? this.total,
    );
  }
}

class LinkedInApplicationConfiguration {
  final String? buttonText;
  final String? clientId;
  final String? clientSecret;
  final String? scope;
  final Map<String, dynamic>? data;
  final bool createRegistration;

  LinkedInApplicationConfiguration(
      {this.buttonText,
      this.clientId,
      this.clientSecret,
      this.scope,
      this.data,
      bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory LinkedInApplicationConfiguration.fromJson(Map<String, Object?> json) {
    return LinkedInApplicationConfiguration(
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      scope: json[r'scope'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var scope = this.scope;
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  LinkedInApplicationConfiguration copyWith(
      {String? buttonText,
      String? clientId,
      String? clientSecret,
      String? scope,
      Map<String, dynamic>? data,
      bool? createRegistration}) {
    return LinkedInApplicationConfiguration(
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      scope: scope ?? this.scope,
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

class LinkedInIdentityProvider {
  final String? buttonText;
  final String? clientId;
  final String? clientSecret;
  final String? scope;
  final Map<String, dynamic>? data;
  final Map<String, dynamic>? applicationConfiguration;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ProviderLambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final IdentityProviderLinkingStrategy? linkingStrategy;
  final String? name;
  final Map<String, dynamic>? tenantConfiguration;
  final IdentityProviderType? type;

  LinkedInIdentityProvider(
      {this.buttonText,
      this.clientId,
      this.clientSecret,
      this.scope,
      this.data,
      this.applicationConfiguration,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.linkingStrategy,
      this.name,
      this.tenantConfiguration,
      this.type})
      : debug = debug ?? false;

  factory LinkedInIdentityProvider.fromJson(Map<String, Object?> json) {
    return LinkedInIdentityProvider(
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      scope: json[r'scope'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      applicationConfiguration:
          json[r'applicationConfiguration'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? ProviderLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      linkingStrategy: json[r'linkingStrategy'] != null
          ? IdentityProviderLinkingStrategy.fromValue(
              json[r'linkingStrategy']! as String)
          : null,
      name: json[r'name'] as String?,
      tenantConfiguration:
          json[r'tenantConfiguration'] as Map<String, Object?>?,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var scope = this.scope;
    var data = this.data;
    var applicationConfiguration = this.applicationConfiguration;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var linkingStrategy = this.linkingStrategy;
    var name = this.name;
    var tenantConfiguration = this.tenantConfiguration;
    var type = this.type;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (applicationConfiguration != null) {
      json[r'applicationConfiguration'] = applicationConfiguration;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (linkingStrategy != null) {
      json[r'linkingStrategy'] = linkingStrategy.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (tenantConfiguration != null) {
      json[r'tenantConfiguration'] = tenantConfiguration;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  LinkedInIdentityProvider copyWith(
      {String? buttonText,
      String? clientId,
      String? clientSecret,
      String? scope,
      Map<String, dynamic>? data,
      Map<String, dynamic>? applicationConfiguration,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ProviderLambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      IdentityProviderLinkingStrategy? linkingStrategy,
      String? name,
      Map<String, dynamic>? tenantConfiguration,
      IdentityProviderType? type}) {
    return LinkedInIdentityProvider(
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      scope: scope ?? this.scope,
      data: data ?? this.data,
      applicationConfiguration:
          applicationConfiguration ?? this.applicationConfiguration,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      linkingStrategy: linkingStrategy ?? this.linkingStrategy,
      name: name ?? this.name,
      tenantConfiguration: tenantConfiguration ?? this.tenantConfiguration,
      type: type ?? this.type,
    );
  }
}

/// Models a set of localized Integers that can be stored as JSON.
class LocalizedIntegers {
  LocalizedIntegers();

  factory LocalizedIntegers.fromJson(Map<String, Object?> json) {
    return LocalizedIntegers();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// Models a set of localized Strings that can be stored as JSON.
class LocalizedStrings {
  LocalizedStrings();

  factory LocalizedStrings.fromJson(Map<String, Object?> json) {
    return LocalizedStrings();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// Location information. Useful for IP addresses and other displayable data
/// objects.
class Location {
  final String? city;
  final String? country;
  final num? latitude;
  final num? longitude;
  final String? region;
  final String? zipcode;
  final String? displayString;

  Location(
      {this.city,
      this.country,
      this.latitude,
      this.longitude,
      this.region,
      this.zipcode,
      this.displayString});

  factory Location.fromJson(Map<String, Object?> json) {
    return Location(
      city: json[r'city'] as String?,
      country: json[r'country'] as String?,
      latitude: json[r'latitude'] as num?,
      longitude: json[r'longitude'] as num?,
      region: json[r'region'] as String?,
      zipcode: json[r'zipcode'] as String?,
      displayString: json[r'displayString'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var city = this.city;
    var country = this.country;
    var latitude = this.latitude;
    var longitude = this.longitude;
    var region = this.region;
    var zipcode = this.zipcode;
    var displayString = this.displayString;

    final json = <String, Object?>{};
    if (city != null) {
      json[r'city'] = city;
    }
    if (country != null) {
      json[r'country'] = country;
    }
    if (latitude != null) {
      json[r'latitude'] = latitude;
    }
    if (longitude != null) {
      json[r'longitude'] = longitude;
    }
    if (region != null) {
      json[r'region'] = region;
    }
    if (zipcode != null) {
      json[r'zipcode'] = zipcode;
    }
    if (displayString != null) {
      json[r'displayString'] = displayString;
    }
    return json;
  }

  Location copyWith(
      {String? city,
      String? country,
      num? latitude,
      num? longitude,
      String? region,
      String? zipcode,
      String? displayString}) {
    return Location(
      city: city ?? this.city,
      country: country ?? this.country,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      region: region ?? this.region,
      zipcode: zipcode ?? this.zipcode,
      displayString: displayString ?? this.displayString,
    );
  }
}

/// A historical state of a user log event. Since events can be modified, this
/// stores the historical state.
class LogHistory {
  final List<HistoryItem> historyItems;

  LogHistory({List<HistoryItem>? historyItems})
      : historyItems = historyItems ?? [];

  factory LogHistory.fromJson(Map<String, Object?> json) {
    return LogHistory(
      historyItems: (json[r'historyItems'] as List<Object?>?)
              ?.map((i) =>
                  HistoryItem.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var historyItems = this.historyItems;

    final json = <String, Object?>{};
    json[r'historyItems'] = historyItems.map((i) => i.toJson()).toList();
    return json;
  }

  LogHistory copyWith({List<HistoryItem>? historyItems}) {
    return LogHistory(
      historyItems: historyItems ?? this.historyItems,
    );
  }
}

class LoginConfiguration {
  final bool allowTokenRefresh;
  final bool generateRefreshTokens;
  final bool requireAuthentication;

  LoginConfiguration(
      {bool? allowTokenRefresh,
      bool? generateRefreshTokens,
      bool? requireAuthentication})
      : allowTokenRefresh = allowTokenRefresh ?? false,
        generateRefreshTokens = generateRefreshTokens ?? false,
        requireAuthentication = requireAuthentication ?? false;

  factory LoginConfiguration.fromJson(Map<String, Object?> json) {
    return LoginConfiguration(
      allowTokenRefresh: json[r'allowTokenRefresh'] as bool? ?? false,
      generateRefreshTokens: json[r'generateRefreshTokens'] as bool? ?? false,
      requireAuthentication: json[r'requireAuthentication'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var allowTokenRefresh = this.allowTokenRefresh;
    var generateRefreshTokens = this.generateRefreshTokens;
    var requireAuthentication = this.requireAuthentication;

    final json = <String, Object?>{};
    json[r'allowTokenRefresh'] = allowTokenRefresh;
    json[r'generateRefreshTokens'] = generateRefreshTokens;
    json[r'requireAuthentication'] = requireAuthentication;
    return json;
  }

  LoginConfiguration copyWith(
      {bool? allowTokenRefresh,
      bool? generateRefreshTokens,
      bool? requireAuthentication}) {
    return LoginConfiguration(
      allowTokenRefresh: allowTokenRefresh ?? this.allowTokenRefresh,
      generateRefreshTokens:
          generateRefreshTokens ?? this.generateRefreshTokens,
      requireAuthentication:
          requireAuthentication ?? this.requireAuthentication,
    );
  }
}

class LoginHintConfiguration {
  final String? parameterName;
  final bool enabled;

  LoginHintConfiguration({this.parameterName, bool? enabled})
      : enabled = enabled ?? false;

  factory LoginHintConfiguration.fromJson(Map<String, Object?> json) {
    return LoginHintConfiguration(
      parameterName: json[r'parameterName'] as String?,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var parameterName = this.parameterName;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (parameterName != null) {
      json[r'parameterName'] = parameterName;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  LoginHintConfiguration copyWith({String? parameterName, bool? enabled}) {
    return LoginHintConfiguration(
      parameterName: parameterName ?? this.parameterName,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Login Ping API request object.
class LoginPingRequest {
  final String? userId;
  final String? applicationId;
  final String? ipAddress;
  final MetaData? metaData;
  final bool newDevice;
  final bool noJwt;

  LoginPingRequest(
      {this.userId,
      this.applicationId,
      this.ipAddress,
      this.metaData,
      bool? newDevice,
      bool? noJwt})
      : newDevice = newDevice ?? false,
        noJwt = noJwt ?? false;

  factory LoginPingRequest.fromJson(Map<String, Object?> json) {
    return LoginPingRequest(
      userId: json[r'userId'] as String?,
      applicationId: json[r'applicationId'] as String?,
      ipAddress: json[r'ipAddress'] as String?,
      metaData: json[r'metaData'] != null
          ? MetaData.fromJson(json[r'metaData']! as Map<String, Object?>)
          : null,
      newDevice: json[r'newDevice'] as bool? ?? false,
      noJwt: json[r'noJWT'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var userId = this.userId;
    var applicationId = this.applicationId;
    var ipAddress = this.ipAddress;
    var metaData = this.metaData;
    var newDevice = this.newDevice;
    var noJwt = this.noJwt;

    final json = <String, Object?>{};
    if (userId != null) {
      json[r'userId'] = userId;
    }
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (ipAddress != null) {
      json[r'ipAddress'] = ipAddress;
    }
    if (metaData != null) {
      json[r'metaData'] = metaData.toJson();
    }
    json[r'newDevice'] = newDevice;
    json[r'noJWT'] = noJwt;
    return json;
  }

  LoginPingRequest copyWith(
      {String? userId,
      String? applicationId,
      String? ipAddress,
      MetaData? metaData,
      bool? newDevice,
      bool? noJwt}) {
    return LoginPingRequest(
      userId: userId ?? this.userId,
      applicationId: applicationId ?? this.applicationId,
      ipAddress: ipAddress ?? this.ipAddress,
      metaData: metaData ?? this.metaData,
      newDevice: newDevice ?? this.newDevice,
      noJwt: noJwt ?? this.noJwt,
    );
  }
}

/// The summary of the action that is preventing login to be returned on the
/// login response.
class LoginPreventedResponse {
  final String? actionId;
  final String? actionerUserId;
  final ZonedDateTime? expiry;
  final String? localizedName;
  final String? localizedOption;
  final String? localizedReason;
  final String? name;
  final String? option;
  final String? reason;
  final String? reasonCode;

  LoginPreventedResponse(
      {this.actionId,
      this.actionerUserId,
      this.expiry,
      this.localizedName,
      this.localizedOption,
      this.localizedReason,
      this.name,
      this.option,
      this.reason,
      this.reasonCode});

  factory LoginPreventedResponse.fromJson(Map<String, Object?> json) {
    return LoginPreventedResponse(
      actionId: json[r'actionId'] as String?,
      actionerUserId: json[r'actionerUserId'] as String?,
      expiry: (json[r'expiry'] as num?)?.toInt() as ZonedDateTime?,
      localizedName: json[r'localizedName'] as String?,
      localizedOption: json[r'localizedOption'] as String?,
      localizedReason: json[r'localizedReason'] as String?,
      name: json[r'name'] as String?,
      option: json[r'option'] as String?,
      reason: json[r'reason'] as String?,
      reasonCode: json[r'reasonCode'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var actionId = this.actionId;
    var actionerUserId = this.actionerUserId;
    var expiry = this.expiry;
    var localizedName = this.localizedName;
    var localizedOption = this.localizedOption;
    var localizedReason = this.localizedReason;
    var name = this.name;
    var option = this.option;
    var reason = this.reason;
    var reasonCode = this.reasonCode;

    final json = <String, Object?>{};
    if (actionId != null) {
      json[r'actionId'] = actionId;
    }
    if (actionerUserId != null) {
      json[r'actionerUserId'] = actionerUserId;
    }
    if (expiry != null) {
      json[r'expiry'] = expiry.toJson();
    }
    if (localizedName != null) {
      json[r'localizedName'] = localizedName;
    }
    if (localizedOption != null) {
      json[r'localizedOption'] = localizedOption;
    }
    if (localizedReason != null) {
      json[r'localizedReason'] = localizedReason;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (option != null) {
      json[r'option'] = option;
    }
    if (reason != null) {
      json[r'reason'] = reason;
    }
    if (reasonCode != null) {
      json[r'reasonCode'] = reasonCode;
    }
    return json;
  }

  LoginPreventedResponse copyWith(
      {String? actionId,
      String? actionerUserId,
      ZonedDateTime? expiry,
      String? localizedName,
      String? localizedOption,
      String? localizedReason,
      String? name,
      String? option,
      String? reason,
      String? reasonCode}) {
    return LoginPreventedResponse(
      actionId: actionId ?? this.actionId,
      actionerUserId: actionerUserId ?? this.actionerUserId,
      expiry: expiry ?? this.expiry,
      localizedName: localizedName ?? this.localizedName,
      localizedOption: localizedOption ?? this.localizedOption,
      localizedReason: localizedReason ?? this.localizedReason,
      name: name ?? this.name,
      option: option ?? this.option,
      reason: reason ?? this.reason,
      reasonCode: reasonCode ?? this.reasonCode,
    );
  }
}

class LoginRecordConfiguration {
  final DeleteConfiguration? delete;

  LoginRecordConfiguration({this.delete});

  factory LoginRecordConfiguration.fromJson(Map<String, Object?> json) {
    return LoginRecordConfiguration(
      delete: json[r'delete'] != null
          ? DeleteConfiguration.fromJson(
              json[r'delete']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var delete = this.delete;

    final json = <String, Object?>{};
    if (delete != null) {
      json[r'delete'] = delete.toJson();
    }
    return json;
  }

  LoginRecordConfiguration copyWith({DeleteConfiguration? delete}) {
    return LoginRecordConfiguration(
      delete: delete ?? this.delete,
    );
  }
}

class LoginRecordExportRequest {
  final LoginRecordSearchCriteria? criteria;
  final String? dateTimeSecondsFormat;
  final ZoneId? zoneId;

  LoginRecordExportRequest(
      {this.criteria, this.dateTimeSecondsFormat, this.zoneId});

  factory LoginRecordExportRequest.fromJson(Map<String, Object?> json) {
    return LoginRecordExportRequest(
      criteria: json[r'criteria'] != null
          ? LoginRecordSearchCriteria.fromJson(
              json[r'criteria']! as Map<String, Object?>)
          : null,
      dateTimeSecondsFormat: json[r'dateTimeSecondsFormat'] as String?,
      zoneId: json[r'zoneId'] as ZoneId?,
    );
  }

  Map<String, Object?> toJson() {
    var criteria = this.criteria;
    var dateTimeSecondsFormat = this.dateTimeSecondsFormat;
    var zoneId = this.zoneId;

    final json = <String, Object?>{};
    if (criteria != null) {
      json[r'criteria'] = criteria.toJson();
    }
    if (dateTimeSecondsFormat != null) {
      json[r'dateTimeSecondsFormat'] = dateTimeSecondsFormat;
    }
    if (zoneId != null) {
      json[r'zoneId'] = zoneId.toJson();
    }
    return json;
  }

  LoginRecordExportRequest copyWith(
      {LoginRecordSearchCriteria? criteria,
      String? dateTimeSecondsFormat,
      ZoneId? zoneId}) {
    return LoginRecordExportRequest(
      criteria: criteria ?? this.criteria,
      dateTimeSecondsFormat:
          dateTimeSecondsFormat ?? this.dateTimeSecondsFormat,
      zoneId: zoneId ?? this.zoneId,
    );
  }
}

class LoginRecordSearchCriteria {
  final String? applicationId;
  final ZonedDateTime? end;
  final ZonedDateTime? start;
  final String? userId;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  LoginRecordSearchCriteria(
      {this.applicationId,
      this.end,
      this.start,
      this.userId,
      this.numberOfResults,
      this.orderBy,
      this.startRow});

  factory LoginRecordSearchCriteria.fromJson(Map<String, Object?> json) {
    return LoginRecordSearchCriteria(
      applicationId: json[r'applicationId'] as String?,
      end: (json[r'end'] as num?)?.toInt() as ZonedDateTime?,
      start: (json[r'start'] as num?)?.toInt() as ZonedDateTime?,
      userId: json[r'userId'] as String?,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var end = this.end;
    var start = this.start;
    var userId = this.userId;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (end != null) {
      json[r'end'] = end.toJson();
    }
    if (start != null) {
      json[r'start'] = start.toJson();
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  LoginRecordSearchCriteria copyWith(
      {String? applicationId,
      ZonedDateTime? end,
      ZonedDateTime? start,
      String? userId,
      int? numberOfResults,
      String? orderBy,
      int? startRow}) {
    return LoginRecordSearchCriteria(
      applicationId: applicationId ?? this.applicationId,
      end: end ?? this.end,
      start: start ?? this.start,
      userId: userId ?? this.userId,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

class LoginRecordSearchRequest {
  final bool retrieveTotal;
  final LoginRecordSearchCriteria? search;

  LoginRecordSearchRequest({bool? retrieveTotal, this.search})
      : retrieveTotal = retrieveTotal ?? false;

  factory LoginRecordSearchRequest.fromJson(Map<String, Object?> json) {
    return LoginRecordSearchRequest(
      retrieveTotal: json[r'retrieveTotal'] as bool? ?? false,
      search: json[r'search'] != null
          ? LoginRecordSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var retrieveTotal = this.retrieveTotal;
    var search = this.search;

    final json = <String, Object?>{};
    json[r'retrieveTotal'] = retrieveTotal;
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  LoginRecordSearchRequest copyWith(
      {bool? retrieveTotal, LoginRecordSearchCriteria? search}) {
    return LoginRecordSearchRequest(
      retrieveTotal: retrieveTotal ?? this.retrieveTotal,
      search: search ?? this.search,
    );
  }
}

/// A raw login record response
class LoginRecordSearchResponse {
  final List<DisplayableRawLogin> logins;
  final int? total;

  LoginRecordSearchResponse({List<DisplayableRawLogin>? logins, this.total})
      : logins = logins ?? [];

  factory LoginRecordSearchResponse.fromJson(Map<String, Object?> json) {
    return LoginRecordSearchResponse(
      logins: (json[r'logins'] as List<Object?>?)
              ?.map((i) => DisplayableRawLogin.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var logins = this.logins;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'logins'] = logins.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  LoginRecordSearchResponse copyWith(
      {List<DisplayableRawLogin>? logins, int? total}) {
    return LoginRecordSearchResponse(
      logins: logins ?? this.logins,
      total: total ?? this.total,
    );
  }
}

/// Response for the login report.
class LoginReportResponse {
  final List<Count> hourlyCounts;
  final int? total;

  LoginReportResponse({List<Count>? hourlyCounts, this.total})
      : hourlyCounts = hourlyCounts ?? [];

  factory LoginReportResponse.fromJson(Map<String, Object?> json) {
    return LoginReportResponse(
      hourlyCounts: (json[r'hourlyCounts'] as List<Object?>?)
              ?.map(
                  (i) => Count.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var hourlyCounts = this.hourlyCounts;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'hourlyCounts'] = hourlyCounts.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  LoginReportResponse copyWith({List<Count>? hourlyCounts, int? total}) {
    return LoginReportResponse(
      hourlyCounts: hourlyCounts ?? this.hourlyCounts,
      total: total ?? this.total,
    );
  }
}

/// Login API request object.
class LoginRequest {
  final String? loginId;
  final String? oneTimePassword;
  final String? password;
  final String? twoFactorTrustId;
  final String? applicationId;
  final String? ipAddress;
  final MetaData? metaData;
  final bool newDevice;
  final bool noJwt;

  LoginRequest(
      {this.loginId,
      this.oneTimePassword,
      this.password,
      this.twoFactorTrustId,
      this.applicationId,
      this.ipAddress,
      this.metaData,
      bool? newDevice,
      bool? noJwt})
      : newDevice = newDevice ?? false,
        noJwt = noJwt ?? false;

  factory LoginRequest.fromJson(Map<String, Object?> json) {
    return LoginRequest(
      loginId: json[r'loginId'] as String?,
      oneTimePassword: json[r'oneTimePassword'] as String?,
      password: json[r'password'] as String?,
      twoFactorTrustId: json[r'twoFactorTrustId'] as String?,
      applicationId: json[r'applicationId'] as String?,
      ipAddress: json[r'ipAddress'] as String?,
      metaData: json[r'metaData'] != null
          ? MetaData.fromJson(json[r'metaData']! as Map<String, Object?>)
          : null,
      newDevice: json[r'newDevice'] as bool? ?? false,
      noJwt: json[r'noJWT'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var loginId = this.loginId;
    var oneTimePassword = this.oneTimePassword;
    var password = this.password;
    var twoFactorTrustId = this.twoFactorTrustId;
    var applicationId = this.applicationId;
    var ipAddress = this.ipAddress;
    var metaData = this.metaData;
    var newDevice = this.newDevice;
    var noJwt = this.noJwt;

    final json = <String, Object?>{};
    if (loginId != null) {
      json[r'loginId'] = loginId;
    }
    if (oneTimePassword != null) {
      json[r'oneTimePassword'] = oneTimePassword;
    }
    if (password != null) {
      json[r'password'] = password;
    }
    if (twoFactorTrustId != null) {
      json[r'twoFactorTrustId'] = twoFactorTrustId;
    }
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (ipAddress != null) {
      json[r'ipAddress'] = ipAddress;
    }
    if (metaData != null) {
      json[r'metaData'] = metaData.toJson();
    }
    json[r'newDevice'] = newDevice;
    json[r'noJWT'] = noJwt;
    return json;
  }

  LoginRequest copyWith(
      {String? loginId,
      String? oneTimePassword,
      String? password,
      String? twoFactorTrustId,
      String? applicationId,
      String? ipAddress,
      MetaData? metaData,
      bool? newDevice,
      bool? noJwt}) {
    return LoginRequest(
      loginId: loginId ?? this.loginId,
      oneTimePassword: oneTimePassword ?? this.oneTimePassword,
      password: password ?? this.password,
      twoFactorTrustId: twoFactorTrustId ?? this.twoFactorTrustId,
      applicationId: applicationId ?? this.applicationId,
      ipAddress: ipAddress ?? this.ipAddress,
      metaData: metaData ?? this.metaData,
      newDevice: newDevice ?? this.newDevice,
      noJwt: noJwt ?? this.noJwt,
    );
  }
}

class LoginResponse {
  final List<LoginPreventedResponse> actions;
  final String? changePasswordId;
  final ChangePasswordReason? changePasswordReason;
  final List<String> configurableMethods;
  final String? emailVerificationId;
  final List<TwoFactorMethod> methods;
  final String? pendingIdpLinkId;
  final String? refreshToken;
  final String? refreshTokenId;
  final String? registrationVerificationId;
  final Map<String, dynamic>? state;
  final List<dynamic> threatsDetected;
  final String? token;
  final ZonedDateTime? tokenExpirationInstant;
  final String? trustToken;
  final String? twoFactorId;
  final String? twoFactorTrustId;
  final User? user;

  LoginResponse(
      {List<LoginPreventedResponse>? actions,
      this.changePasswordId,
      this.changePasswordReason,
      List<String>? configurableMethods,
      this.emailVerificationId,
      List<TwoFactorMethod>? methods,
      this.pendingIdpLinkId,
      this.refreshToken,
      this.refreshTokenId,
      this.registrationVerificationId,
      this.state,
      List<dynamic>? threatsDetected,
      this.token,
      this.tokenExpirationInstant,
      this.trustToken,
      this.twoFactorId,
      this.twoFactorTrustId,
      this.user})
      : actions = actions ?? [],
        configurableMethods = configurableMethods ?? [],
        methods = methods ?? [],
        threatsDetected = threatsDetected ?? [];

  factory LoginResponse.fromJson(Map<String, Object?> json) {
    return LoginResponse(
      actions: (json[r'actions'] as List<Object?>?)
              ?.map((i) => LoginPreventedResponse.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      changePasswordId: json[r'changePasswordId'] as String?,
      changePasswordReason: json[r'changePasswordReason'] != null
          ? ChangePasswordReason.fromValue(
              json[r'changePasswordReason']! as String)
          : null,
      configurableMethods: (json[r'configurableMethods'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      emailVerificationId: json[r'emailVerificationId'] as String?,
      methods: (json[r'methods'] as List<Object?>?)
              ?.map((i) => TwoFactorMethod.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      pendingIdpLinkId: json[r'pendingIdPLinkId'] as String?,
      refreshToken: json[r'refreshToken'] as String?,
      refreshTokenId: json[r'refreshTokenId'] as String?,
      registrationVerificationId:
          json[r'registrationVerificationId'] as String?,
      state: json[r'state'] as Map<String, Object?>?,
      threatsDetected: (json[r'threatsDetected'] as List<Object?>?)
              ?.map((i) => i)
              .toList() ??
          [],
      token: json[r'token'] as String?,
      tokenExpirationInstant:
          (json[r'tokenExpirationInstant'] as num?)?.toInt() as ZonedDateTime?,
      trustToken: json[r'trustToken'] as String?,
      twoFactorId: json[r'twoFactorId'] as String?,
      twoFactorTrustId: json[r'twoFactorTrustId'] as String?,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var actions = this.actions;
    var changePasswordId = this.changePasswordId;
    var changePasswordReason = this.changePasswordReason;
    var configurableMethods = this.configurableMethods;
    var emailVerificationId = this.emailVerificationId;
    var methods = this.methods;
    var pendingIdpLinkId = this.pendingIdpLinkId;
    var refreshToken = this.refreshToken;
    var refreshTokenId = this.refreshTokenId;
    var registrationVerificationId = this.registrationVerificationId;
    var state = this.state;
    var threatsDetected = this.threatsDetected;
    var token = this.token;
    var tokenExpirationInstant = this.tokenExpirationInstant;
    var trustToken = this.trustToken;
    var twoFactorId = this.twoFactorId;
    var twoFactorTrustId = this.twoFactorTrustId;
    var user = this.user;

    final json = <String, Object?>{};
    json[r'actions'] = actions.map((i) => i.toJson()).toList();
    if (changePasswordId != null) {
      json[r'changePasswordId'] = changePasswordId;
    }
    if (changePasswordReason != null) {
      json[r'changePasswordReason'] = changePasswordReason.value;
    }
    json[r'configurableMethods'] = configurableMethods;
    if (emailVerificationId != null) {
      json[r'emailVerificationId'] = emailVerificationId;
    }
    json[r'methods'] = methods.map((i) => i.toJson()).toList();
    if (pendingIdpLinkId != null) {
      json[r'pendingIdPLinkId'] = pendingIdpLinkId;
    }
    if (refreshToken != null) {
      json[r'refreshToken'] = refreshToken;
    }
    if (refreshTokenId != null) {
      json[r'refreshTokenId'] = refreshTokenId;
    }
    if (registrationVerificationId != null) {
      json[r'registrationVerificationId'] = registrationVerificationId;
    }
    if (state != null) {
      json[r'state'] = state;
    }
    json[r'threatsDetected'] = threatsDetected;
    if (token != null) {
      json[r'token'] = token;
    }
    if (tokenExpirationInstant != null) {
      json[r'tokenExpirationInstant'] = tokenExpirationInstant.toJson();
    }
    if (trustToken != null) {
      json[r'trustToken'] = trustToken;
    }
    if (twoFactorId != null) {
      json[r'twoFactorId'] = twoFactorId;
    }
    if (twoFactorTrustId != null) {
      json[r'twoFactorTrustId'] = twoFactorTrustId;
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  LoginResponse copyWith(
      {List<LoginPreventedResponse>? actions,
      String? changePasswordId,
      ChangePasswordReason? changePasswordReason,
      List<String>? configurableMethods,
      String? emailVerificationId,
      List<TwoFactorMethod>? methods,
      String? pendingIdpLinkId,
      String? refreshToken,
      String? refreshTokenId,
      String? registrationVerificationId,
      Map<String, dynamic>? state,
      List<dynamic>? threatsDetected,
      String? token,
      ZonedDateTime? tokenExpirationInstant,
      String? trustToken,
      String? twoFactorId,
      String? twoFactorTrustId,
      User? user}) {
    return LoginResponse(
      actions: actions ?? this.actions,
      changePasswordId: changePasswordId ?? this.changePasswordId,
      changePasswordReason: changePasswordReason ?? this.changePasswordReason,
      configurableMethods: configurableMethods ?? this.configurableMethods,
      emailVerificationId: emailVerificationId ?? this.emailVerificationId,
      methods: methods ?? this.methods,
      pendingIdpLinkId: pendingIdpLinkId ?? this.pendingIdpLinkId,
      refreshToken: refreshToken ?? this.refreshToken,
      refreshTokenId: refreshTokenId ?? this.refreshTokenId,
      registrationVerificationId:
          registrationVerificationId ?? this.registrationVerificationId,
      state: state ?? this.state,
      threatsDetected: threatsDetected ?? this.threatsDetected,
      token: token ?? this.token,
      tokenExpirationInstant:
          tokenExpirationInstant ?? this.tokenExpirationInstant,
      trustToken: trustToken ?? this.trustToken,
      twoFactorId: twoFactorId ?? this.twoFactorId,
      twoFactorTrustId: twoFactorTrustId ?? this.twoFactorTrustId,
      user: user ?? this.user,
    );
  }
}

/// Request for the Logout API that can be used as an alternative to URL
/// parameters.
class LogoutRequest {
  final bool global;
  final String? refreshToken;
  final EventInfo? eventInfo;

  LogoutRequest({bool? global, this.refreshToken, this.eventInfo})
      : global = global ?? false;

  factory LogoutRequest.fromJson(Map<String, Object?> json) {
    return LogoutRequest(
      global: json[r'global'] as bool? ?? false,
      refreshToken: json[r'refreshToken'] as String?,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var global = this.global;
    var refreshToken = this.refreshToken;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    json[r'global'] = global;
    if (refreshToken != null) {
      json[r'refreshToken'] = refreshToken;
    }
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  LogoutRequest copyWith(
      {bool? global, String? refreshToken, EventInfo? eventInfo}) {
    return LogoutRequest(
      global: global ?? this.global,
      refreshToken: refreshToken ?? this.refreshToken,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

class LookupResponse {
  final IdentityProviderDetails? identityProvider;

  LookupResponse({this.identityProvider});

  factory LookupResponse.fromJson(Map<String, Object?> json) {
    return LookupResponse(
      identityProvider: json[r'identityProvider'] != null
          ? IdentityProviderDetails.fromJson(
              json[r'identityProvider']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var identityProvider = this.identityProvider;

    final json = <String, Object?>{};
    if (identityProvider != null) {
      json[r'identityProvider'] = identityProvider.toJson();
    }
    return json;
  }

  LookupResponse copyWith({IdentityProviderDetails? identityProvider}) {
    return LookupResponse(
      identityProvider: identityProvider ?? this.identityProvider,
    );
  }
}

/// This class contains the managed fields that are also put into the database
/// during FusionAuth setup.  <p>  Internal Note: These fields are also declared
/// in SQL in order to bootstrap the system. These need to stay in sync.  Any
/// changes to these fields needs to also be reflected in mysql.sql and
/// postgresql.sql
class ManagedFields {
  ManagedFields();

  factory ManagedFields.fromJson(Map<String, Object?> json) {
    return ManagedFields();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class MaximumPasswordAge {
  final int? days;
  final bool enabled;

  MaximumPasswordAge({this.days, bool? enabled}) : enabled = enabled ?? false;

  factory MaximumPasswordAge.fromJson(Map<String, Object?> json) {
    return MaximumPasswordAge(
      days: (json[r'days'] as num?)?.toInt(),
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var days = this.days;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (days != null) {
      json[r'days'] = days;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  MaximumPasswordAge copyWith({int? days, bool? enabled}) {
    return MaximumPasswordAge(
      days: days ?? this.days,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Group Member Delete Request
class MemberDeleteRequest {
  final List<String> memberIds;
  final List<String> members;

  MemberDeleteRequest({List<String>? memberIds, List<String>? members})
      : memberIds = memberIds ?? [],
        members = members ?? [];

  factory MemberDeleteRequest.fromJson(Map<String, Object?> json) {
    return MemberDeleteRequest(
      memberIds: (json[r'memberIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      members: (json[r'members'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var memberIds = this.memberIds;
    var members = this.members;

    final json = <String, Object?>{};
    json[r'memberIds'] = memberIds;
    json[r'members'] = members;
    return json;
  }

  MemberDeleteRequest copyWith(
      {List<String>? memberIds, List<String>? members}) {
    return MemberDeleteRequest(
      memberIds: memberIds ?? this.memberIds,
      members: members ?? this.members,
    );
  }
}

/// Group Member Request
class MemberRequest {
  final List<GroupMember> members;

  MemberRequest({List<GroupMember>? members}) : members = members ?? [];

  factory MemberRequest.fromJson(Map<String, Object?> json) {
    return MemberRequest(
      members: (json[r'members'] as List<Object?>?)
              ?.map((i) =>
                  GroupMember.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var members = this.members;

    final json = <String, Object?>{};
    json[r'members'] = members.map((i) => i.toJson()).toList();
    return json;
  }

  MemberRequest copyWith({List<GroupMember>? members}) {
    return MemberRequest(
      members: members ?? this.members,
    );
  }
}

/// Group Member Response
class MemberResponse {
  final List<GroupMember> members;

  MemberResponse({List<GroupMember>? members}) : members = members ?? [];

  factory MemberResponse.fromJson(Map<String, Object?> json) {
    return MemberResponse(
      members: (json[r'members'] as List<Object?>?)
              ?.map((i) =>
                  GroupMember.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var members = this.members;

    final json = <String, Object?>{};
    json[r'members'] = members.map((i) => i.toJson()).toList();
    return json;
  }

  MemberResponse copyWith({List<GroupMember>? members}) {
    return MemberResponse(
      members: members ?? this.members,
    );
  }
}

class Message {
  Message();

  factory Message.fromJson(Map<String, Object?> json) {
    return Message();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// Stores an message template used to distribute messages;
class MessageTemplate {
  final Map<String, dynamic>? data;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final MessageType? type;

  MessageTemplate(
      {this.data,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.name,
      this.type});

  factory MessageTemplate.fromJson(Map<String, Object?> json) {
    return MessageTemplate(
      data: json[r'data'] as Map<String, Object?>?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      type: json[r'type'] != null
          ? MessageType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var type = this.type;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  MessageTemplate copyWith(
      {Map<String, dynamic>? data,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      MessageType? type}) {
    return MessageTemplate(
      data: data ?? this.data,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      type: type ?? this.type,
    );
  }
}

/// A Message Template Request to the API
class MessageTemplateRequest {
  final MessageTemplate? messageTemplate;

  MessageTemplateRequest({this.messageTemplate});

  factory MessageTemplateRequest.fromJson(Map<String, Object?> json) {
    return MessageTemplateRequest(
      messageTemplate: json[r'messageTemplate'] != null
          ? MessageTemplate.fromJson(
              json[r'messageTemplate']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var messageTemplate = this.messageTemplate;

    final json = <String, Object?>{};
    if (messageTemplate != null) {
      json[r'messageTemplate'] = messageTemplate.toJson();
    }
    return json;
  }

  MessageTemplateRequest copyWith({MessageTemplate? messageTemplate}) {
    return MessageTemplateRequest(
      messageTemplate: messageTemplate ?? this.messageTemplate,
    );
  }
}

class MessageTemplateResponse {
  final MessageTemplate? messageTemplate;
  final List<MessageTemplate> messageTemplates;

  MessageTemplateResponse(
      {this.messageTemplate, List<MessageTemplate>? messageTemplates})
      : messageTemplates = messageTemplates ?? [];

  factory MessageTemplateResponse.fromJson(Map<String, Object?> json) {
    return MessageTemplateResponse(
      messageTemplate: json[r'messageTemplate'] != null
          ? MessageTemplate.fromJson(
              json[r'messageTemplate']! as Map<String, Object?>)
          : null,
      messageTemplates: (json[r'messageTemplates'] as List<Object?>?)
              ?.map((i) => MessageTemplate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var messageTemplate = this.messageTemplate;
    var messageTemplates = this.messageTemplates;

    final json = <String, Object?>{};
    if (messageTemplate != null) {
      json[r'messageTemplate'] = messageTemplate.toJson();
    }
    json[r'messageTemplates'] =
        messageTemplates.map((i) => i.toJson()).toList();
    return json;
  }

  MessageTemplateResponse copyWith(
      {MessageTemplate? messageTemplate,
      List<MessageTemplate>? messageTemplates}) {
    return MessageTemplateResponse(
      messageTemplate: messageTemplate ?? this.messageTemplate,
      messageTemplates: messageTemplates ?? this.messageTemplates,
    );
  }
}

class MessengerRequest {
  final BaseMessengerConfiguration? messenger;

  MessengerRequest({this.messenger});

  factory MessengerRequest.fromJson(Map<String, Object?> json) {
    return MessengerRequest(
      messenger: json[r'messenger'] != null
          ? BaseMessengerConfiguration.fromJson(
              json[r'messenger']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var messenger = this.messenger;

    final json = <String, Object?>{};
    if (messenger != null) {
      json[r'messenger'] = messenger.toJson();
    }
    return json;
  }

  MessengerRequest copyWith({BaseMessengerConfiguration? messenger}) {
    return MessengerRequest(
      messenger: messenger ?? this.messenger,
    );
  }
}

class MessengerResponse {
  final BaseMessengerConfiguration? messenger;
  final List<BaseMessengerConfiguration> messengers;

  MessengerResponse(
      {this.messenger, List<BaseMessengerConfiguration>? messengers})
      : messengers = messengers ?? [];

  factory MessengerResponse.fromJson(Map<String, Object?> json) {
    return MessengerResponse(
      messenger: json[r'messenger'] != null
          ? BaseMessengerConfiguration.fromJson(
              json[r'messenger']! as Map<String, Object?>)
          : null,
      messengers: (json[r'messengers'] as List<Object?>?)
              ?.map((i) => BaseMessengerConfiguration.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var messenger = this.messenger;
    var messengers = this.messengers;

    final json = <String, Object?>{};
    if (messenger != null) {
      json[r'messenger'] = messenger.toJson();
    }
    json[r'messengers'] = messengers.map((i) => i.toJson()).toList();
    return json;
  }

  MessengerResponse copyWith(
      {BaseMessengerConfiguration? messenger,
      List<BaseMessengerConfiguration>? messengers}) {
    return MessengerResponse(
      messenger: messenger ?? this.messenger,
      messengers: messengers ?? this.messengers,
    );
  }
}

class MessengerTransport {
  MessengerTransport();

  factory MessengerTransport.fromJson(Map<String, Object?> json) {
    return MessengerTransport();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class MetaData {
  final Map<String, dynamic>? data;
  final DeviceInfo? device;
  final List<dynamic> scopes;

  MetaData({this.data, this.device, List<dynamic>? scopes})
      : scopes = scopes ?? [];

  factory MetaData.fromJson(Map<String, Object?> json) {
    return MetaData(
      data: json[r'data'] as Map<String, Object?>?,
      device: json[r'device'] != null
          ? DeviceInfo.fromJson(json[r'device']! as Map<String, Object?>)
          : null,
      scopes: (json[r'scopes'] as List<Object?>?)?.map((i) => i).toList() ?? [],
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var device = this.device;
    var scopes = this.scopes;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (device != null) {
      json[r'device'] = device.toJson();
    }
    json[r'scopes'] = scopes;
    return json;
  }

  MetaData copyWith(
      {Map<String, dynamic>? data, DeviceInfo? device, List<dynamic>? scopes}) {
    return MetaData(
      data: data ?? this.data,
      device: device ?? this.device,
      scopes: scopes ?? this.scopes,
    );
  }
}

class MinimumPasswordAge {
  final int? seconds;
  final bool enabled;

  MinimumPasswordAge({this.seconds, bool? enabled})
      : enabled = enabled ?? false;

  factory MinimumPasswordAge.fromJson(Map<String, Object?> json) {
    return MinimumPasswordAge(
      seconds: (json[r'seconds'] as num?)?.toInt(),
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var seconds = this.seconds;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (seconds != null) {
      json[r'seconds'] = seconds;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  MinimumPasswordAge copyWith({int? seconds, bool? enabled}) {
    return MinimumPasswordAge(
      seconds: seconds ?? this.seconds,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Response for the daily active user report.
class MonthlyActiveUserReportResponse {
  final List<Count> monthlyActiveUsers;
  final int? total;

  MonthlyActiveUserReportResponse({List<Count>? monthlyActiveUsers, this.total})
      : monthlyActiveUsers = monthlyActiveUsers ?? [];

  factory MonthlyActiveUserReportResponse.fromJson(Map<String, Object?> json) {
    return MonthlyActiveUserReportResponse(
      monthlyActiveUsers: (json[r'monthlyActiveUsers'] as List<Object?>?)
              ?.map(
                  (i) => Count.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var monthlyActiveUsers = this.monthlyActiveUsers;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'monthlyActiveUsers'] =
        monthlyActiveUsers.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  MonthlyActiveUserReportResponse copyWith(
      {List<Count>? monthlyActiveUsers, int? total}) {
    return MonthlyActiveUserReportResponse(
      monthlyActiveUsers: monthlyActiveUsers ?? this.monthlyActiveUsers,
      total: total ?? this.total,
    );
  }
}

class MultiFactorAuthenticatorMethod {
  final TOTPAlgorithm? algorithm;
  final int? codeLength;
  final int? timeStep;
  final bool enabled;

  MultiFactorAuthenticatorMethod(
      {this.algorithm, this.codeLength, this.timeStep, bool? enabled})
      : enabled = enabled ?? false;

  factory MultiFactorAuthenticatorMethod.fromJson(Map<String, Object?> json) {
    return MultiFactorAuthenticatorMethod(
      algorithm: json[r'algorithm'] != null
          ? TOTPAlgorithm.fromValue(json[r'algorithm']! as String)
          : null,
      codeLength: (json[r'codeLength'] as num?)?.toInt(),
      timeStep: (json[r'timeStep'] as num?)?.toInt(),
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var algorithm = this.algorithm;
    var codeLength = this.codeLength;
    var timeStep = this.timeStep;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (algorithm != null) {
      json[r'algorithm'] = algorithm.value;
    }
    if (codeLength != null) {
      json[r'codeLength'] = codeLength;
    }
    if (timeStep != null) {
      json[r'timeStep'] = timeStep;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  MultiFactorAuthenticatorMethod copyWith(
      {TOTPAlgorithm? algorithm,
      int? codeLength,
      int? timeStep,
      bool? enabled}) {
    return MultiFactorAuthenticatorMethod(
      algorithm: algorithm ?? this.algorithm,
      codeLength: codeLength ?? this.codeLength,
      timeStep: timeStep ?? this.timeStep,
      enabled: enabled ?? this.enabled,
    );
  }
}

class MultiFactorEmailMethod {
  final String? templateId;
  final bool enabled;

  MultiFactorEmailMethod({this.templateId, bool? enabled})
      : enabled = enabled ?? false;

  factory MultiFactorEmailMethod.fromJson(Map<String, Object?> json) {
    return MultiFactorEmailMethod(
      templateId: json[r'templateId'] as String?,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var templateId = this.templateId;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (templateId != null) {
      json[r'templateId'] = templateId;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  MultiFactorEmailMethod copyWith({String? templateId, bool? enabled}) {
    return MultiFactorEmailMethod(
      templateId: templateId ?? this.templateId,
      enabled: enabled ?? this.enabled,
    );
  }
}

class MultiFactorEmailTemplate {
  final String? templateId;

  MultiFactorEmailTemplate({this.templateId});

  factory MultiFactorEmailTemplate.fromJson(Map<String, Object?> json) {
    return MultiFactorEmailTemplate(
      templateId: json[r'templateId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var templateId = this.templateId;

    final json = <String, Object?>{};
    if (templateId != null) {
      json[r'templateId'] = templateId;
    }
    return json;
  }

  MultiFactorEmailTemplate copyWith({String? templateId}) {
    return MultiFactorEmailTemplate(
      templateId: templateId ?? this.templateId,
    );
  }
}

class MultiFactorSMSMethod {
  final String? messengerId;
  final String? templateId;
  final bool enabled;

  MultiFactorSMSMethod({this.messengerId, this.templateId, bool? enabled})
      : enabled = enabled ?? false;

  factory MultiFactorSMSMethod.fromJson(Map<String, Object?> json) {
    return MultiFactorSMSMethod(
      messengerId: json[r'messengerId'] as String?,
      templateId: json[r'templateId'] as String?,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var messengerId = this.messengerId;
    var templateId = this.templateId;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (messengerId != null) {
      json[r'messengerId'] = messengerId;
    }
    if (templateId != null) {
      json[r'templateId'] = templateId;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  MultiFactorSMSMethod copyWith(
      {String? messengerId, String? templateId, bool? enabled}) {
    return MultiFactorSMSMethod(
      messengerId: messengerId ?? this.messengerId,
      templateId: templateId ?? this.templateId,
      enabled: enabled ?? this.enabled,
    );
  }
}

class MultiFactorSMSTemplate {
  final String? templateId;

  MultiFactorSMSTemplate({this.templateId});

  factory MultiFactorSMSTemplate.fromJson(Map<String, Object?> json) {
    return MultiFactorSMSTemplate(
      templateId: json[r'templateId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var templateId = this.templateId;

    final json = <String, Object?>{};
    if (templateId != null) {
      json[r'templateId'] = templateId;
    }
    return json;
  }

  MultiFactorSMSTemplate copyWith({String? templateId}) {
    return MultiFactorSMSTemplate(
      templateId: templateId ?? this.templateId,
    );
  }
}

class NintendoApplicationConfiguration {
  final String? buttonText;
  final String? clientId;
  final String? clientSecret;
  final String? emailClaim;
  final String? scope;
  final String? uniqueIdClaim;
  final String? usernameClaim;
  final Map<String, dynamic>? data;
  final bool createRegistration;

  NintendoApplicationConfiguration(
      {this.buttonText,
      this.clientId,
      this.clientSecret,
      this.emailClaim,
      this.scope,
      this.uniqueIdClaim,
      this.usernameClaim,
      this.data,
      bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory NintendoApplicationConfiguration.fromJson(Map<String, Object?> json) {
    return NintendoApplicationConfiguration(
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      emailClaim: json[r'emailClaim'] as String?,
      scope: json[r'scope'] as String?,
      uniqueIdClaim: json[r'uniqueIdClaim'] as String?,
      usernameClaim: json[r'usernameClaim'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var emailClaim = this.emailClaim;
    var scope = this.scope;
    var uniqueIdClaim = this.uniqueIdClaim;
    var usernameClaim = this.usernameClaim;
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (emailClaim != null) {
      json[r'emailClaim'] = emailClaim;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (uniqueIdClaim != null) {
      json[r'uniqueIdClaim'] = uniqueIdClaim;
    }
    if (usernameClaim != null) {
      json[r'usernameClaim'] = usernameClaim;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  NintendoApplicationConfiguration copyWith(
      {String? buttonText,
      String? clientId,
      String? clientSecret,
      String? emailClaim,
      String? scope,
      String? uniqueIdClaim,
      String? usernameClaim,
      Map<String, dynamic>? data,
      bool? createRegistration}) {
    return NintendoApplicationConfiguration(
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      emailClaim: emailClaim ?? this.emailClaim,
      scope: scope ?? this.scope,
      uniqueIdClaim: uniqueIdClaim ?? this.uniqueIdClaim,
      usernameClaim: usernameClaim ?? this.usernameClaim,
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

/// Nintendo gaming login provider.
class NintendoIdentityProvider {
  final String? buttonText;
  final String? clientId;
  final String? clientSecret;
  final String? emailClaim;
  final String? scope;
  final String? uniqueIdClaim;
  final String? usernameClaim;
  final Map<String, dynamic>? data;
  final Map<String, dynamic>? applicationConfiguration;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ProviderLambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final IdentityProviderLinkingStrategy? linkingStrategy;
  final String? name;
  final Map<String, dynamic>? tenantConfiguration;
  final IdentityProviderType? type;

  NintendoIdentityProvider(
      {this.buttonText,
      this.clientId,
      this.clientSecret,
      this.emailClaim,
      this.scope,
      this.uniqueIdClaim,
      this.usernameClaim,
      this.data,
      this.applicationConfiguration,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.linkingStrategy,
      this.name,
      this.tenantConfiguration,
      this.type})
      : debug = debug ?? false;

  factory NintendoIdentityProvider.fromJson(Map<String, Object?> json) {
    return NintendoIdentityProvider(
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      emailClaim: json[r'emailClaim'] as String?,
      scope: json[r'scope'] as String?,
      uniqueIdClaim: json[r'uniqueIdClaim'] as String?,
      usernameClaim: json[r'usernameClaim'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      applicationConfiguration:
          json[r'applicationConfiguration'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? ProviderLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      linkingStrategy: json[r'linkingStrategy'] != null
          ? IdentityProviderLinkingStrategy.fromValue(
              json[r'linkingStrategy']! as String)
          : null,
      name: json[r'name'] as String?,
      tenantConfiguration:
          json[r'tenantConfiguration'] as Map<String, Object?>?,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var emailClaim = this.emailClaim;
    var scope = this.scope;
    var uniqueIdClaim = this.uniqueIdClaim;
    var usernameClaim = this.usernameClaim;
    var data = this.data;
    var applicationConfiguration = this.applicationConfiguration;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var linkingStrategy = this.linkingStrategy;
    var name = this.name;
    var tenantConfiguration = this.tenantConfiguration;
    var type = this.type;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (emailClaim != null) {
      json[r'emailClaim'] = emailClaim;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (uniqueIdClaim != null) {
      json[r'uniqueIdClaim'] = uniqueIdClaim;
    }
    if (usernameClaim != null) {
      json[r'usernameClaim'] = usernameClaim;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (applicationConfiguration != null) {
      json[r'applicationConfiguration'] = applicationConfiguration;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (linkingStrategy != null) {
      json[r'linkingStrategy'] = linkingStrategy.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (tenantConfiguration != null) {
      json[r'tenantConfiguration'] = tenantConfiguration;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  NintendoIdentityProvider copyWith(
      {String? buttonText,
      String? clientId,
      String? clientSecret,
      String? emailClaim,
      String? scope,
      String? uniqueIdClaim,
      String? usernameClaim,
      Map<String, dynamic>? data,
      Map<String, dynamic>? applicationConfiguration,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ProviderLambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      IdentityProviderLinkingStrategy? linkingStrategy,
      String? name,
      Map<String, dynamic>? tenantConfiguration,
      IdentityProviderType? type}) {
    return NintendoIdentityProvider(
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      emailClaim: emailClaim ?? this.emailClaim,
      scope: scope ?? this.scope,
      uniqueIdClaim: uniqueIdClaim ?? this.uniqueIdClaim,
      usernameClaim: usernameClaim ?? this.usernameClaim,
      data: data ?? this.data,
      applicationConfiguration:
          applicationConfiguration ?? this.applicationConfiguration,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      linkingStrategy: linkingStrategy ?? this.linkingStrategy,
      name: name ?? this.name,
      tenantConfiguration: tenantConfiguration ?? this.tenantConfiguration,
      type: type ?? this.type,
    );
  }
}

/// A marker interface indicating this event cannot be made transactional.
class NonTransactionalEvent {
  NonTransactionalEvent();

  factory NonTransactionalEvent.fromJson(Map<String, Object?> json) {
    return NonTransactionalEvent();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class OAuth2Configuration {
  final List<String> authorizedOriginUrLs;
  final List<String> authorizedRedirectUrLs;
  final Oauth2AuthorizedURLValidationPolicy? authorizedUrlValidationPolicy;
  final ClientAuthenticationPolicy? clientAuthenticationPolicy;
  final String? clientId;
  final String? clientSecret;
  final OAuthScopeConsentMode? consentMode;
  final bool debug;
  final String? deviceVerificationUrl;
  final List<dynamic> enabledGrants;
  final bool generateRefreshTokens;
  final LogoutBehavior? logoutBehavior;
  final String? logoutUrl;
  final ProofKeyForCodeExchangePolicy? proofKeyForCodeExchangePolicy;
  final ProvidedScopePolicy? providedScopePolicy;
  final OAuthApplicationRelationship? relationship;
  final bool requireClientAuthentication;
  final bool requireRegistration;
  final OAuthScopeHandlingPolicy? scopeHandlingPolicy;
  final UnknownScopePolicy? unknownScopePolicy;

  OAuth2Configuration(
      {List<String>? authorizedOriginUrLs,
      List<String>? authorizedRedirectUrLs,
      this.authorizedUrlValidationPolicy,
      this.clientAuthenticationPolicy,
      this.clientId,
      this.clientSecret,
      this.consentMode,
      bool? debug,
      this.deviceVerificationUrl,
      List<dynamic>? enabledGrants,
      bool? generateRefreshTokens,
      this.logoutBehavior,
      this.logoutUrl,
      this.proofKeyForCodeExchangePolicy,
      this.providedScopePolicy,
      this.relationship,
      bool? requireClientAuthentication,
      bool? requireRegistration,
      this.scopeHandlingPolicy,
      this.unknownScopePolicy})
      : authorizedOriginUrLs = authorizedOriginUrLs ?? [],
        authorizedRedirectUrLs = authorizedRedirectUrLs ?? [],
        debug = debug ?? false,
        enabledGrants = enabledGrants ?? [],
        generateRefreshTokens = generateRefreshTokens ?? false,
        requireClientAuthentication = requireClientAuthentication ?? false,
        requireRegistration = requireRegistration ?? false;

  factory OAuth2Configuration.fromJson(Map<String, Object?> json) {
    return OAuth2Configuration(
      authorizedOriginUrLs: (json[r'authorizedOriginURLs'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      authorizedRedirectUrLs:
          (json[r'authorizedRedirectURLs'] as List<Object?>?)
                  ?.map((i) => i as String? ?? '')
                  .toList() ??
              [],
      authorizedUrlValidationPolicy:
          json[r'authorizedURLValidationPolicy'] != null
              ? Oauth2AuthorizedURLValidationPolicy.fromValue(
                  json[r'authorizedURLValidationPolicy']! as String)
              : null,
      clientAuthenticationPolicy: json[r'clientAuthenticationPolicy'] != null
          ? ClientAuthenticationPolicy.fromValue(
              json[r'clientAuthenticationPolicy']! as String)
          : null,
      clientId: json[r'clientId'] as String?,
      clientSecret: json[r'clientSecret'] as String?,
      consentMode: json[r'consentMode'] != null
          ? OAuthScopeConsentMode.fromValue(json[r'consentMode']! as String)
          : null,
      debug: json[r'debug'] as bool? ?? false,
      deviceVerificationUrl: json[r'deviceVerificationURL'] as String?,
      enabledGrants:
          (json[r'enabledGrants'] as List<Object?>?)?.map((i) => i).toList() ??
              [],
      generateRefreshTokens: json[r'generateRefreshTokens'] as bool? ?? false,
      logoutBehavior: json[r'logoutBehavior'] != null
          ? LogoutBehavior.fromValue(json[r'logoutBehavior']! as String)
          : null,
      logoutUrl: json[r'logoutURL'] as String?,
      proofKeyForCodeExchangePolicy:
          json[r'proofKeyForCodeExchangePolicy'] != null
              ? ProofKeyForCodeExchangePolicy.fromValue(
                  json[r'proofKeyForCodeExchangePolicy']! as String)
              : null,
      providedScopePolicy: json[r'providedScopePolicy'] != null
          ? ProvidedScopePolicy.fromJson(
              json[r'providedScopePolicy']! as Map<String, Object?>)
          : null,
      relationship: json[r'relationship'] != null
          ? OAuthApplicationRelationship.fromValue(
              json[r'relationship']! as String)
          : null,
      requireClientAuthentication:
          json[r'requireClientAuthentication'] as bool? ?? false,
      requireRegistration: json[r'requireRegistration'] as bool? ?? false,
      scopeHandlingPolicy: json[r'scopeHandlingPolicy'] != null
          ? OAuthScopeHandlingPolicy.fromValue(
              json[r'scopeHandlingPolicy']! as String)
          : null,
      unknownScopePolicy: json[r'unknownScopePolicy'] != null
          ? UnknownScopePolicy.fromValue(json[r'unknownScopePolicy']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var authorizedOriginUrLs = this.authorizedOriginUrLs;
    var authorizedRedirectUrLs = this.authorizedRedirectUrLs;
    var authorizedUrlValidationPolicy = this.authorizedUrlValidationPolicy;
    var clientAuthenticationPolicy = this.clientAuthenticationPolicy;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var consentMode = this.consentMode;
    var debug = this.debug;
    var deviceVerificationUrl = this.deviceVerificationUrl;
    var enabledGrants = this.enabledGrants;
    var generateRefreshTokens = this.generateRefreshTokens;
    var logoutBehavior = this.logoutBehavior;
    var logoutUrl = this.logoutUrl;
    var proofKeyForCodeExchangePolicy = this.proofKeyForCodeExchangePolicy;
    var providedScopePolicy = this.providedScopePolicy;
    var relationship = this.relationship;
    var requireClientAuthentication = this.requireClientAuthentication;
    var requireRegistration = this.requireRegistration;
    var scopeHandlingPolicy = this.scopeHandlingPolicy;
    var unknownScopePolicy = this.unknownScopePolicy;

    final json = <String, Object?>{};
    json[r'authorizedOriginURLs'] = authorizedOriginUrLs;
    json[r'authorizedRedirectURLs'] = authorizedRedirectUrLs;
    if (authorizedUrlValidationPolicy != null) {
      json[r'authorizedURLValidationPolicy'] =
          authorizedUrlValidationPolicy.value;
    }
    if (clientAuthenticationPolicy != null) {
      json[r'clientAuthenticationPolicy'] = clientAuthenticationPolicy.value;
    }
    if (clientId != null) {
      json[r'clientId'] = clientId;
    }
    if (clientSecret != null) {
      json[r'clientSecret'] = clientSecret;
    }
    if (consentMode != null) {
      json[r'consentMode'] = consentMode.value;
    }
    json[r'debug'] = debug;
    if (deviceVerificationUrl != null) {
      json[r'deviceVerificationURL'] = deviceVerificationUrl;
    }
    json[r'enabledGrants'] = enabledGrants;
    json[r'generateRefreshTokens'] = generateRefreshTokens;
    if (logoutBehavior != null) {
      json[r'logoutBehavior'] = logoutBehavior.value;
    }
    if (logoutUrl != null) {
      json[r'logoutURL'] = logoutUrl;
    }
    if (proofKeyForCodeExchangePolicy != null) {
      json[r'proofKeyForCodeExchangePolicy'] =
          proofKeyForCodeExchangePolicy.value;
    }
    if (providedScopePolicy != null) {
      json[r'providedScopePolicy'] = providedScopePolicy.toJson();
    }
    if (relationship != null) {
      json[r'relationship'] = relationship.value;
    }
    json[r'requireClientAuthentication'] = requireClientAuthentication;
    json[r'requireRegistration'] = requireRegistration;
    if (scopeHandlingPolicy != null) {
      json[r'scopeHandlingPolicy'] = scopeHandlingPolicy.value;
    }
    if (unknownScopePolicy != null) {
      json[r'unknownScopePolicy'] = unknownScopePolicy.value;
    }
    return json;
  }

  OAuth2Configuration copyWith(
      {List<String>? authorizedOriginUrLs,
      List<String>? authorizedRedirectUrLs,
      Oauth2AuthorizedURLValidationPolicy? authorizedUrlValidationPolicy,
      ClientAuthenticationPolicy? clientAuthenticationPolicy,
      String? clientId,
      String? clientSecret,
      OAuthScopeConsentMode? consentMode,
      bool? debug,
      String? deviceVerificationUrl,
      List<dynamic>? enabledGrants,
      bool? generateRefreshTokens,
      LogoutBehavior? logoutBehavior,
      String? logoutUrl,
      ProofKeyForCodeExchangePolicy? proofKeyForCodeExchangePolicy,
      ProvidedScopePolicy? providedScopePolicy,
      OAuthApplicationRelationship? relationship,
      bool? requireClientAuthentication,
      bool? requireRegistration,
      OAuthScopeHandlingPolicy? scopeHandlingPolicy,
      UnknownScopePolicy? unknownScopePolicy}) {
    return OAuth2Configuration(
      authorizedOriginUrLs: authorizedOriginUrLs ?? this.authorizedOriginUrLs,
      authorizedRedirectUrLs:
          authorizedRedirectUrLs ?? this.authorizedRedirectUrLs,
      authorizedUrlValidationPolicy:
          authorizedUrlValidationPolicy ?? this.authorizedUrlValidationPolicy,
      clientAuthenticationPolicy:
          clientAuthenticationPolicy ?? this.clientAuthenticationPolicy,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      consentMode: consentMode ?? this.consentMode,
      debug: debug ?? this.debug,
      deviceVerificationUrl:
          deviceVerificationUrl ?? this.deviceVerificationUrl,
      enabledGrants: enabledGrants ?? this.enabledGrants,
      generateRefreshTokens:
          generateRefreshTokens ?? this.generateRefreshTokens,
      logoutBehavior: logoutBehavior ?? this.logoutBehavior,
      logoutUrl: logoutUrl ?? this.logoutUrl,
      proofKeyForCodeExchangePolicy:
          proofKeyForCodeExchangePolicy ?? this.proofKeyForCodeExchangePolicy,
      providedScopePolicy: providedScopePolicy ?? this.providedScopePolicy,
      relationship: relationship ?? this.relationship,
      requireClientAuthentication:
          requireClientAuthentication ?? this.requireClientAuthentication,
      requireRegistration: requireRegistration ?? this.requireRegistration,
      scopeHandlingPolicy: scopeHandlingPolicy ?? this.scopeHandlingPolicy,
      unknownScopePolicy: unknownScopePolicy ?? this.unknownScopePolicy,
    );
  }
}

class OAuthConfigurationResponse {
  final int? httpSessionMaxInactiveInterval;
  final String? logoutUrl;
  final OAuth2Configuration? oauthConfiguration;

  OAuthConfigurationResponse(
      {this.httpSessionMaxInactiveInterval,
      this.logoutUrl,
      this.oauthConfiguration});

  factory OAuthConfigurationResponse.fromJson(Map<String, Object?> json) {
    return OAuthConfigurationResponse(
      httpSessionMaxInactiveInterval:
          (json[r'httpSessionMaxInactiveInterval'] as num?)?.toInt(),
      logoutUrl: json[r'logoutURL'] as String?,
      oauthConfiguration: json[r'oauthConfiguration'] != null
          ? OAuth2Configuration.fromJson(
              json[r'oauthConfiguration']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var httpSessionMaxInactiveInterval = this.httpSessionMaxInactiveInterval;
    var logoutUrl = this.logoutUrl;
    var oauthConfiguration = this.oauthConfiguration;

    final json = <String, Object?>{};
    if (httpSessionMaxInactiveInterval != null) {
      json[r'httpSessionMaxInactiveInterval'] = httpSessionMaxInactiveInterval;
    }
    if (logoutUrl != null) {
      json[r'logoutURL'] = logoutUrl;
    }
    if (oauthConfiguration != null) {
      json[r'oauthConfiguration'] = oauthConfiguration.toJson();
    }
    return json;
  }

  OAuthConfigurationResponse copyWith(
      {int? httpSessionMaxInactiveInterval,
      String? logoutUrl,
      OAuth2Configuration? oauthConfiguration}) {
    return OAuthConfigurationResponse(
      httpSessionMaxInactiveInterval:
          httpSessionMaxInactiveInterval ?? this.httpSessionMaxInactiveInterval,
      logoutUrl: logoutUrl ?? this.logoutUrl,
      oauthConfiguration: oauthConfiguration ?? this.oauthConfiguration,
    );
  }
}

class OAuthError {
  final String? changePasswordId;
  final String? errorDescription;
  final OAuthErrorType? error;
  final String? errorUri;
  final List<TwoFactorMethod> twoFactorMethods;
  final OAuthErrorReason? errorReason;
  final String? twoFactorId;

  OAuthError(
      {this.changePasswordId,
      this.errorDescription,
      this.error,
      this.errorUri,
      List<TwoFactorMethod>? twoFactorMethods,
      this.errorReason,
      this.twoFactorId})
      : twoFactorMethods = twoFactorMethods ?? [];

  factory OAuthError.fromJson(Map<String, Object?> json) {
    return OAuthError(
      changePasswordId: json[r'change_password_id'] as String?,
      errorDescription: json[r'error_description'] as String?,
      error: json[r'error'] != null
          ? OAuthErrorType.fromValue(json[r'error']! as String)
          : null,
      errorUri: json[r'error_uri'] as String?,
      twoFactorMethods: (json[r'two_factor_methods'] as List<Object?>?)
              ?.map((i) => TwoFactorMethod.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      errorReason: json[r'error_reason'] != null
          ? OAuthErrorReason.fromValue(json[r'error_reason']! as String)
          : null,
      twoFactorId: json[r'two_factor_id'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var changePasswordId = this.changePasswordId;
    var errorDescription = this.errorDescription;
    var error = this.error;
    var errorUri = this.errorUri;
    var twoFactorMethods = this.twoFactorMethods;
    var errorReason = this.errorReason;
    var twoFactorId = this.twoFactorId;

    final json = <String, Object?>{};
    if (changePasswordId != null) {
      json[r'change_password_id'] = changePasswordId;
    }
    if (errorDescription != null) {
      json[r'error_description'] = errorDescription;
    }
    if (error != null) {
      json[r'error'] = error.value;
    }
    if (errorUri != null) {
      json[r'error_uri'] = errorUri;
    }
    json[r'two_factor_methods'] =
        twoFactorMethods.map((i) => i.toJson()).toList();
    if (errorReason != null) {
      json[r'error_reason'] = errorReason.value;
    }
    if (twoFactorId != null) {
      json[r'two_factor_id'] = twoFactorId;
    }
    return json;
  }

  OAuthError copyWith(
      {String? changePasswordId,
      String? errorDescription,
      OAuthErrorType? error,
      String? errorUri,
      List<TwoFactorMethod>? twoFactorMethods,
      OAuthErrorReason? errorReason,
      String? twoFactorId}) {
    return OAuthError(
      changePasswordId: changePasswordId ?? this.changePasswordId,
      errorDescription: errorDescription ?? this.errorDescription,
      error: error ?? this.error,
      errorUri: errorUri ?? this.errorUri,
      twoFactorMethods: twoFactorMethods ?? this.twoFactorMethods,
      errorReason: errorReason ?? this.errorReason,
      twoFactorId: twoFactorId ?? this.twoFactorId,
    );
  }
}

class OAuthResponse {
  OAuthResponse();

  factory OAuthResponse.fromJson(Map<String, Object?> json) {
    return OAuthResponse();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// A marker interface indicating this event is an event that can supply a
/// linked object Id.
class ObjectIdentifiable {
  ObjectIdentifiable();

  factory ObjectIdentifiable.fromJson(Map<String, Object?> json) {
    return ObjectIdentifiable();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// OpenID Connect Configuration as described by the <a
/// href="https:openid.netspecsopenid-connect-discovery-1_0.html#ProviderMetadata">OpenID
///  Provider Metadata<a>.
class OpenIdConfiguration {
  final String? authorizationEndpoint;
  final bool backchannelLogoutSupported;
  final List<String> claimsSupported;
  final String? deviceAuthorizationEndpoint;
  final String? endSessionEndpoint;
  final bool frontchannelLogoutSupported;
  final List<String> grantTypesSupported;
  final List<String> idTokenSigningAlgValuesSupported;
  final String? issuer;
  final String? jwksUri;
  final List<String> responseModesSupported;
  final List<String> responseTypesSupported;
  final List<String> scopesSupported;
  final List<String> subjectTypesSupported;
  final String? tokenEndpoint;
  final List<String> tokenEndpointAuthMethodsSupported;
  final String? userinfoEndpoint;
  final List<String> userinfoSigningAlgValuesSupported;

  OpenIdConfiguration(
      {this.authorizationEndpoint,
      bool? backchannelLogoutSupported,
      List<String>? claimsSupported,
      this.deviceAuthorizationEndpoint,
      this.endSessionEndpoint,
      bool? frontchannelLogoutSupported,
      List<String>? grantTypesSupported,
      List<String>? idTokenSigningAlgValuesSupported,
      this.issuer,
      this.jwksUri,
      List<String>? responseModesSupported,
      List<String>? responseTypesSupported,
      List<String>? scopesSupported,
      List<String>? subjectTypesSupported,
      this.tokenEndpoint,
      List<String>? tokenEndpointAuthMethodsSupported,
      this.userinfoEndpoint,
      List<String>? userinfoSigningAlgValuesSupported})
      : backchannelLogoutSupported = backchannelLogoutSupported ?? false,
        claimsSupported = claimsSupported ?? [],
        frontchannelLogoutSupported = frontchannelLogoutSupported ?? false,
        grantTypesSupported = grantTypesSupported ?? [],
        idTokenSigningAlgValuesSupported =
            idTokenSigningAlgValuesSupported ?? [],
        responseModesSupported = responseModesSupported ?? [],
        responseTypesSupported = responseTypesSupported ?? [],
        scopesSupported = scopesSupported ?? [],
        subjectTypesSupported = subjectTypesSupported ?? [],
        tokenEndpointAuthMethodsSupported =
            tokenEndpointAuthMethodsSupported ?? [],
        userinfoSigningAlgValuesSupported =
            userinfoSigningAlgValuesSupported ?? [];

  factory OpenIdConfiguration.fromJson(Map<String, Object?> json) {
    return OpenIdConfiguration(
      authorizationEndpoint: json[r'authorization_endpoint'] as String?,
      backchannelLogoutSupported:
          json[r'backchannel_logout_supported'] as bool? ?? false,
      claimsSupported: (json[r'claims_supported'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      deviceAuthorizationEndpoint:
          json[r'device_authorization_endpoint'] as String?,
      endSessionEndpoint: json[r'end_session_endpoint'] as String?,
      frontchannelLogoutSupported:
          json[r'frontchannel_logout_supported'] as bool? ?? false,
      grantTypesSupported: (json[r'grant_types_supported'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      idTokenSigningAlgValuesSupported:
          (json[r'id_token_signing_alg_values_supported'] as List<Object?>?)
                  ?.map((i) => i as String? ?? '')
                  .toList() ??
              [],
      issuer: json[r'issuer'] as String?,
      jwksUri: json[r'jwks_uri'] as String?,
      responseModesSupported:
          (json[r'response_modes_supported'] as List<Object?>?)
                  ?.map((i) => i as String? ?? '')
                  .toList() ??
              [],
      responseTypesSupported:
          (json[r'response_types_supported'] as List<Object?>?)
                  ?.map((i) => i as String? ?? '')
                  .toList() ??
              [],
      scopesSupported: (json[r'scopes_supported'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      subjectTypesSupported:
          (json[r'subject_types_supported'] as List<Object?>?)
                  ?.map((i) => i as String? ?? '')
                  .toList() ??
              [],
      tokenEndpoint: json[r'token_endpoint'] as String?,
      tokenEndpointAuthMethodsSupported:
          (json[r'token_endpoint_auth_methods_supported'] as List<Object?>?)
                  ?.map((i) => i as String? ?? '')
                  .toList() ??
              [],
      userinfoEndpoint: json[r'userinfo_endpoint'] as String?,
      userinfoSigningAlgValuesSupported:
          (json[r'userinfo_signing_alg_values_supported'] as List<Object?>?)
                  ?.map((i) => i as String? ?? '')
                  .toList() ??
              [],
    );
  }

  Map<String, Object?> toJson() {
    var authorizationEndpoint = this.authorizationEndpoint;
    var backchannelLogoutSupported = this.backchannelLogoutSupported;
    var claimsSupported = this.claimsSupported;
    var deviceAuthorizationEndpoint = this.deviceAuthorizationEndpoint;
    var endSessionEndpoint = this.endSessionEndpoint;
    var frontchannelLogoutSupported = this.frontchannelLogoutSupported;
    var grantTypesSupported = this.grantTypesSupported;
    var idTokenSigningAlgValuesSupported =
        this.idTokenSigningAlgValuesSupported;
    var issuer = this.issuer;
    var jwksUri = this.jwksUri;
    var responseModesSupported = this.responseModesSupported;
    var responseTypesSupported = this.responseTypesSupported;
    var scopesSupported = this.scopesSupported;
    var subjectTypesSupported = this.subjectTypesSupported;
    var tokenEndpoint = this.tokenEndpoint;
    var tokenEndpointAuthMethodsSupported =
        this.tokenEndpointAuthMethodsSupported;
    var userinfoEndpoint = this.userinfoEndpoint;
    var userinfoSigningAlgValuesSupported =
        this.userinfoSigningAlgValuesSupported;

    final json = <String, Object?>{};
    if (authorizationEndpoint != null) {
      json[r'authorization_endpoint'] = authorizationEndpoint;
    }
    json[r'backchannel_logout_supported'] = backchannelLogoutSupported;
    json[r'claims_supported'] = claimsSupported;
    if (deviceAuthorizationEndpoint != null) {
      json[r'device_authorization_endpoint'] = deviceAuthorizationEndpoint;
    }
    if (endSessionEndpoint != null) {
      json[r'end_session_endpoint'] = endSessionEndpoint;
    }
    json[r'frontchannel_logout_supported'] = frontchannelLogoutSupported;
    json[r'grant_types_supported'] = grantTypesSupported;
    json[r'id_token_signing_alg_values_supported'] =
        idTokenSigningAlgValuesSupported;
    if (issuer != null) {
      json[r'issuer'] = issuer;
    }
    if (jwksUri != null) {
      json[r'jwks_uri'] = jwksUri;
    }
    json[r'response_modes_supported'] = responseModesSupported;
    json[r'response_types_supported'] = responseTypesSupported;
    json[r'scopes_supported'] = scopesSupported;
    json[r'subject_types_supported'] = subjectTypesSupported;
    if (tokenEndpoint != null) {
      json[r'token_endpoint'] = tokenEndpoint;
    }
    json[r'token_endpoint_auth_methods_supported'] =
        tokenEndpointAuthMethodsSupported;
    if (userinfoEndpoint != null) {
      json[r'userinfo_endpoint'] = userinfoEndpoint;
    }
    json[r'userinfo_signing_alg_values_supported'] =
        userinfoSigningAlgValuesSupported;
    return json;
  }

  OpenIdConfiguration copyWith(
      {String? authorizationEndpoint,
      bool? backchannelLogoutSupported,
      List<String>? claimsSupported,
      String? deviceAuthorizationEndpoint,
      String? endSessionEndpoint,
      bool? frontchannelLogoutSupported,
      List<String>? grantTypesSupported,
      List<String>? idTokenSigningAlgValuesSupported,
      String? issuer,
      String? jwksUri,
      List<String>? responseModesSupported,
      List<String>? responseTypesSupported,
      List<String>? scopesSupported,
      List<String>? subjectTypesSupported,
      String? tokenEndpoint,
      List<String>? tokenEndpointAuthMethodsSupported,
      String? userinfoEndpoint,
      List<String>? userinfoSigningAlgValuesSupported}) {
    return OpenIdConfiguration(
      authorizationEndpoint:
          authorizationEndpoint ?? this.authorizationEndpoint,
      backchannelLogoutSupported:
          backchannelLogoutSupported ?? this.backchannelLogoutSupported,
      claimsSupported: claimsSupported ?? this.claimsSupported,
      deviceAuthorizationEndpoint:
          deviceAuthorizationEndpoint ?? this.deviceAuthorizationEndpoint,
      endSessionEndpoint: endSessionEndpoint ?? this.endSessionEndpoint,
      frontchannelLogoutSupported:
          frontchannelLogoutSupported ?? this.frontchannelLogoutSupported,
      grantTypesSupported: grantTypesSupported ?? this.grantTypesSupported,
      idTokenSigningAlgValuesSupported: idTokenSigningAlgValuesSupported ??
          this.idTokenSigningAlgValuesSupported,
      issuer: issuer ?? this.issuer,
      jwksUri: jwksUri ?? this.jwksUri,
      responseModesSupported:
          responseModesSupported ?? this.responseModesSupported,
      responseTypesSupported:
          responseTypesSupported ?? this.responseTypesSupported,
      scopesSupported: scopesSupported ?? this.scopesSupported,
      subjectTypesSupported:
          subjectTypesSupported ?? this.subjectTypesSupported,
      tokenEndpoint: tokenEndpoint ?? this.tokenEndpoint,
      tokenEndpointAuthMethodsSupported: tokenEndpointAuthMethodsSupported ??
          this.tokenEndpointAuthMethodsSupported,
      userinfoEndpoint: userinfoEndpoint ?? this.userinfoEndpoint,
      userinfoSigningAlgValuesSupported: userinfoSigningAlgValuesSupported ??
          this.userinfoSigningAlgValuesSupported,
    );
  }
}

class OpenIdConnectApplicationConfiguration {
  final String? buttonImageUrl;
  final String? buttonText;
  final IdentityProviderOauth2Configuration? oauth2;
  final Map<String, dynamic>? data;
  final bool createRegistration;

  OpenIdConnectApplicationConfiguration(
      {this.buttonImageUrl,
      this.buttonText,
      this.oauth2,
      this.data,
      bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory OpenIdConnectApplicationConfiguration.fromJson(
      Map<String, Object?> json) {
    return OpenIdConnectApplicationConfiguration(
      buttonImageUrl: json[r'buttonImageURL'] as String?,
      buttonText: json[r'buttonText'] as String?,
      oauth2: json[r'oauth2'] != null
          ? IdentityProviderOauth2Configuration.fromJson(
              json[r'oauth2']! as Map<String, Object?>)
          : null,
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var buttonImageUrl = this.buttonImageUrl;
    var buttonText = this.buttonText;
    var oauth2 = this.oauth2;
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (buttonImageUrl != null) {
      json[r'buttonImageURL'] = buttonImageUrl;
    }
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (oauth2 != null) {
      json[r'oauth2'] = oauth2.toJson();
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  OpenIdConnectApplicationConfiguration copyWith(
      {String? buttonImageUrl,
      String? buttonText,
      IdentityProviderOauth2Configuration? oauth2,
      Map<String, dynamic>? data,
      bool? createRegistration}) {
    return OpenIdConnectApplicationConfiguration(
      buttonImageUrl: buttonImageUrl ?? this.buttonImageUrl,
      buttonText: buttonText ?? this.buttonText,
      oauth2: oauth2 ?? this.oauth2,
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

class OpenIdConnectIdentityProvider {
  final List<dynamic> domains;
  final String? buttonImageUrl;
  final String? buttonText;
  final IdentityProviderOauth2Configuration? oauth2;
  final bool postRequest;
  final Map<String, dynamic>? data;
  final Map<String, dynamic>? applicationConfiguration;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ProviderLambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final IdentityProviderLinkingStrategy? linkingStrategy;
  final String? name;
  final Map<String, dynamic>? tenantConfiguration;
  final IdentityProviderType? type;

  OpenIdConnectIdentityProvider(
      {List<dynamic>? domains,
      this.buttonImageUrl,
      this.buttonText,
      this.oauth2,
      bool? postRequest,
      this.data,
      this.applicationConfiguration,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.linkingStrategy,
      this.name,
      this.tenantConfiguration,
      this.type})
      : domains = domains ?? [],
        postRequest = postRequest ?? false,
        debug = debug ?? false;

  factory OpenIdConnectIdentityProvider.fromJson(Map<String, Object?> json) {
    return OpenIdConnectIdentityProvider(
      domains:
          (json[r'domains'] as List<Object?>?)?.map((i) => i).toList() ?? [],
      buttonImageUrl: json[r'buttonImageURL'] as String?,
      buttonText: json[r'buttonText'] as String?,
      oauth2: json[r'oauth2'] != null
          ? IdentityProviderOauth2Configuration.fromJson(
              json[r'oauth2']! as Map<String, Object?>)
          : null,
      postRequest: json[r'postRequest'] as bool? ?? false,
      data: json[r'data'] as Map<String, Object?>?,
      applicationConfiguration:
          json[r'applicationConfiguration'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? ProviderLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      linkingStrategy: json[r'linkingStrategy'] != null
          ? IdentityProviderLinkingStrategy.fromValue(
              json[r'linkingStrategy']! as String)
          : null,
      name: json[r'name'] as String?,
      tenantConfiguration:
          json[r'tenantConfiguration'] as Map<String, Object?>?,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var domains = this.domains;
    var buttonImageUrl = this.buttonImageUrl;
    var buttonText = this.buttonText;
    var oauth2 = this.oauth2;
    var postRequest = this.postRequest;
    var data = this.data;
    var applicationConfiguration = this.applicationConfiguration;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var linkingStrategy = this.linkingStrategy;
    var name = this.name;
    var tenantConfiguration = this.tenantConfiguration;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'domains'] = domains;
    if (buttonImageUrl != null) {
      json[r'buttonImageURL'] = buttonImageUrl;
    }
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (oauth2 != null) {
      json[r'oauth2'] = oauth2.toJson();
    }
    json[r'postRequest'] = postRequest;
    if (data != null) {
      json[r'data'] = data;
    }
    if (applicationConfiguration != null) {
      json[r'applicationConfiguration'] = applicationConfiguration;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (linkingStrategy != null) {
      json[r'linkingStrategy'] = linkingStrategy.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (tenantConfiguration != null) {
      json[r'tenantConfiguration'] = tenantConfiguration;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  OpenIdConnectIdentityProvider copyWith(
      {List<dynamic>? domains,
      String? buttonImageUrl,
      String? buttonText,
      IdentityProviderOauth2Configuration? oauth2,
      bool? postRequest,
      Map<String, dynamic>? data,
      Map<String, dynamic>? applicationConfiguration,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ProviderLambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      IdentityProviderLinkingStrategy? linkingStrategy,
      String? name,
      Map<String, dynamic>? tenantConfiguration,
      IdentityProviderType? type}) {
    return OpenIdConnectIdentityProvider(
      domains: domains ?? this.domains,
      buttonImageUrl: buttonImageUrl ?? this.buttonImageUrl,
      buttonText: buttonText ?? this.buttonText,
      oauth2: oauth2 ?? this.oauth2,
      postRequest: postRequest ?? this.postRequest,
      data: data ?? this.data,
      applicationConfiguration:
          applicationConfiguration ?? this.applicationConfiguration,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      linkingStrategy: linkingStrategy ?? this.linkingStrategy,
      name: name ?? this.name,
      tenantConfiguration: tenantConfiguration ?? this.tenantConfiguration,
      type: type ?? this.type,
    );
  }
}

class PasswordBreachDetection {
  final BreachMatchMode? matchMode;
  final String? notifyUserEmailTemplateId;
  final BreachAction? onLogin;
  final bool enabled;

  PasswordBreachDetection(
      {this.matchMode,
      this.notifyUserEmailTemplateId,
      this.onLogin,
      bool? enabled})
      : enabled = enabled ?? false;

  factory PasswordBreachDetection.fromJson(Map<String, Object?> json) {
    return PasswordBreachDetection(
      matchMode: json[r'matchMode'] != null
          ? BreachMatchMode.fromValue(json[r'matchMode']! as String)
          : null,
      notifyUserEmailTemplateId: json[r'notifyUserEmailTemplateId'] as String?,
      onLogin: json[r'onLogin'] != null
          ? BreachAction.fromValue(json[r'onLogin']! as String)
          : null,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var matchMode = this.matchMode;
    var notifyUserEmailTemplateId = this.notifyUserEmailTemplateId;
    var onLogin = this.onLogin;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (matchMode != null) {
      json[r'matchMode'] = matchMode.value;
    }
    if (notifyUserEmailTemplateId != null) {
      json[r'notifyUserEmailTemplateId'] = notifyUserEmailTemplateId;
    }
    if (onLogin != null) {
      json[r'onLogin'] = onLogin.value;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  PasswordBreachDetection copyWith(
      {BreachMatchMode? matchMode,
      String? notifyUserEmailTemplateId,
      BreachAction? onLogin,
      bool? enabled}) {
    return PasswordBreachDetection(
      matchMode: matchMode ?? this.matchMode,
      notifyUserEmailTemplateId:
          notifyUserEmailTemplateId ?? this.notifyUserEmailTemplateId,
      onLogin: onLogin ?? this.onLogin,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Password Encryption Scheme Configuration
class PasswordEncryptionConfiguration {
  final String? encryptionScheme;
  final int? encryptionSchemeFactor;
  final bool modifyEncryptionSchemeOnLogin;

  PasswordEncryptionConfiguration(
      {this.encryptionScheme,
      this.encryptionSchemeFactor,
      bool? modifyEncryptionSchemeOnLogin})
      : modifyEncryptionSchemeOnLogin = modifyEncryptionSchemeOnLogin ?? false;

  factory PasswordEncryptionConfiguration.fromJson(Map<String, Object?> json) {
    return PasswordEncryptionConfiguration(
      encryptionScheme: json[r'encryptionScheme'] as String?,
      encryptionSchemeFactor:
          (json[r'encryptionSchemeFactor'] as num?)?.toInt(),
      modifyEncryptionSchemeOnLogin:
          json[r'modifyEncryptionSchemeOnLogin'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var encryptionScheme = this.encryptionScheme;
    var encryptionSchemeFactor = this.encryptionSchemeFactor;
    var modifyEncryptionSchemeOnLogin = this.modifyEncryptionSchemeOnLogin;

    final json = <String, Object?>{};
    if (encryptionScheme != null) {
      json[r'encryptionScheme'] = encryptionScheme;
    }
    if (encryptionSchemeFactor != null) {
      json[r'encryptionSchemeFactor'] = encryptionSchemeFactor;
    }
    json[r'modifyEncryptionSchemeOnLogin'] = modifyEncryptionSchemeOnLogin;
    return json;
  }

  PasswordEncryptionConfiguration copyWith(
      {String? encryptionScheme,
      int? encryptionSchemeFactor,
      bool? modifyEncryptionSchemeOnLogin}) {
    return PasswordEncryptionConfiguration(
      encryptionScheme: encryptionScheme ?? this.encryptionScheme,
      encryptionSchemeFactor:
          encryptionSchemeFactor ?? this.encryptionSchemeFactor,
      modifyEncryptionSchemeOnLogin:
          modifyEncryptionSchemeOnLogin ?? this.modifyEncryptionSchemeOnLogin,
    );
  }
}

class PasswordValidationRules {
  final PasswordBreachDetection? breachDetection;
  final int? maxLength;
  final int? minLength;
  final RememberPreviousPasswords? rememberPreviousPasswords;
  final bool requireMixedCase;
  final bool requireNonAlpha;
  final bool requireNumber;
  final bool validateOnLogin;

  PasswordValidationRules(
      {this.breachDetection,
      this.maxLength,
      this.minLength,
      this.rememberPreviousPasswords,
      bool? requireMixedCase,
      bool? requireNonAlpha,
      bool? requireNumber,
      bool? validateOnLogin})
      : requireMixedCase = requireMixedCase ?? false,
        requireNonAlpha = requireNonAlpha ?? false,
        requireNumber = requireNumber ?? false,
        validateOnLogin = validateOnLogin ?? false;

  factory PasswordValidationRules.fromJson(Map<String, Object?> json) {
    return PasswordValidationRules(
      breachDetection: json[r'breachDetection'] != null
          ? PasswordBreachDetection.fromJson(
              json[r'breachDetection']! as Map<String, Object?>)
          : null,
      maxLength: (json[r'maxLength'] as num?)?.toInt(),
      minLength: (json[r'minLength'] as num?)?.toInt(),
      rememberPreviousPasswords: json[r'rememberPreviousPasswords'] != null
          ? RememberPreviousPasswords.fromJson(
              json[r'rememberPreviousPasswords']! as Map<String, Object?>)
          : null,
      requireMixedCase: json[r'requireMixedCase'] as bool? ?? false,
      requireNonAlpha: json[r'requireNonAlpha'] as bool? ?? false,
      requireNumber: json[r'requireNumber'] as bool? ?? false,
      validateOnLogin: json[r'validateOnLogin'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var breachDetection = this.breachDetection;
    var maxLength = this.maxLength;
    var minLength = this.minLength;
    var rememberPreviousPasswords = this.rememberPreviousPasswords;
    var requireMixedCase = this.requireMixedCase;
    var requireNonAlpha = this.requireNonAlpha;
    var requireNumber = this.requireNumber;
    var validateOnLogin = this.validateOnLogin;

    final json = <String, Object?>{};
    if (breachDetection != null) {
      json[r'breachDetection'] = breachDetection.toJson();
    }
    if (maxLength != null) {
      json[r'maxLength'] = maxLength;
    }
    if (minLength != null) {
      json[r'minLength'] = minLength;
    }
    if (rememberPreviousPasswords != null) {
      json[r'rememberPreviousPasswords'] = rememberPreviousPasswords.toJson();
    }
    json[r'requireMixedCase'] = requireMixedCase;
    json[r'requireNonAlpha'] = requireNonAlpha;
    json[r'requireNumber'] = requireNumber;
    json[r'validateOnLogin'] = validateOnLogin;
    return json;
  }

  PasswordValidationRules copyWith(
      {PasswordBreachDetection? breachDetection,
      int? maxLength,
      int? minLength,
      RememberPreviousPasswords? rememberPreviousPasswords,
      bool? requireMixedCase,
      bool? requireNonAlpha,
      bool? requireNumber,
      bool? validateOnLogin}) {
    return PasswordValidationRules(
      breachDetection: breachDetection ?? this.breachDetection,
      maxLength: maxLength ?? this.maxLength,
      minLength: minLength ?? this.minLength,
      rememberPreviousPasswords:
          rememberPreviousPasswords ?? this.rememberPreviousPasswords,
      requireMixedCase: requireMixedCase ?? this.requireMixedCase,
      requireNonAlpha: requireNonAlpha ?? this.requireNonAlpha,
      requireNumber: requireNumber ?? this.requireNumber,
      validateOnLogin: validateOnLogin ?? this.validateOnLogin,
    );
  }
}

class PasswordValidationRulesResponse {
  final PasswordValidationRules? passwordValidationRules;

  PasswordValidationRulesResponse({this.passwordValidationRules});

  factory PasswordValidationRulesResponse.fromJson(Map<String, Object?> json) {
    return PasswordValidationRulesResponse(
      passwordValidationRules: json[r'passwordValidationRules'] != null
          ? PasswordValidationRules.fromJson(
              json[r'passwordValidationRules']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var passwordValidationRules = this.passwordValidationRules;

    final json = <String, Object?>{};
    if (passwordValidationRules != null) {
      json[r'passwordValidationRules'] = passwordValidationRules.toJson();
    }
    return json;
  }

  PasswordValidationRulesResponse copyWith(
      {PasswordValidationRules? passwordValidationRules}) {
    return PasswordValidationRulesResponse(
      passwordValidationRules:
          passwordValidationRules ?? this.passwordValidationRules,
    );
  }
}

class PasswordlessConfiguration {
  final bool enabled;

  PasswordlessConfiguration({bool? enabled}) : enabled = enabled ?? false;

  factory PasswordlessConfiguration.fromJson(Map<String, Object?> json) {
    return PasswordlessConfiguration(
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var enabled = this.enabled;

    final json = <String, Object?>{};
    json[r'enabled'] = enabled;
    return json;
  }

  PasswordlessConfiguration copyWith({bool? enabled}) {
    return PasswordlessConfiguration(
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Interface for all identity providers that are passwordless and do not accept
/// a password.
class PasswordlessIdentityProvider {
  PasswordlessIdentityProvider();

  factory PasswordlessIdentityProvider.fromJson(Map<String, Object?> json) {
    return PasswordlessIdentityProvider();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class PasswordlessLoginRequest {
  final String? code;
  final String? twoFactorTrustId;
  final String? applicationId;
  final String? ipAddress;
  final MetaData? metaData;
  final bool newDevice;
  final bool noJwt;

  PasswordlessLoginRequest(
      {this.code,
      this.twoFactorTrustId,
      this.applicationId,
      this.ipAddress,
      this.metaData,
      bool? newDevice,
      bool? noJwt})
      : newDevice = newDevice ?? false,
        noJwt = noJwt ?? false;

  factory PasswordlessLoginRequest.fromJson(Map<String, Object?> json) {
    return PasswordlessLoginRequest(
      code: json[r'code'] as String?,
      twoFactorTrustId: json[r'twoFactorTrustId'] as String?,
      applicationId: json[r'applicationId'] as String?,
      ipAddress: json[r'ipAddress'] as String?,
      metaData: json[r'metaData'] != null
          ? MetaData.fromJson(json[r'metaData']! as Map<String, Object?>)
          : null,
      newDevice: json[r'newDevice'] as bool? ?? false,
      noJwt: json[r'noJWT'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var code = this.code;
    var twoFactorTrustId = this.twoFactorTrustId;
    var applicationId = this.applicationId;
    var ipAddress = this.ipAddress;
    var metaData = this.metaData;
    var newDevice = this.newDevice;
    var noJwt = this.noJwt;

    final json = <String, Object?>{};
    if (code != null) {
      json[r'code'] = code;
    }
    if (twoFactorTrustId != null) {
      json[r'twoFactorTrustId'] = twoFactorTrustId;
    }
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (ipAddress != null) {
      json[r'ipAddress'] = ipAddress;
    }
    if (metaData != null) {
      json[r'metaData'] = metaData.toJson();
    }
    json[r'newDevice'] = newDevice;
    json[r'noJWT'] = noJwt;
    return json;
  }

  PasswordlessLoginRequest copyWith(
      {String? code,
      String? twoFactorTrustId,
      String? applicationId,
      String? ipAddress,
      MetaData? metaData,
      bool? newDevice,
      bool? noJwt}) {
    return PasswordlessLoginRequest(
      code: code ?? this.code,
      twoFactorTrustId: twoFactorTrustId ?? this.twoFactorTrustId,
      applicationId: applicationId ?? this.applicationId,
      ipAddress: ipAddress ?? this.ipAddress,
      metaData: metaData ?? this.metaData,
      newDevice: newDevice ?? this.newDevice,
      noJwt: noJwt ?? this.noJwt,
    );
  }
}

class PasswordlessSendRequest {
  final String? applicationId;
  final String? code;
  final String? loginId;
  final Map<String, dynamic>? state;

  PasswordlessSendRequest(
      {this.applicationId, this.code, this.loginId, this.state});

  factory PasswordlessSendRequest.fromJson(Map<String, Object?> json) {
    return PasswordlessSendRequest(
      applicationId: json[r'applicationId'] as String?,
      code: json[r'code'] as String?,
      loginId: json[r'loginId'] as String?,
      state: json[r'state'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var code = this.code;
    var loginId = this.loginId;
    var state = this.state;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (code != null) {
      json[r'code'] = code;
    }
    if (loginId != null) {
      json[r'loginId'] = loginId;
    }
    if (state != null) {
      json[r'state'] = state;
    }
    return json;
  }

  PasswordlessSendRequest copyWith(
      {String? applicationId,
      String? code,
      String? loginId,
      Map<String, dynamic>? state}) {
    return PasswordlessSendRequest(
      applicationId: applicationId ?? this.applicationId,
      code: code ?? this.code,
      loginId: loginId ?? this.loginId,
      state: state ?? this.state,
    );
  }
}

class PasswordlessStartRequest {
  final String? applicationId;
  final String? loginId;
  final Map<String, dynamic>? state;

  PasswordlessStartRequest({this.applicationId, this.loginId, this.state});

  factory PasswordlessStartRequest.fromJson(Map<String, Object?> json) {
    return PasswordlessStartRequest(
      applicationId: json[r'applicationId'] as String?,
      loginId: json[r'loginId'] as String?,
      state: json[r'state'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var loginId = this.loginId;
    var state = this.state;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (loginId != null) {
      json[r'loginId'] = loginId;
    }
    if (state != null) {
      json[r'state'] = state;
    }
    return json;
  }

  PasswordlessStartRequest copyWith(
      {String? applicationId, String? loginId, Map<String, dynamic>? state}) {
    return PasswordlessStartRequest(
      applicationId: applicationId ?? this.applicationId,
      loginId: loginId ?? this.loginId,
      state: state ?? this.state,
    );
  }
}

class PasswordlessStartResponse {
  final String? code;

  PasswordlessStartResponse({this.code});

  factory PasswordlessStartResponse.fromJson(Map<String, Object?> json) {
    return PasswordlessStartResponse(
      code: json[r'code'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var code = this.code;

    final json = <String, Object?>{};
    if (code != null) {
      json[r'code'] = code;
    }
    return json;
  }

  PasswordlessStartResponse copyWith({String? code}) {
    return PasswordlessStartResponse(
      code: code ?? this.code,
    );
  }
}

class PendingIdPLink {
  final String? displayName;
  final String? email;
  final String? identityProviderId;
  final List<IdentityProviderLink> identityProviderLinks;
  final String? identityProviderName;
  final IdentityProviderTenantConfiguration?
      identityProviderTenantConfiguration;
  final IdentityProviderType? identityProviderType;
  final String? identityProviderUserId;
  final User? user;
  final String? username;

  PendingIdPLink(
      {this.displayName,
      this.email,
      this.identityProviderId,
      List<IdentityProviderLink>? identityProviderLinks,
      this.identityProviderName,
      this.identityProviderTenantConfiguration,
      this.identityProviderType,
      this.identityProviderUserId,
      this.user,
      this.username})
      : identityProviderLinks = identityProviderLinks ?? [];

  factory PendingIdPLink.fromJson(Map<String, Object?> json) {
    return PendingIdPLink(
      displayName: json[r'displayName'] as String?,
      email: json[r'email'] as String?,
      identityProviderId: json[r'identityProviderId'] as String?,
      identityProviderLinks: (json[r'identityProviderLinks'] as List<Object?>?)
              ?.map((i) => IdentityProviderLink.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      identityProviderName: json[r'identityProviderName'] as String?,
      identityProviderTenantConfiguration:
          json[r'identityProviderTenantConfiguration'] != null
              ? IdentityProviderTenantConfiguration.fromJson(
                  json[r'identityProviderTenantConfiguration']!
                      as Map<String, Object?>)
              : null,
      identityProviderType: json[r'identityProviderType'] != null
          ? IdentityProviderType.fromValue(
              json[r'identityProviderType']! as String)
          : null,
      identityProviderUserId: json[r'identityProviderUserId'] as String?,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
      username: json[r'username'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var displayName = this.displayName;
    var email = this.email;
    var identityProviderId = this.identityProviderId;
    var identityProviderLinks = this.identityProviderLinks;
    var identityProviderName = this.identityProviderName;
    var identityProviderTenantConfiguration =
        this.identityProviderTenantConfiguration;
    var identityProviderType = this.identityProviderType;
    var identityProviderUserId = this.identityProviderUserId;
    var user = this.user;
    var username = this.username;

    final json = <String, Object?>{};
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (email != null) {
      json[r'email'] = email;
    }
    if (identityProviderId != null) {
      json[r'identityProviderId'] = identityProviderId;
    }
    json[r'identityProviderLinks'] =
        identityProviderLinks.map((i) => i.toJson()).toList();
    if (identityProviderName != null) {
      json[r'identityProviderName'] = identityProviderName;
    }
    if (identityProviderTenantConfiguration != null) {
      json[r'identityProviderTenantConfiguration'] =
          identityProviderTenantConfiguration.toJson();
    }
    if (identityProviderType != null) {
      json[r'identityProviderType'] = identityProviderType.value;
    }
    if (identityProviderUserId != null) {
      json[r'identityProviderUserId'] = identityProviderUserId;
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    if (username != null) {
      json[r'username'] = username;
    }
    return json;
  }

  PendingIdPLink copyWith(
      {String? displayName,
      String? email,
      String? identityProviderId,
      List<IdentityProviderLink>? identityProviderLinks,
      String? identityProviderName,
      IdentityProviderTenantConfiguration? identityProviderTenantConfiguration,
      IdentityProviderType? identityProviderType,
      String? identityProviderUserId,
      User? user,
      String? username}) {
    return PendingIdPLink(
      displayName: displayName ?? this.displayName,
      email: email ?? this.email,
      identityProviderId: identityProviderId ?? this.identityProviderId,
      identityProviderLinks:
          identityProviderLinks ?? this.identityProviderLinks,
      identityProviderName: identityProviderName ?? this.identityProviderName,
      identityProviderTenantConfiguration:
          identityProviderTenantConfiguration ??
              this.identityProviderTenantConfiguration,
      identityProviderType: identityProviderType ?? this.identityProviderType,
      identityProviderUserId:
          identityProviderUserId ?? this.identityProviderUserId,
      user: user ?? this.user,
      username: username ?? this.username,
    );
  }
}

class PendingResponse {
  final List<User> users;

  PendingResponse({List<User>? users}) : users = users ?? [];

  factory PendingResponse.fromJson(Map<String, Object?> json) {
    return PendingResponse(
      users: (json[r'users'] as List<Object?>?)
              ?.map(
                  (i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var users = this.users;

    final json = <String, Object?>{};
    json[r'users'] = users.map((i) => i.toJson()).toList();
    return json;
  }

  PendingResponse copyWith({List<User>? users}) {
    return PendingResponse(
      users: users ?? this.users,
    );
  }
}

class PreviewMessageTemplateRequest {
  final Locale? locale;
  final MessageTemplate? messageTemplate;

  PreviewMessageTemplateRequest({this.locale, this.messageTemplate});

  factory PreviewMessageTemplateRequest.fromJson(Map<String, Object?> json) {
    return PreviewMessageTemplateRequest(
      locale: json[r'locale'] as Locale?,
      messageTemplate: json[r'messageTemplate'] != null
          ? MessageTemplate.fromJson(
              json[r'messageTemplate']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var locale = this.locale;
    var messageTemplate = this.messageTemplate;

    final json = <String, Object?>{};
    if (locale != null) {
      json[r'locale'] = locale.toJson();
    }
    if (messageTemplate != null) {
      json[r'messageTemplate'] = messageTemplate.toJson();
    }
    return json;
  }

  PreviewMessageTemplateRequest copyWith(
      {Locale? locale, MessageTemplate? messageTemplate}) {
    return PreviewMessageTemplateRequest(
      locale: locale ?? this.locale,
      messageTemplate: messageTemplate ?? this.messageTemplate,
    );
  }
}

class PreviewMessageTemplateResponse {
  final Errors? errors;
  final SMSMessage? message;

  PreviewMessageTemplateResponse({this.errors, this.message});

  factory PreviewMessageTemplateResponse.fromJson(Map<String, Object?> json) {
    return PreviewMessageTemplateResponse(
      errors: json[r'errors'] != null
          ? Errors.fromJson(json[r'errors']! as Map<String, Object?>)
          : null,
      message: json[r'message'] != null
          ? SMSMessage.fromJson(json[r'message']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var errors = this.errors;
    var message = this.message;

    final json = <String, Object?>{};
    if (errors != null) {
      json[r'errors'] = errors.toJson();
    }
    if (message != null) {
      json[r'message'] = message.toJson();
    }
    return json;
  }

  PreviewMessageTemplateResponse copyWith(
      {Errors? errors, SMSMessage? message}) {
    return PreviewMessageTemplateResponse(
      errors: errors ?? this.errors,
      message: message ?? this.message,
    );
  }
}

class PreviewRequest {
  final EmailTemplate? emailTemplate;
  final Locale? locale;

  PreviewRequest({this.emailTemplate, this.locale});

  factory PreviewRequest.fromJson(Map<String, Object?> json) {
    return PreviewRequest(
      emailTemplate: json[r'emailTemplate'] != null
          ? EmailTemplate.fromJson(
              json[r'emailTemplate']! as Map<String, Object?>)
          : null,
      locale: json[r'locale'] as Locale?,
    );
  }

  Map<String, Object?> toJson() {
    var emailTemplate = this.emailTemplate;
    var locale = this.locale;

    final json = <String, Object?>{};
    if (emailTemplate != null) {
      json[r'emailTemplate'] = emailTemplate.toJson();
    }
    if (locale != null) {
      json[r'locale'] = locale.toJson();
    }
    return json;
  }

  PreviewRequest copyWith({EmailTemplate? emailTemplate, Locale? locale}) {
    return PreviewRequest(
      emailTemplate: emailTemplate ?? this.emailTemplate,
      locale: locale ?? this.locale,
    );
  }
}

class PreviewResponse {
  final Email? email;
  final Errors? errors;

  PreviewResponse({this.email, this.errors});

  factory PreviewResponse.fromJson(Map<String, Object?> json) {
    return PreviewResponse(
      email: json[r'email'] != null
          ? Email.fromJson(json[r'email']! as Map<String, Object?>)
          : null,
      errors: json[r'errors'] != null
          ? Errors.fromJson(json[r'errors']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var email = this.email;
    var errors = this.errors;

    final json = <String, Object?>{};
    if (email != null) {
      json[r'email'] = email.toJson();
    }
    if (errors != null) {
      json[r'errors'] = errors.toJson();
    }
    return json;
  }

  PreviewResponse copyWith({Email? email, Errors? errors}) {
    return PreviewResponse(
      email: email ?? this.email,
      errors: errors ?? this.errors,
    );
  }
}

/// The handling policy for scopes provided by FusionAuth
class ProvidedScopePolicy {
  final Requirable? address;
  final Requirable? email;
  final Requirable? phone;
  final Requirable? profile;

  ProvidedScopePolicy({this.address, this.email, this.phone, this.profile});

  factory ProvidedScopePolicy.fromJson(Map<String, Object?> json) {
    return ProvidedScopePolicy(
      address: json[r'address'] != null
          ? Requirable.fromJson(json[r'address']! as Map<String, Object?>)
          : null,
      email: json[r'email'] != null
          ? Requirable.fromJson(json[r'email']! as Map<String, Object?>)
          : null,
      phone: json[r'phone'] != null
          ? Requirable.fromJson(json[r'phone']! as Map<String, Object?>)
          : null,
      profile: json[r'profile'] != null
          ? Requirable.fromJson(json[r'profile']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var address = this.address;
    var email = this.email;
    var phone = this.phone;
    var profile = this.profile;

    final json = <String, Object?>{};
    if (address != null) {
      json[r'address'] = address.toJson();
    }
    if (email != null) {
      json[r'email'] = email.toJson();
    }
    if (phone != null) {
      json[r'phone'] = phone.toJson();
    }
    if (profile != null) {
      json[r'profile'] = profile.toJson();
    }
    return json;
  }

  ProvidedScopePolicy copyWith(
      {Requirable? address,
      Requirable? email,
      Requirable? phone,
      Requirable? profile}) {
    return ProvidedScopePolicy(
      address: address ?? this.address,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      profile: profile ?? this.profile,
    );
  }
}

class ProviderLambdaConfiguration {
  final String? reconcileId;

  ProviderLambdaConfiguration({this.reconcileId});

  factory ProviderLambdaConfiguration.fromJson(Map<String, Object?> json) {
    return ProviderLambdaConfiguration(
      reconcileId: json[r'reconcileId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var reconcileId = this.reconcileId;

    final json = <String, Object?>{};
    if (reconcileId != null) {
      json[r'reconcileId'] = reconcileId;
    }
    return json;
  }

  ProviderLambdaConfiguration copyWith({String? reconcileId}) {
    return ProviderLambdaConfiguration(
      reconcileId: reconcileId ?? this.reconcileId,
    );
  }
}

/// Allows the Relying Party to specify desired attributes of a new credential.
class PublicKeyCredentialCreationOptions {
  final AttestationConveyancePreference? attestation;
  final AuthenticatorSelectionCriteria? authenticatorSelection;
  final String? challenge;
  final List<PublicKeyCredentialDescriptor> excludeCredentials;
  final WebAuthnRegistrationExtensionOptions? extensions;
  final List<PublicKeyCredentialParameters> pubKeyCredParams;
  final PublicKeyCredentialRelyingPartyEntity? rp;
  final int? timeout;
  final PublicKeyCredentialUserEntity? user;

  PublicKeyCredentialCreationOptions(
      {this.attestation,
      this.authenticatorSelection,
      this.challenge,
      List<PublicKeyCredentialDescriptor>? excludeCredentials,
      this.extensions,
      List<PublicKeyCredentialParameters>? pubKeyCredParams,
      this.rp,
      this.timeout,
      this.user})
      : excludeCredentials = excludeCredentials ?? [],
        pubKeyCredParams = pubKeyCredParams ?? [];

  factory PublicKeyCredentialCreationOptions.fromJson(
      Map<String, Object?> json) {
    return PublicKeyCredentialCreationOptions(
      attestation: json[r'attestation'] != null
          ? AttestationConveyancePreference.fromValue(
              json[r'attestation']! as String)
          : null,
      authenticatorSelection: json[r'authenticatorSelection'] != null
          ? AuthenticatorSelectionCriteria.fromJson(
              json[r'authenticatorSelection']! as Map<String, Object?>)
          : null,
      challenge: json[r'challenge'] as String?,
      excludeCredentials: (json[r'excludeCredentials'] as List<Object?>?)
              ?.map((i) => PublicKeyCredentialDescriptor.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      extensions: json[r'extensions'] != null
          ? WebAuthnRegistrationExtensionOptions.fromJson(
              json[r'extensions']! as Map<String, Object?>)
          : null,
      pubKeyCredParams: (json[r'pubKeyCredParams'] as List<Object?>?)
              ?.map((i) => PublicKeyCredentialParameters.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      rp: json[r'rp'] != null
          ? PublicKeyCredentialRelyingPartyEntity.fromJson(
              json[r'rp']! as Map<String, Object?>)
          : null,
      timeout: (json[r'timeout'] as num?)?.toInt(),
      user: json[r'user'] != null
          ? PublicKeyCredentialUserEntity.fromJson(
              json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var attestation = this.attestation;
    var authenticatorSelection = this.authenticatorSelection;
    var challenge = this.challenge;
    var excludeCredentials = this.excludeCredentials;
    var extensions = this.extensions;
    var pubKeyCredParams = this.pubKeyCredParams;
    var rp = this.rp;
    var timeout = this.timeout;
    var user = this.user;

    final json = <String, Object?>{};
    if (attestation != null) {
      json[r'attestation'] = attestation.value;
    }
    if (authenticatorSelection != null) {
      json[r'authenticatorSelection'] = authenticatorSelection.toJson();
    }
    if (challenge != null) {
      json[r'challenge'] = challenge;
    }
    json[r'excludeCredentials'] =
        excludeCredentials.map((i) => i.toJson()).toList();
    if (extensions != null) {
      json[r'extensions'] = extensions.toJson();
    }
    json[r'pubKeyCredParams'] =
        pubKeyCredParams.map((i) => i.toJson()).toList();
    if (rp != null) {
      json[r'rp'] = rp.toJson();
    }
    if (timeout != null) {
      json[r'timeout'] = timeout;
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  PublicKeyCredentialCreationOptions copyWith(
      {AttestationConveyancePreference? attestation,
      AuthenticatorSelectionCriteria? authenticatorSelection,
      String? challenge,
      List<PublicKeyCredentialDescriptor>? excludeCredentials,
      WebAuthnRegistrationExtensionOptions? extensions,
      List<PublicKeyCredentialParameters>? pubKeyCredParams,
      PublicKeyCredentialRelyingPartyEntity? rp,
      int? timeout,
      PublicKeyCredentialUserEntity? user}) {
    return PublicKeyCredentialCreationOptions(
      attestation: attestation ?? this.attestation,
      authenticatorSelection:
          authenticatorSelection ?? this.authenticatorSelection,
      challenge: challenge ?? this.challenge,
      excludeCredentials: excludeCredentials ?? this.excludeCredentials,
      extensions: extensions ?? this.extensions,
      pubKeyCredParams: pubKeyCredParams ?? this.pubKeyCredParams,
      rp: rp ?? this.rp,
      timeout: timeout ?? this.timeout,
      user: user ?? this.user,
    );
  }
}

/// Contains attributes for the Relying Party to refer to an existing public key
/// credential as an input parameter.
class PublicKeyCredentialDescriptor {
  final String? id;
  final List<String> transports;
  final PublicKeyCredentialType? type;

  PublicKeyCredentialDescriptor({this.id, List<String>? transports, this.type})
      : transports = transports ?? [];

  factory PublicKeyCredentialDescriptor.fromJson(Map<String, Object?> json) {
    return PublicKeyCredentialDescriptor(
      id: json[r'id'] as String?,
      transports: (json[r'transports'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      type: json[r'type'] != null
          ? PublicKeyCredentialType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var transports = this.transports;
    var type = this.type;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'transports'] = transports;
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  PublicKeyCredentialDescriptor copyWith(
      {String? id, List<String>? transports, PublicKeyCredentialType? type}) {
    return PublicKeyCredentialDescriptor(
      id: id ?? this.id,
      transports: transports ?? this.transports,
      type: type ?? this.type,
    );
  }
}

/// Describes a user account or WebAuthn Relying Party associated with a public
/// key credential
class PublicKeyCredentialEntity {
  final String? name;

  PublicKeyCredentialEntity({this.name});

  factory PublicKeyCredentialEntity.fromJson(Map<String, Object?> json) {
    return PublicKeyCredentialEntity(
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  PublicKeyCredentialEntity copyWith({String? name}) {
    return PublicKeyCredentialEntity(
      name: name ?? this.name,
    );
  }
}

/// Supply information on credential type and algorithm to the
/// <i>authenticator<i>.
class PublicKeyCredentialParameters {
  final CoseAlgorithmIdentifier? alg;
  final PublicKeyCredentialType? type;

  PublicKeyCredentialParameters({this.alg, this.type});

  factory PublicKeyCredentialParameters.fromJson(Map<String, Object?> json) {
    return PublicKeyCredentialParameters(
      alg: json[r'alg'] != null
          ? CoseAlgorithmIdentifier.fromValue(json[r'alg']! as String)
          : null,
      type: json[r'type'] != null
          ? PublicKeyCredentialType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var alg = this.alg;
    var type = this.type;

    final json = <String, Object?>{};
    if (alg != null) {
      json[r'alg'] = alg.value;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  PublicKeyCredentialParameters copyWith(
      {CoseAlgorithmIdentifier? alg, PublicKeyCredentialType? type}) {
    return PublicKeyCredentialParameters(
      alg: alg ?? this.alg,
      type: type ?? this.type,
    );
  }
}

/// Supply additional information about the Relying Party when creating a new
/// credential
class PublicKeyCredentialRelyingPartyEntity {
  final String? id;
  final String? name;

  PublicKeyCredentialRelyingPartyEntity({this.id, this.name});

  factory PublicKeyCredentialRelyingPartyEntity.fromJson(
      Map<String, Object?> json) {
    return PublicKeyCredentialRelyingPartyEntity(
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  PublicKeyCredentialRelyingPartyEntity copyWith({String? id, String? name}) {
    return PublicKeyCredentialRelyingPartyEntity(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

/// Provides the <i>authenticator<i> with the data it needs to generate an
/// assertion.
class PublicKeyCredentialRequestOptions {
  final List<PublicKeyCredentialDescriptor> allowCredentials;
  final String? challenge;
  final String? rpId;
  final int? timeout;
  final UserVerificationRequirement? userVerification;

  PublicKeyCredentialRequestOptions(
      {List<PublicKeyCredentialDescriptor>? allowCredentials,
      this.challenge,
      this.rpId,
      this.timeout,
      this.userVerification})
      : allowCredentials = allowCredentials ?? [];

  factory PublicKeyCredentialRequestOptions.fromJson(
      Map<String, Object?> json) {
    return PublicKeyCredentialRequestOptions(
      allowCredentials: (json[r'allowCredentials'] as List<Object?>?)
              ?.map((i) => PublicKeyCredentialDescriptor.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      challenge: json[r'challenge'] as String?,
      rpId: json[r'rpId'] as String?,
      timeout: (json[r'timeout'] as num?)?.toInt(),
      userVerification: json[r'userVerification'] != null
          ? UserVerificationRequirement.fromValue(
              json[r'userVerification']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var allowCredentials = this.allowCredentials;
    var challenge = this.challenge;
    var rpId = this.rpId;
    var timeout = this.timeout;
    var userVerification = this.userVerification;

    final json = <String, Object?>{};
    json[r'allowCredentials'] =
        allowCredentials.map((i) => i.toJson()).toList();
    if (challenge != null) {
      json[r'challenge'] = challenge;
    }
    if (rpId != null) {
      json[r'rpId'] = rpId;
    }
    if (timeout != null) {
      json[r'timeout'] = timeout;
    }
    if (userVerification != null) {
      json[r'userVerification'] = userVerification.value;
    }
    return json;
  }

  PublicKeyCredentialRequestOptions copyWith(
      {List<PublicKeyCredentialDescriptor>? allowCredentials,
      String? challenge,
      String? rpId,
      int? timeout,
      UserVerificationRequirement? userVerification}) {
    return PublicKeyCredentialRequestOptions(
      allowCredentials: allowCredentials ?? this.allowCredentials,
      challenge: challenge ?? this.challenge,
      rpId: rpId ?? this.rpId,
      timeout: timeout ?? this.timeout,
      userVerification: userVerification ?? this.userVerification,
    );
  }
}

/// Supply additional information about the user account when creating a new
/// credential
class PublicKeyCredentialUserEntity {
  final String? displayName;
  final String? id;
  final String? name;

  PublicKeyCredentialUserEntity({this.displayName, this.id, this.name});

  factory PublicKeyCredentialUserEntity.fromJson(Map<String, Object?> json) {
    return PublicKeyCredentialUserEntity(
      displayName: json[r'displayName'] as String?,
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var displayName = this.displayName;
    var id = this.id;
    var name = this.name;

    final json = <String, Object?>{};
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  PublicKeyCredentialUserEntity copyWith(
      {String? displayName, String? id, String? name}) {
    return PublicKeyCredentialUserEntity(
      displayName: displayName ?? this.displayName,
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

/// JWT Public Key Response Object
class PublicKeyResponse {
  final String? publicKey;
  final Map<String, dynamic>? publicKeys;

  PublicKeyResponse({this.publicKey, this.publicKeys});

  factory PublicKeyResponse.fromJson(Map<String, Object?> json) {
    return PublicKeyResponse(
      publicKey: json[r'publicKey'] as String?,
      publicKeys: json[r'publicKeys'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var publicKey = this.publicKey;
    var publicKeys = this.publicKeys;

    final json = <String, Object?>{};
    if (publicKey != null) {
      json[r'publicKey'] = publicKey;
    }
    if (publicKeys != null) {
      json[r'publicKeys'] = publicKeys;
    }
    return json;
  }

  PublicKeyResponse copyWith(
      {String? publicKey, Map<String, dynamic>? publicKeys}) {
    return PublicKeyResponse(
      publicKey: publicKey ?? this.publicKey,
      publicKeys: publicKeys ?? this.publicKeys,
    );
  }
}

class RateLimitedRequestConfiguration {
  final int? limit;
  final int? timePeriodInSeconds;
  final bool enabled;

  RateLimitedRequestConfiguration(
      {this.limit, this.timePeriodInSeconds, bool? enabled})
      : enabled = enabled ?? false;

  factory RateLimitedRequestConfiguration.fromJson(Map<String, Object?> json) {
    return RateLimitedRequestConfiguration(
      limit: (json[r'limit'] as num?)?.toInt(),
      timePeriodInSeconds: (json[r'timePeriodInSeconds'] as num?)?.toInt(),
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var limit = this.limit;
    var timePeriodInSeconds = this.timePeriodInSeconds;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (limit != null) {
      json[r'limit'] = limit;
    }
    if (timePeriodInSeconds != null) {
      json[r'timePeriodInSeconds'] = timePeriodInSeconds;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  RateLimitedRequestConfiguration copyWith(
      {int? limit, int? timePeriodInSeconds, bool? enabled}) {
    return RateLimitedRequestConfiguration(
      limit: limit ?? this.limit,
      timePeriodInSeconds: timePeriodInSeconds ?? this.timePeriodInSeconds,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Raw login information for each time a user logs into an application.
class RawLogin {
  final String? applicationId;
  final ZonedDateTime? instant;
  final String? ipAddress;
  final String? userId;

  RawLogin({this.applicationId, this.instant, this.ipAddress, this.userId});

  factory RawLogin.fromJson(Map<String, Object?> json) {
    return RawLogin(
      applicationId: json[r'applicationId'] as String?,
      instant: (json[r'instant'] as num?)?.toInt() as ZonedDateTime?,
      ipAddress: json[r'ipAddress'] as String?,
      userId: json[r'userId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var instant = this.instant;
    var ipAddress = this.ipAddress;
    var userId = this.userId;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (instant != null) {
      json[r'instant'] = instant.toJson();
    }
    if (ipAddress != null) {
      json[r'ipAddress'] = ipAddress;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    return json;
  }

  RawLogin copyWith(
      {String? applicationId,
      ZonedDateTime? instant,
      String? ipAddress,
      String? userId}) {
    return RawLogin(
      applicationId: applicationId ?? this.applicationId,
      instant: instant ?? this.instant,
      ipAddress: ipAddress ?? this.ipAddress,
      userId: userId ?? this.userId,
    );
  }
}

class ReactorMetrics {
  final Map<String, dynamic>? breachedPasswordMetrics;

  ReactorMetrics({this.breachedPasswordMetrics});

  factory ReactorMetrics.fromJson(Map<String, Object?> json) {
    return ReactorMetrics(
      breachedPasswordMetrics:
          json[r'breachedPasswordMetrics'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var breachedPasswordMetrics = this.breachedPasswordMetrics;

    final json = <String, Object?>{};
    if (breachedPasswordMetrics != null) {
      json[r'breachedPasswordMetrics'] = breachedPasswordMetrics;
    }
    return json;
  }

  ReactorMetrics copyWith({Map<String, dynamic>? breachedPasswordMetrics}) {
    return ReactorMetrics(
      breachedPasswordMetrics:
          breachedPasswordMetrics ?? this.breachedPasswordMetrics,
    );
  }
}

class ReactorMetricsResponse {
  final ReactorMetrics? metrics;

  ReactorMetricsResponse({this.metrics});

  factory ReactorMetricsResponse.fromJson(Map<String, Object?> json) {
    return ReactorMetricsResponse(
      metrics: json[r'metrics'] != null
          ? ReactorMetrics.fromJson(json[r'metrics']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var metrics = this.metrics;

    final json = <String, Object?>{};
    if (metrics != null) {
      json[r'metrics'] = metrics.toJson();
    }
    return json;
  }

  ReactorMetricsResponse copyWith({ReactorMetrics? metrics}) {
    return ReactorMetricsResponse(
      metrics: metrics ?? this.metrics,
    );
  }
}

/// Request for managing FusionAuth Reactor and licenses.
class ReactorRequest {
  final String? license;
  final String? licenseId;

  ReactorRequest({this.license, this.licenseId});

  factory ReactorRequest.fromJson(Map<String, Object?> json) {
    return ReactorRequest(
      license: json[r'license'] as String?,
      licenseId: json[r'licenseId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var license = this.license;
    var licenseId = this.licenseId;

    final json = <String, Object?>{};
    if (license != null) {
      json[r'license'] = license;
    }
    if (licenseId != null) {
      json[r'licenseId'] = licenseId;
    }
    return json;
  }

  ReactorRequest copyWith({String? license, String? licenseId}) {
    return ReactorRequest(
      license: license ?? this.license,
      licenseId: licenseId ?? this.licenseId,
    );
  }
}

class ReactorResponse {
  final ReactorStatus? status;

  ReactorResponse({this.status});

  factory ReactorResponse.fromJson(Map<String, Object?> json) {
    return ReactorResponse(
      status: json[r'status'] != null
          ? ReactorStatus.fromJson(json[r'status']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var status = this.status;

    final json = <String, Object?>{};
    if (status != null) {
      json[r'status'] = status.toJson();
    }
    return json;
  }

  ReactorResponse copyWith({ReactorStatus? status}) {
    return ReactorResponse(
      status: status ?? this.status,
    );
  }
}

class ReactorStatus {
  final ReactorFeatureStatus? advancedIdentityProviders;
  final ReactorFeatureStatus? advancedLambdas;
  final ReactorFeatureStatus? advancedMultiFactorAuthentication;
  final ReactorFeatureStatus? advancedoAuthScopes;
  final ReactorFeatureStatus? advancedoAuthScopesCustomScopes;
  final ReactorFeatureStatus? advancedoAuthScopesThirdPartyApplications;
  final ReactorFeatureStatus? advancedRegistration;
  final ReactorFeatureStatus? applicationMultiFactorAuthentication;
  final ReactorFeatureStatus? applicationThemes;
  final ReactorFeatureStatus? breachedPasswordDetection;
  final ReactorFeatureStatus? connectors;
  final ReactorFeatureStatus? entityManagement;
  final LocalDate? expiration;
  final Map<String, dynamic>? licenseAttributes;
  final bool licensed;
  final ReactorFeatureStatus? scimServer;
  final ReactorFeatureStatus? threatDetection;
  final ReactorFeatureStatus? webAuthn;
  final ReactorFeatureStatus? webAuthnPlatformAuthenticators;
  final ReactorFeatureStatus? webAuthnRoamingAuthenticators;

  ReactorStatus(
      {this.advancedIdentityProviders,
      this.advancedLambdas,
      this.advancedMultiFactorAuthentication,
      this.advancedoAuthScopes,
      this.advancedoAuthScopesCustomScopes,
      this.advancedoAuthScopesThirdPartyApplications,
      this.advancedRegistration,
      this.applicationMultiFactorAuthentication,
      this.applicationThemes,
      this.breachedPasswordDetection,
      this.connectors,
      this.entityManagement,
      this.expiration,
      this.licenseAttributes,
      bool? licensed,
      this.scimServer,
      this.threatDetection,
      this.webAuthn,
      this.webAuthnPlatformAuthenticators,
      this.webAuthnRoamingAuthenticators})
      : licensed = licensed ?? false;

  factory ReactorStatus.fromJson(Map<String, Object?> json) {
    return ReactorStatus(
      advancedIdentityProviders: json[r'advancedIdentityProviders'] != null
          ? ReactorFeatureStatus.fromValue(
              json[r'advancedIdentityProviders']! as String)
          : null,
      advancedLambdas: json[r'advancedLambdas'] != null
          ? ReactorFeatureStatus.fromValue(json[r'advancedLambdas']! as String)
          : null,
      advancedMultiFactorAuthentication:
          json[r'advancedMultiFactorAuthentication'] != null
              ? ReactorFeatureStatus.fromValue(
                  json[r'advancedMultiFactorAuthentication']! as String)
              : null,
      advancedoAuthScopes: json[r'advancedOAuthScopes'] != null
          ? ReactorFeatureStatus.fromValue(
              json[r'advancedOAuthScopes']! as String)
          : null,
      advancedoAuthScopesCustomScopes:
          json[r'advancedOAuthScopesCustomScopes'] != null
              ? ReactorFeatureStatus.fromValue(
                  json[r'advancedOAuthScopesCustomScopes']! as String)
              : null,
      advancedoAuthScopesThirdPartyApplications:
          json[r'advancedOAuthScopesThirdPartyApplications'] != null
              ? ReactorFeatureStatus.fromValue(
                  json[r'advancedOAuthScopesThirdPartyApplications']! as String)
              : null,
      advancedRegistration: json[r'advancedRegistration'] != null
          ? ReactorFeatureStatus.fromValue(
              json[r'advancedRegistration']! as String)
          : null,
      applicationMultiFactorAuthentication:
          json[r'applicationMultiFactorAuthentication'] != null
              ? ReactorFeatureStatus.fromValue(
                  json[r'applicationMultiFactorAuthentication']! as String)
              : null,
      applicationThemes: json[r'applicationThemes'] != null
          ? ReactorFeatureStatus.fromValue(
              json[r'applicationThemes']! as String)
          : null,
      breachedPasswordDetection: json[r'breachedPasswordDetection'] != null
          ? ReactorFeatureStatus.fromValue(
              json[r'breachedPasswordDetection']! as String)
          : null,
      connectors: json[r'connectors'] != null
          ? ReactorFeatureStatus.fromValue(json[r'connectors']! as String)
          : null,
      entityManagement: json[r'entityManagement'] != null
          ? ReactorFeatureStatus.fromValue(json[r'entityManagement']! as String)
          : null,
      expiration: json[r'expiration'] as LocalDate?,
      licenseAttributes: json[r'licenseAttributes'] as Map<String, Object?>?,
      licensed: json[r'licensed'] as bool? ?? false,
      scimServer: json[r'scimServer'] != null
          ? ReactorFeatureStatus.fromValue(json[r'scimServer']! as String)
          : null,
      threatDetection: json[r'threatDetection'] != null
          ? ReactorFeatureStatus.fromValue(json[r'threatDetection']! as String)
          : null,
      webAuthn: json[r'webAuthn'] != null
          ? ReactorFeatureStatus.fromValue(json[r'webAuthn']! as String)
          : null,
      webAuthnPlatformAuthenticators:
          json[r'webAuthnPlatformAuthenticators'] != null
              ? ReactorFeatureStatus.fromValue(
                  json[r'webAuthnPlatformAuthenticators']! as String)
              : null,
      webAuthnRoamingAuthenticators:
          json[r'webAuthnRoamingAuthenticators'] != null
              ? ReactorFeatureStatus.fromValue(
                  json[r'webAuthnRoamingAuthenticators']! as String)
              : null,
    );
  }

  Map<String, Object?> toJson() {
    var advancedIdentityProviders = this.advancedIdentityProviders;
    var advancedLambdas = this.advancedLambdas;
    var advancedMultiFactorAuthentication =
        this.advancedMultiFactorAuthentication;
    var advancedoAuthScopes = this.advancedoAuthScopes;
    var advancedoAuthScopesCustomScopes = this.advancedoAuthScopesCustomScopes;
    var advancedoAuthScopesThirdPartyApplications =
        this.advancedoAuthScopesThirdPartyApplications;
    var advancedRegistration = this.advancedRegistration;
    var applicationMultiFactorAuthentication =
        this.applicationMultiFactorAuthentication;
    var applicationThemes = this.applicationThemes;
    var breachedPasswordDetection = this.breachedPasswordDetection;
    var connectors = this.connectors;
    var entityManagement = this.entityManagement;
    var expiration = this.expiration;
    var licenseAttributes = this.licenseAttributes;
    var licensed = this.licensed;
    var scimServer = this.scimServer;
    var threatDetection = this.threatDetection;
    var webAuthn = this.webAuthn;
    var webAuthnPlatformAuthenticators = this.webAuthnPlatformAuthenticators;
    var webAuthnRoamingAuthenticators = this.webAuthnRoamingAuthenticators;

    final json = <String, Object?>{};
    if (advancedIdentityProviders != null) {
      json[r'advancedIdentityProviders'] = advancedIdentityProviders.value;
    }
    if (advancedLambdas != null) {
      json[r'advancedLambdas'] = advancedLambdas.value;
    }
    if (advancedMultiFactorAuthentication != null) {
      json[r'advancedMultiFactorAuthentication'] =
          advancedMultiFactorAuthentication.value;
    }
    if (advancedoAuthScopes != null) {
      json[r'advancedOAuthScopes'] = advancedoAuthScopes.value;
    }
    if (advancedoAuthScopesCustomScopes != null) {
      json[r'advancedOAuthScopesCustomScopes'] =
          advancedoAuthScopesCustomScopes.value;
    }
    if (advancedoAuthScopesThirdPartyApplications != null) {
      json[r'advancedOAuthScopesThirdPartyApplications'] =
          advancedoAuthScopesThirdPartyApplications.value;
    }
    if (advancedRegistration != null) {
      json[r'advancedRegistration'] = advancedRegistration.value;
    }
    if (applicationMultiFactorAuthentication != null) {
      json[r'applicationMultiFactorAuthentication'] =
          applicationMultiFactorAuthentication.value;
    }
    if (applicationThemes != null) {
      json[r'applicationThemes'] = applicationThemes.value;
    }
    if (breachedPasswordDetection != null) {
      json[r'breachedPasswordDetection'] = breachedPasswordDetection.value;
    }
    if (connectors != null) {
      json[r'connectors'] = connectors.value;
    }
    if (entityManagement != null) {
      json[r'entityManagement'] = entityManagement.value;
    }
    if (expiration != null) {
      json[r'expiration'] = expiration.toJson();
    }
    if (licenseAttributes != null) {
      json[r'licenseAttributes'] = licenseAttributes;
    }
    json[r'licensed'] = licensed;
    if (scimServer != null) {
      json[r'scimServer'] = scimServer.value;
    }
    if (threatDetection != null) {
      json[r'threatDetection'] = threatDetection.value;
    }
    if (webAuthn != null) {
      json[r'webAuthn'] = webAuthn.value;
    }
    if (webAuthnPlatformAuthenticators != null) {
      json[r'webAuthnPlatformAuthenticators'] =
          webAuthnPlatformAuthenticators.value;
    }
    if (webAuthnRoamingAuthenticators != null) {
      json[r'webAuthnRoamingAuthenticators'] =
          webAuthnRoamingAuthenticators.value;
    }
    return json;
  }

  ReactorStatus copyWith(
      {ReactorFeatureStatus? advancedIdentityProviders,
      ReactorFeatureStatus? advancedLambdas,
      ReactorFeatureStatus? advancedMultiFactorAuthentication,
      ReactorFeatureStatus? advancedoAuthScopes,
      ReactorFeatureStatus? advancedoAuthScopesCustomScopes,
      ReactorFeatureStatus? advancedoAuthScopesThirdPartyApplications,
      ReactorFeatureStatus? advancedRegistration,
      ReactorFeatureStatus? applicationMultiFactorAuthentication,
      ReactorFeatureStatus? applicationThemes,
      ReactorFeatureStatus? breachedPasswordDetection,
      ReactorFeatureStatus? connectors,
      ReactorFeatureStatus? entityManagement,
      LocalDate? expiration,
      Map<String, dynamic>? licenseAttributes,
      bool? licensed,
      ReactorFeatureStatus? scimServer,
      ReactorFeatureStatus? threatDetection,
      ReactorFeatureStatus? webAuthn,
      ReactorFeatureStatus? webAuthnPlatformAuthenticators,
      ReactorFeatureStatus? webAuthnRoamingAuthenticators}) {
    return ReactorStatus(
      advancedIdentityProviders:
          advancedIdentityProviders ?? this.advancedIdentityProviders,
      advancedLambdas: advancedLambdas ?? this.advancedLambdas,
      advancedMultiFactorAuthentication: advancedMultiFactorAuthentication ??
          this.advancedMultiFactorAuthentication,
      advancedoAuthScopes: advancedoAuthScopes ?? this.advancedoAuthScopes,
      advancedoAuthScopesCustomScopes: advancedoAuthScopesCustomScopes ??
          this.advancedoAuthScopesCustomScopes,
      advancedoAuthScopesThirdPartyApplications:
          advancedoAuthScopesThirdPartyApplications ??
              this.advancedoAuthScopesThirdPartyApplications,
      advancedRegistration: advancedRegistration ?? this.advancedRegistration,
      applicationMultiFactorAuthentication:
          applicationMultiFactorAuthentication ??
              this.applicationMultiFactorAuthentication,
      applicationThemes: applicationThemes ?? this.applicationThemes,
      breachedPasswordDetection:
          breachedPasswordDetection ?? this.breachedPasswordDetection,
      connectors: connectors ?? this.connectors,
      entityManagement: entityManagement ?? this.entityManagement,
      expiration: expiration ?? this.expiration,
      licenseAttributes: licenseAttributes ?? this.licenseAttributes,
      licensed: licensed ?? this.licensed,
      scimServer: scimServer ?? this.scimServer,
      threatDetection: threatDetection ?? this.threatDetection,
      webAuthn: webAuthn ?? this.webAuthn,
      webAuthnPlatformAuthenticators:
          webAuthnPlatformAuthenticators ?? this.webAuthnPlatformAuthenticators,
      webAuthnRoamingAuthenticators:
          webAuthnRoamingAuthenticators ?? this.webAuthnRoamingAuthenticators,
    );
  }
}

/// Response for the user login report.
class RecentLoginResponse {
  final List<DisplayableRawLogin> logins;

  RecentLoginResponse({List<DisplayableRawLogin>? logins})
      : logins = logins ?? [];

  factory RecentLoginResponse.fromJson(Map<String, Object?> json) {
    return RecentLoginResponse(
      logins: (json[r'logins'] as List<Object?>?)
              ?.map((i) => DisplayableRawLogin.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var logins = this.logins;

    final json = <String, Object?>{};
    json[r'logins'] = logins.map((i) => i.toJson()).toList();
    return json;
  }

  RecentLoginResponse copyWith({List<DisplayableRawLogin>? logins}) {
    return RecentLoginResponse(
      logins: logins ?? this.logins,
    );
  }
}

class RefreshRequest {
  final String? refreshToken;
  final String? token;
  final EventInfo? eventInfo;

  RefreshRequest({this.refreshToken, this.token, this.eventInfo});

  factory RefreshRequest.fromJson(Map<String, Object?> json) {
    return RefreshRequest(
      refreshToken: json[r'refreshToken'] as String?,
      token: json[r'token'] as String?,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var refreshToken = this.refreshToken;
    var token = this.token;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (refreshToken != null) {
      json[r'refreshToken'] = refreshToken;
    }
    if (token != null) {
      json[r'token'] = token;
    }
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  RefreshRequest copyWith(
      {String? refreshToken, String? token, EventInfo? eventInfo}) {
    return RefreshRequest(
      refreshToken: refreshToken ?? this.refreshToken,
      token: token ?? this.token,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

class RefreshResponse {
  RefreshResponse();

  factory RefreshResponse.fromJson(Map<String, Object?> json) {
    return RefreshResponse();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// Models a JWT Refresh Token.
class RefreshToken {
  final String? applicationId;
  final Map<String, dynamic>? data;
  final String? id;
  final ZonedDateTime? insertInstant;
  final MetaData? metaData;
  final ZonedDateTime? startInstant;
  final String? tenantId;
  final String? token;
  final String? userId;

  RefreshToken(
      {this.applicationId,
      this.data,
      this.id,
      this.insertInstant,
      this.metaData,
      this.startInstant,
      this.tenantId,
      this.token,
      this.userId});

  factory RefreshToken.fromJson(Map<String, Object?> json) {
    return RefreshToken(
      applicationId: json[r'applicationId'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      metaData: json[r'metaData'] != null
          ? MetaData.fromJson(json[r'metaData']! as Map<String, Object?>)
          : null,
      startInstant: (json[r'startInstant'] as num?)?.toInt() as ZonedDateTime?,
      tenantId: json[r'tenantId'] as String?,
      token: json[r'token'] as String?,
      userId: json[r'userId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var data = this.data;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var metaData = this.metaData;
    var startInstant = this.startInstant;
    var tenantId = this.tenantId;
    var token = this.token;
    var userId = this.userId;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (metaData != null) {
      json[r'metaData'] = metaData.toJson();
    }
    if (startInstant != null) {
      json[r'startInstant'] = startInstant.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (token != null) {
      json[r'token'] = token;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    return json;
  }

  RefreshToken copyWith(
      {String? applicationId,
      Map<String, dynamic>? data,
      String? id,
      ZonedDateTime? insertInstant,
      MetaData? metaData,
      ZonedDateTime? startInstant,
      String? tenantId,
      String? token,
      String? userId}) {
    return RefreshToken(
      applicationId: applicationId ?? this.applicationId,
      data: data ?? this.data,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      metaData: metaData ?? this.metaData,
      startInstant: startInstant ?? this.startInstant,
      tenantId: tenantId ?? this.tenantId,
      token: token ?? this.token,
      userId: userId ?? this.userId,
    );
  }
}

/// Refresh Token Import request.
class RefreshTokenImportRequest {
  final List<RefreshToken> refreshTokens;
  final bool validateDbConstraints;

  RefreshTokenImportRequest(
      {List<RefreshToken>? refreshTokens, bool? validateDbConstraints})
      : refreshTokens = refreshTokens ?? [],
        validateDbConstraints = validateDbConstraints ?? false;

  factory RefreshTokenImportRequest.fromJson(Map<String, Object?> json) {
    return RefreshTokenImportRequest(
      refreshTokens: (json[r'refreshTokens'] as List<Object?>?)
              ?.map((i) =>
                  RefreshToken.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      validateDbConstraints: json[r'validateDbConstraints'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var refreshTokens = this.refreshTokens;
    var validateDbConstraints = this.validateDbConstraints;

    final json = <String, Object?>{};
    json[r'refreshTokens'] = refreshTokens.map((i) => i.toJson()).toList();
    json[r'validateDbConstraints'] = validateDbConstraints;
    return json;
  }

  RefreshTokenImportRequest copyWith(
      {List<RefreshToken>? refreshTokens, bool? validateDbConstraints}) {
    return RefreshTokenImportRequest(
      refreshTokens: refreshTokens ?? this.refreshTokens,
      validateDbConstraints:
          validateDbConstraints ?? this.validateDbConstraints,
    );
  }
}

/// API response for retrieving Refresh Tokens
class RefreshTokenResponse {
  final RefreshToken? refreshToken;
  final List<RefreshToken> refreshTokens;

  RefreshTokenResponse({this.refreshToken, List<RefreshToken>? refreshTokens})
      : refreshTokens = refreshTokens ?? [];

  factory RefreshTokenResponse.fromJson(Map<String, Object?> json) {
    return RefreshTokenResponse(
      refreshToken: json[r'refreshToken'] != null
          ? RefreshToken.fromJson(
              json[r'refreshToken']! as Map<String, Object?>)
          : null,
      refreshTokens: (json[r'refreshTokens'] as List<Object?>?)
              ?.map((i) =>
                  RefreshToken.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var refreshToken = this.refreshToken;
    var refreshTokens = this.refreshTokens;

    final json = <String, Object?>{};
    if (refreshToken != null) {
      json[r'refreshToken'] = refreshToken.toJson();
    }
    json[r'refreshTokens'] = refreshTokens.map((i) => i.toJson()).toList();
    return json;
  }

  RefreshTokenResponse copyWith(
      {RefreshToken? refreshToken, List<RefreshToken>? refreshTokens}) {
    return RefreshTokenResponse(
      refreshToken: refreshToken ?? this.refreshToken,
      refreshTokens: refreshTokens ?? this.refreshTokens,
    );
  }
}

class RefreshTokenRevocationPolicy {
  final bool onLoginPrevented;
  final bool onMultiFactorEnable;
  final bool onPasswordChanged;

  RefreshTokenRevocationPolicy(
      {bool? onLoginPrevented,
      bool? onMultiFactorEnable,
      bool? onPasswordChanged})
      : onLoginPrevented = onLoginPrevented ?? false,
        onMultiFactorEnable = onMultiFactorEnable ?? false,
        onPasswordChanged = onPasswordChanged ?? false;

  factory RefreshTokenRevocationPolicy.fromJson(Map<String, Object?> json) {
    return RefreshTokenRevocationPolicy(
      onLoginPrevented: json[r'onLoginPrevented'] as bool? ?? false,
      onMultiFactorEnable: json[r'onMultiFactorEnable'] as bool? ?? false,
      onPasswordChanged: json[r'onPasswordChanged'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var onLoginPrevented = this.onLoginPrevented;
    var onMultiFactorEnable = this.onMultiFactorEnable;
    var onPasswordChanged = this.onPasswordChanged;

    final json = <String, Object?>{};
    json[r'onLoginPrevented'] = onLoginPrevented;
    json[r'onMultiFactorEnable'] = onMultiFactorEnable;
    json[r'onPasswordChanged'] = onPasswordChanged;
    return json;
  }

  RefreshTokenRevocationPolicy copyWith(
      {bool? onLoginPrevented,
      bool? onMultiFactorEnable,
      bool? onPasswordChanged}) {
    return RefreshTokenRevocationPolicy(
      onLoginPrevented: onLoginPrevented ?? this.onLoginPrevented,
      onMultiFactorEnable: onMultiFactorEnable ?? this.onMultiFactorEnable,
      onPasswordChanged: onPasswordChanged ?? this.onPasswordChanged,
    );
  }
}

/// Request for the Refresh Token API to revoke a refresh token rather than
/// using the URL parameters.
class RefreshTokenRevokeRequest {
  final String? applicationId;
  final String? token;
  final String? userId;
  final EventInfo? eventInfo;

  RefreshTokenRevokeRequest(
      {this.applicationId, this.token, this.userId, this.eventInfo});

  factory RefreshTokenRevokeRequest.fromJson(Map<String, Object?> json) {
    return RefreshTokenRevokeRequest(
      applicationId: json[r'applicationId'] as String?,
      token: json[r'token'] as String?,
      userId: json[r'userId'] as String?,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var token = this.token;
    var userId = this.userId;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (token != null) {
      json[r'token'] = token;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  RefreshTokenRevokeRequest copyWith(
      {String? applicationId,
      String? token,
      String? userId,
      EventInfo? eventInfo}) {
    return RefreshTokenRevokeRequest(
      applicationId: applicationId ?? this.applicationId,
      token: token ?? this.token,
      userId: userId ?? this.userId,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

class RefreshTokenSlidingWindowConfiguration {
  final int? maximumTimeToLiveInMinutes;

  RefreshTokenSlidingWindowConfiguration({this.maximumTimeToLiveInMinutes});

  factory RefreshTokenSlidingWindowConfiguration.fromJson(
      Map<String, Object?> json) {
    return RefreshTokenSlidingWindowConfiguration(
      maximumTimeToLiveInMinutes:
          (json[r'maximumTimeToLiveInMinutes'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var maximumTimeToLiveInMinutes = this.maximumTimeToLiveInMinutes;

    final json = <String, Object?>{};
    if (maximumTimeToLiveInMinutes != null) {
      json[r'maximumTimeToLiveInMinutes'] = maximumTimeToLiveInMinutes;
    }
    return json;
  }

  RefreshTokenSlidingWindowConfiguration copyWith(
      {int? maximumTimeToLiveInMinutes}) {
    return RefreshTokenSlidingWindowConfiguration(
      maximumTimeToLiveInMinutes:
          maximumTimeToLiveInMinutes ?? this.maximumTimeToLiveInMinutes,
    );
  }
}

class RegistrationConfiguration {
  final Requirable? birthDate;
  final bool confirmPassword;
  final Requirable? firstName;
  final String? formId;
  final Requirable? fullName;
  final Requirable? lastName;
  final LoginIdType? loginIdType;
  final Requirable? middleName;
  final Requirable? mobilePhone;
  final Requirable? preferredLanguages;
  final RegistrationType? type;
  final bool enabled;

  RegistrationConfiguration(
      {this.birthDate,
      bool? confirmPassword,
      this.firstName,
      this.formId,
      this.fullName,
      this.lastName,
      this.loginIdType,
      this.middleName,
      this.mobilePhone,
      this.preferredLanguages,
      this.type,
      bool? enabled})
      : confirmPassword = confirmPassword ?? false,
        enabled = enabled ?? false;

  factory RegistrationConfiguration.fromJson(Map<String, Object?> json) {
    return RegistrationConfiguration(
      birthDate: json[r'birthDate'] != null
          ? Requirable.fromJson(json[r'birthDate']! as Map<String, Object?>)
          : null,
      confirmPassword: json[r'confirmPassword'] as bool? ?? false,
      firstName: json[r'firstName'] != null
          ? Requirable.fromJson(json[r'firstName']! as Map<String, Object?>)
          : null,
      formId: json[r'formId'] as String?,
      fullName: json[r'fullName'] != null
          ? Requirable.fromJson(json[r'fullName']! as Map<String, Object?>)
          : null,
      lastName: json[r'lastName'] != null
          ? Requirable.fromJson(json[r'lastName']! as Map<String, Object?>)
          : null,
      loginIdType: json[r'loginIdType'] != null
          ? LoginIdType.fromValue(json[r'loginIdType']! as String)
          : null,
      middleName: json[r'middleName'] != null
          ? Requirable.fromJson(json[r'middleName']! as Map<String, Object?>)
          : null,
      mobilePhone: json[r'mobilePhone'] != null
          ? Requirable.fromJson(json[r'mobilePhone']! as Map<String, Object?>)
          : null,
      preferredLanguages: json[r'preferredLanguages'] != null
          ? Requirable.fromJson(
              json[r'preferredLanguages']! as Map<String, Object?>)
          : null,
      type: json[r'type'] != null
          ? RegistrationType.fromValue(json[r'type']! as String)
          : null,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var birthDate = this.birthDate;
    var confirmPassword = this.confirmPassword;
    var firstName = this.firstName;
    var formId = this.formId;
    var fullName = this.fullName;
    var lastName = this.lastName;
    var loginIdType = this.loginIdType;
    var middleName = this.middleName;
    var mobilePhone = this.mobilePhone;
    var preferredLanguages = this.preferredLanguages;
    var type = this.type;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (birthDate != null) {
      json[r'birthDate'] = birthDate.toJson();
    }
    json[r'confirmPassword'] = confirmPassword;
    if (firstName != null) {
      json[r'firstName'] = firstName.toJson();
    }
    if (formId != null) {
      json[r'formId'] = formId;
    }
    if (fullName != null) {
      json[r'fullName'] = fullName.toJson();
    }
    if (lastName != null) {
      json[r'lastName'] = lastName.toJson();
    }
    if (loginIdType != null) {
      json[r'loginIdType'] = loginIdType.value;
    }
    if (middleName != null) {
      json[r'middleName'] = middleName.toJson();
    }
    if (mobilePhone != null) {
      json[r'mobilePhone'] = mobilePhone.toJson();
    }
    if (preferredLanguages != null) {
      json[r'preferredLanguages'] = preferredLanguages.toJson();
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  RegistrationConfiguration copyWith(
      {Requirable? birthDate,
      bool? confirmPassword,
      Requirable? firstName,
      String? formId,
      Requirable? fullName,
      Requirable? lastName,
      LoginIdType? loginIdType,
      Requirable? middleName,
      Requirable? mobilePhone,
      Requirable? preferredLanguages,
      RegistrationType? type,
      bool? enabled}) {
    return RegistrationConfiguration(
      birthDate: birthDate ?? this.birthDate,
      confirmPassword: confirmPassword ?? this.confirmPassword,
      firstName: firstName ?? this.firstName,
      formId: formId ?? this.formId,
      fullName: fullName ?? this.fullName,
      lastName: lastName ?? this.lastName,
      loginIdType: loginIdType ?? this.loginIdType,
      middleName: middleName ?? this.middleName,
      mobilePhone: mobilePhone ?? this.mobilePhone,
      preferredLanguages: preferredLanguages ?? this.preferredLanguages,
      type: type ?? this.type,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Registration delete API request object.
class RegistrationDeleteRequest {
  final EventInfo? eventInfo;

  RegistrationDeleteRequest({this.eventInfo});

  factory RegistrationDeleteRequest.fromJson(Map<String, Object?> json) {
    return RegistrationDeleteRequest(
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  RegistrationDeleteRequest copyWith({EventInfo? eventInfo}) {
    return RegistrationDeleteRequest(
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

/// Response for the registration report.
class RegistrationReportResponse {
  final List<Count> hourlyCounts;
  final int? total;

  RegistrationReportResponse({List<Count>? hourlyCounts, this.total})
      : hourlyCounts = hourlyCounts ?? [];

  factory RegistrationReportResponse.fromJson(Map<String, Object?> json) {
    return RegistrationReportResponse(
      hourlyCounts: (json[r'hourlyCounts'] as List<Object?>?)
              ?.map(
                  (i) => Count.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var hourlyCounts = this.hourlyCounts;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'hourlyCounts'] = hourlyCounts.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  RegistrationReportResponse copyWith({List<Count>? hourlyCounts, int? total}) {
    return RegistrationReportResponse(
      hourlyCounts: hourlyCounts ?? this.hourlyCounts,
      total: total ?? this.total,
    );
  }
}

/// Registration API request object.
class RegistrationRequest {
  final bool disableDomainBlock;
  final bool generateAuthenticationToken;
  final UserRegistration? registration;
  final bool sendSetPasswordEmail;
  final bool skipRegistrationVerification;
  final bool skipVerification;
  final User? user;
  final EventInfo? eventInfo;

  RegistrationRequest(
      {bool? disableDomainBlock,
      bool? generateAuthenticationToken,
      this.registration,
      bool? sendSetPasswordEmail,
      bool? skipRegistrationVerification,
      bool? skipVerification,
      this.user,
      this.eventInfo})
      : disableDomainBlock = disableDomainBlock ?? false,
        generateAuthenticationToken = generateAuthenticationToken ?? false,
        sendSetPasswordEmail = sendSetPasswordEmail ?? false,
        skipRegistrationVerification = skipRegistrationVerification ?? false,
        skipVerification = skipVerification ?? false;

  factory RegistrationRequest.fromJson(Map<String, Object?> json) {
    return RegistrationRequest(
      disableDomainBlock: json[r'disableDomainBlock'] as bool? ?? false,
      generateAuthenticationToken:
          json[r'generateAuthenticationToken'] as bool? ?? false,
      registration: json[r'registration'] != null
          ? UserRegistration.fromJson(
              json[r'registration']! as Map<String, Object?>)
          : null,
      sendSetPasswordEmail: json[r'sendSetPasswordEmail'] as bool? ?? false,
      skipRegistrationVerification:
          json[r'skipRegistrationVerification'] as bool? ?? false,
      skipVerification: json[r'skipVerification'] as bool? ?? false,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var disableDomainBlock = this.disableDomainBlock;
    var generateAuthenticationToken = this.generateAuthenticationToken;
    var registration = this.registration;
    var sendSetPasswordEmail = this.sendSetPasswordEmail;
    var skipRegistrationVerification = this.skipRegistrationVerification;
    var skipVerification = this.skipVerification;
    var user = this.user;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    json[r'disableDomainBlock'] = disableDomainBlock;
    json[r'generateAuthenticationToken'] = generateAuthenticationToken;
    if (registration != null) {
      json[r'registration'] = registration.toJson();
    }
    json[r'sendSetPasswordEmail'] = sendSetPasswordEmail;
    json[r'skipRegistrationVerification'] = skipRegistrationVerification;
    json[r'skipVerification'] = skipVerification;
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  RegistrationRequest copyWith(
      {bool? disableDomainBlock,
      bool? generateAuthenticationToken,
      UserRegistration? registration,
      bool? sendSetPasswordEmail,
      bool? skipRegistrationVerification,
      bool? skipVerification,
      User? user,
      EventInfo? eventInfo}) {
    return RegistrationRequest(
      disableDomainBlock: disableDomainBlock ?? this.disableDomainBlock,
      generateAuthenticationToken:
          generateAuthenticationToken ?? this.generateAuthenticationToken,
      registration: registration ?? this.registration,
      sendSetPasswordEmail: sendSetPasswordEmail ?? this.sendSetPasswordEmail,
      skipRegistrationVerification:
          skipRegistrationVerification ?? this.skipRegistrationVerification,
      skipVerification: skipVerification ?? this.skipVerification,
      user: user ?? this.user,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

/// Registration API request object.
class RegistrationResponse {
  final String? refreshToken;
  final UserRegistration? registration;
  final String? registrationVerificationId;
  final String? registrationVerificationOneTimeCode;
  final String? token;
  final ZonedDateTime? tokenExpirationInstant;
  final User? user;

  RegistrationResponse(
      {this.refreshToken,
      this.registration,
      this.registrationVerificationId,
      this.registrationVerificationOneTimeCode,
      this.token,
      this.tokenExpirationInstant,
      this.user});

  factory RegistrationResponse.fromJson(Map<String, Object?> json) {
    return RegistrationResponse(
      refreshToken: json[r'refreshToken'] as String?,
      registration: json[r'registration'] != null
          ? UserRegistration.fromJson(
              json[r'registration']! as Map<String, Object?>)
          : null,
      registrationVerificationId:
          json[r'registrationVerificationId'] as String?,
      registrationVerificationOneTimeCode:
          json[r'registrationVerificationOneTimeCode'] as String?,
      token: json[r'token'] as String?,
      tokenExpirationInstant:
          (json[r'tokenExpirationInstant'] as num?)?.toInt() as ZonedDateTime?,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var refreshToken = this.refreshToken;
    var registration = this.registration;
    var registrationVerificationId = this.registrationVerificationId;
    var registrationVerificationOneTimeCode =
        this.registrationVerificationOneTimeCode;
    var token = this.token;
    var tokenExpirationInstant = this.tokenExpirationInstant;
    var user = this.user;

    final json = <String, Object?>{};
    if (refreshToken != null) {
      json[r'refreshToken'] = refreshToken;
    }
    if (registration != null) {
      json[r'registration'] = registration.toJson();
    }
    if (registrationVerificationId != null) {
      json[r'registrationVerificationId'] = registrationVerificationId;
    }
    if (registrationVerificationOneTimeCode != null) {
      json[r'registrationVerificationOneTimeCode'] =
          registrationVerificationOneTimeCode;
    }
    if (token != null) {
      json[r'token'] = token;
    }
    if (tokenExpirationInstant != null) {
      json[r'tokenExpirationInstant'] = tokenExpirationInstant.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  RegistrationResponse copyWith(
      {String? refreshToken,
      UserRegistration? registration,
      String? registrationVerificationId,
      String? registrationVerificationOneTimeCode,
      String? token,
      ZonedDateTime? tokenExpirationInstant,
      User? user}) {
    return RegistrationResponse(
      refreshToken: refreshToken ?? this.refreshToken,
      registration: registration ?? this.registration,
      registrationVerificationId:
          registrationVerificationId ?? this.registrationVerificationId,
      registrationVerificationOneTimeCode:
          registrationVerificationOneTimeCode ??
              this.registrationVerificationOneTimeCode,
      token: token ?? this.token,
      tokenExpirationInstant:
          tokenExpirationInstant ?? this.tokenExpirationInstant,
      user: user ?? this.user,
    );
  }
}

class RegistrationUnverifiedOptions {
  final UnverifiedBehavior? behavior;

  RegistrationUnverifiedOptions({this.behavior});

  factory RegistrationUnverifiedOptions.fromJson(Map<String, Object?> json) {
    return RegistrationUnverifiedOptions(
      behavior: json[r'behavior'] != null
          ? UnverifiedBehavior.fromValue(json[r'behavior']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var behavior = this.behavior;

    final json = <String, Object?>{};
    if (behavior != null) {
      json[r'behavior'] = behavior.value;
    }
    return json;
  }

  RegistrationUnverifiedOptions copyWith({UnverifiedBehavior? behavior}) {
    return RegistrationUnverifiedOptions(
      behavior: behavior ?? this.behavior,
    );
  }
}

/// Reindex API request
class ReindexRequest {
  final String? index;

  ReindexRequest({this.index});

  factory ReindexRequest.fromJson(Map<String, Object?> json) {
    return ReindexRequest(
      index: json[r'index'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var index = this.index;

    final json = <String, Object?>{};
    if (index != null) {
      json[r'index'] = index;
    }
    return json;
  }

  ReindexRequest copyWith({String? index}) {
    return ReindexRequest(
      index: index ?? this.index,
    );
  }
}

class ReloadRequest {
  final List<String> names;

  ReloadRequest({List<String>? names}) : names = names ?? [];

  factory ReloadRequest.fromJson(Map<String, Object?> json) {
    return ReloadRequest(
      names: (json[r'names'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var names = this.names;

    final json = <String, Object?>{};
    json[r'names'] = names;
    return json;
  }

  ReloadRequest copyWith({List<String>? names}) {
    return ReloadRequest(
      names: names ?? this.names,
    );
  }
}

class RememberPreviousPasswords {
  final int? count;
  final bool enabled;

  RememberPreviousPasswords({this.count, bool? enabled})
      : enabled = enabled ?? false;

  factory RememberPreviousPasswords.fromJson(Map<String, Object?> json) {
    return RememberPreviousPasswords(
      count: (json[r'count'] as num?)?.toInt(),
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var count = this.count;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (count != null) {
      json[r'count'] = count;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  RememberPreviousPasswords copyWith({int? count, bool? enabled}) {
    return RememberPreviousPasswords(
      count: count ?? this.count,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Something that can be required and thus also optional. This currently
/// extends Enableable because anything that is  requiredoptional is almost
/// always enableable as well.
class Requirable {
  final bool required;
  final bool enabled;

  Requirable({bool? required, bool? enabled})
      : required = required ?? false,
        enabled = enabled ?? false;

  factory Requirable.fromJson(Map<String, Object?> json) {
    return Requirable(
      required: json[r'required'] as bool? ?? false,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var required = this.required;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    json[r'required'] = required;
    json[r'enabled'] = enabled;
    return json;
  }

  Requirable copyWith({bool? required, bool? enabled}) {
    return Requirable(
      required: required ?? this.required,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Interface describing the need for CORS configuration.
class RequiresCORSConfiguration {
  RequiresCORSConfiguration();

  factory RequiresCORSConfiguration.fromJson(Map<String, Object?> json) {
    return RequiresCORSConfiguration();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class SAMLv2ApplicationConfiguration {
  final String? buttonImageUrl;
  final String? buttonText;
  final Map<String, dynamic>? data;
  final bool createRegistration;

  SAMLv2ApplicationConfiguration(
      {this.buttonImageUrl,
      this.buttonText,
      this.data,
      bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory SAMLv2ApplicationConfiguration.fromJson(Map<String, Object?> json) {
    return SAMLv2ApplicationConfiguration(
      buttonImageUrl: json[r'buttonImageURL'] as String?,
      buttonText: json[r'buttonText'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var buttonImageUrl = this.buttonImageUrl;
    var buttonText = this.buttonText;
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (buttonImageUrl != null) {
      json[r'buttonImageURL'] = buttonImageUrl;
    }
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  SAMLv2ApplicationConfiguration copyWith(
      {String? buttonImageUrl,
      String? buttonText,
      Map<String, dynamic>? data,
      bool? createRegistration}) {
    return SAMLv2ApplicationConfiguration(
      buttonImageUrl: buttonImageUrl ?? this.buttonImageUrl,
      buttonText: buttonText ?? this.buttonText,
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

class SAMLv2AssertionConfiguration {
  final SAMLv2DestinationAssertionConfiguration? destination;

  SAMLv2AssertionConfiguration({this.destination});

  factory SAMLv2AssertionConfiguration.fromJson(Map<String, Object?> json) {
    return SAMLv2AssertionConfiguration(
      destination: json[r'destination'] != null
          ? SAMLv2DestinationAssertionConfiguration.fromJson(
              json[r'destination']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var destination = this.destination;

    final json = <String, Object?>{};
    if (destination != null) {
      json[r'destination'] = destination.toJson();
    }
    return json;
  }

  SAMLv2AssertionConfiguration copyWith(
      {SAMLv2DestinationAssertionConfiguration? destination}) {
    return SAMLv2AssertionConfiguration(
      destination: destination ?? this.destination,
    );
  }
}

class SAMLv2AssertionEncryptionConfiguration {
  final String? digestAlgorithm;
  final String? encryptionAlgorithm;
  final String? keyLocation;
  final String? keyTransportAlgorithm;
  final String? keyTransportEncryptionKeyId;
  final String? maskGenerationFunction;
  final bool enabled;

  SAMLv2AssertionEncryptionConfiguration(
      {this.digestAlgorithm,
      this.encryptionAlgorithm,
      this.keyLocation,
      this.keyTransportAlgorithm,
      this.keyTransportEncryptionKeyId,
      this.maskGenerationFunction,
      bool? enabled})
      : enabled = enabled ?? false;

  factory SAMLv2AssertionEncryptionConfiguration.fromJson(
      Map<String, Object?> json) {
    return SAMLv2AssertionEncryptionConfiguration(
      digestAlgorithm: json[r'digestAlgorithm'] as String?,
      encryptionAlgorithm: json[r'encryptionAlgorithm'] as String?,
      keyLocation: json[r'keyLocation'] as String?,
      keyTransportAlgorithm: json[r'keyTransportAlgorithm'] as String?,
      keyTransportEncryptionKeyId:
          json[r'keyTransportEncryptionKeyId'] as String?,
      maskGenerationFunction: json[r'maskGenerationFunction'] as String?,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var digestAlgorithm = this.digestAlgorithm;
    var encryptionAlgorithm = this.encryptionAlgorithm;
    var keyLocation = this.keyLocation;
    var keyTransportAlgorithm = this.keyTransportAlgorithm;
    var keyTransportEncryptionKeyId = this.keyTransportEncryptionKeyId;
    var maskGenerationFunction = this.maskGenerationFunction;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (digestAlgorithm != null) {
      json[r'digestAlgorithm'] = digestAlgorithm;
    }
    if (encryptionAlgorithm != null) {
      json[r'encryptionAlgorithm'] = encryptionAlgorithm;
    }
    if (keyLocation != null) {
      json[r'keyLocation'] = keyLocation;
    }
    if (keyTransportAlgorithm != null) {
      json[r'keyTransportAlgorithm'] = keyTransportAlgorithm;
    }
    if (keyTransportEncryptionKeyId != null) {
      json[r'keyTransportEncryptionKeyId'] = keyTransportEncryptionKeyId;
    }
    if (maskGenerationFunction != null) {
      json[r'maskGenerationFunction'] = maskGenerationFunction;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  SAMLv2AssertionEncryptionConfiguration copyWith(
      {String? digestAlgorithm,
      String? encryptionAlgorithm,
      String? keyLocation,
      String? keyTransportAlgorithm,
      String? keyTransportEncryptionKeyId,
      String? maskGenerationFunction,
      bool? enabled}) {
    return SAMLv2AssertionEncryptionConfiguration(
      digestAlgorithm: digestAlgorithm ?? this.digestAlgorithm,
      encryptionAlgorithm: encryptionAlgorithm ?? this.encryptionAlgorithm,
      keyLocation: keyLocation ?? this.keyLocation,
      keyTransportAlgorithm:
          keyTransportAlgorithm ?? this.keyTransportAlgorithm,
      keyTransportEncryptionKeyId:
          keyTransportEncryptionKeyId ?? this.keyTransportEncryptionKeyId,
      maskGenerationFunction:
          maskGenerationFunction ?? this.maskGenerationFunction,
      enabled: enabled ?? this.enabled,
    );
  }
}

class SAMLv2Configuration {
  final SAMLv2AssertionEncryptionConfiguration?
      assertionEncryptionConfiguration;
  final String? audience;
  final List<String> authorizedRedirectUrLs;
  final bool debug;
  final String? defaultVerificationKeyId;
  final SAMLv2IdPInitiatedLoginConfiguration? initiatedLogin;
  final String? issuer;
  final String? keyId;
  final LoginHintConfiguration? loginHintConfiguration;
  final SAMLv2Logout? logout;
  final String? logoutUrl;
  final bool requireSignedRequests;
  final CanonicalizationMethod? xmlSignatureC14nMethod;
  final XMLSignatureLocation? xmlSignatureLocation;
  final String? callbackUrl;
  final bool enabled;

  SAMLv2Configuration(
      {this.assertionEncryptionConfiguration,
      this.audience,
      List<String>? authorizedRedirectUrLs,
      bool? debug,
      this.defaultVerificationKeyId,
      this.initiatedLogin,
      this.issuer,
      this.keyId,
      this.loginHintConfiguration,
      this.logout,
      this.logoutUrl,
      bool? requireSignedRequests,
      this.xmlSignatureC14nMethod,
      this.xmlSignatureLocation,
      this.callbackUrl,
      bool? enabled})
      : authorizedRedirectUrLs = authorizedRedirectUrLs ?? [],
        debug = debug ?? false,
        requireSignedRequests = requireSignedRequests ?? false,
        enabled = enabled ?? false;

  factory SAMLv2Configuration.fromJson(Map<String, Object?> json) {
    return SAMLv2Configuration(
      assertionEncryptionConfiguration:
          json[r'assertionEncryptionConfiguration'] != null
              ? SAMLv2AssertionEncryptionConfiguration.fromJson(
                  json[r'assertionEncryptionConfiguration']!
                      as Map<String, Object?>)
              : null,
      audience: json[r'audience'] as String?,
      authorizedRedirectUrLs:
          (json[r'authorizedRedirectURLs'] as List<Object?>?)
                  ?.map((i) => i as String? ?? '')
                  .toList() ??
              [],
      debug: json[r'debug'] as bool? ?? false,
      defaultVerificationKeyId: json[r'defaultVerificationKeyId'] as String?,
      initiatedLogin: json[r'initiatedLogin'] != null
          ? SAMLv2IdPInitiatedLoginConfiguration.fromJson(
              json[r'initiatedLogin']! as Map<String, Object?>)
          : null,
      issuer: json[r'issuer'] as String?,
      keyId: json[r'keyId'] as String?,
      loginHintConfiguration: json[r'loginHintConfiguration'] != null
          ? LoginHintConfiguration.fromJson(
              json[r'loginHintConfiguration']! as Map<String, Object?>)
          : null,
      logout: json[r'logout'] != null
          ? SAMLv2Logout.fromJson(json[r'logout']! as Map<String, Object?>)
          : null,
      logoutUrl: json[r'logoutURL'] as String?,
      requireSignedRequests: json[r'requireSignedRequests'] as bool? ?? false,
      xmlSignatureC14nMethod: json[r'xmlSignatureC14nMethod'] != null
          ? CanonicalizationMethod.fromValue(
              json[r'xmlSignatureC14nMethod']! as String)
          : null,
      xmlSignatureLocation: json[r'xmlSignatureLocation'] != null
          ? XMLSignatureLocation.fromValue(
              json[r'xmlSignatureLocation']! as String)
          : null,
      callbackUrl: json[r'callbackURL'] as String?,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var assertionEncryptionConfiguration =
        this.assertionEncryptionConfiguration;
    var audience = this.audience;
    var authorizedRedirectUrLs = this.authorizedRedirectUrLs;
    var debug = this.debug;
    var defaultVerificationKeyId = this.defaultVerificationKeyId;
    var initiatedLogin = this.initiatedLogin;
    var issuer = this.issuer;
    var keyId = this.keyId;
    var loginHintConfiguration = this.loginHintConfiguration;
    var logout = this.logout;
    var logoutUrl = this.logoutUrl;
    var requireSignedRequests = this.requireSignedRequests;
    var xmlSignatureC14nMethod = this.xmlSignatureC14nMethod;
    var xmlSignatureLocation = this.xmlSignatureLocation;
    var callbackUrl = this.callbackUrl;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (assertionEncryptionConfiguration != null) {
      json[r'assertionEncryptionConfiguration'] =
          assertionEncryptionConfiguration.toJson();
    }
    if (audience != null) {
      json[r'audience'] = audience;
    }
    json[r'authorizedRedirectURLs'] = authorizedRedirectUrLs;
    json[r'debug'] = debug;
    if (defaultVerificationKeyId != null) {
      json[r'defaultVerificationKeyId'] = defaultVerificationKeyId;
    }
    if (initiatedLogin != null) {
      json[r'initiatedLogin'] = initiatedLogin.toJson();
    }
    if (issuer != null) {
      json[r'issuer'] = issuer;
    }
    if (keyId != null) {
      json[r'keyId'] = keyId;
    }
    if (loginHintConfiguration != null) {
      json[r'loginHintConfiguration'] = loginHintConfiguration.toJson();
    }
    if (logout != null) {
      json[r'logout'] = logout.toJson();
    }
    if (logoutUrl != null) {
      json[r'logoutURL'] = logoutUrl;
    }
    json[r'requireSignedRequests'] = requireSignedRequests;
    if (xmlSignatureC14nMethod != null) {
      json[r'xmlSignatureC14nMethod'] = xmlSignatureC14nMethod.value;
    }
    if (xmlSignatureLocation != null) {
      json[r'xmlSignatureLocation'] = xmlSignatureLocation.value;
    }
    if (callbackUrl != null) {
      json[r'callbackURL'] = callbackUrl;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  SAMLv2Configuration copyWith(
      {SAMLv2AssertionEncryptionConfiguration? assertionEncryptionConfiguration,
      String? audience,
      List<String>? authorizedRedirectUrLs,
      bool? debug,
      String? defaultVerificationKeyId,
      SAMLv2IdPInitiatedLoginConfiguration? initiatedLogin,
      String? issuer,
      String? keyId,
      LoginHintConfiguration? loginHintConfiguration,
      SAMLv2Logout? logout,
      String? logoutUrl,
      bool? requireSignedRequests,
      CanonicalizationMethod? xmlSignatureC14nMethod,
      XMLSignatureLocation? xmlSignatureLocation,
      String? callbackUrl,
      bool? enabled}) {
    return SAMLv2Configuration(
      assertionEncryptionConfiguration: assertionEncryptionConfiguration ??
          this.assertionEncryptionConfiguration,
      audience: audience ?? this.audience,
      authorizedRedirectUrLs:
          authorizedRedirectUrLs ?? this.authorizedRedirectUrLs,
      debug: debug ?? this.debug,
      defaultVerificationKeyId:
          defaultVerificationKeyId ?? this.defaultVerificationKeyId,
      initiatedLogin: initiatedLogin ?? this.initiatedLogin,
      issuer: issuer ?? this.issuer,
      keyId: keyId ?? this.keyId,
      loginHintConfiguration:
          loginHintConfiguration ?? this.loginHintConfiguration,
      logout: logout ?? this.logout,
      logoutUrl: logoutUrl ?? this.logoutUrl,
      requireSignedRequests:
          requireSignedRequests ?? this.requireSignedRequests,
      xmlSignatureC14nMethod:
          xmlSignatureC14nMethod ?? this.xmlSignatureC14nMethod,
      xmlSignatureLocation: xmlSignatureLocation ?? this.xmlSignatureLocation,
      callbackUrl: callbackUrl ?? this.callbackUrl,
      enabled: enabled ?? this.enabled,
    );
  }
}

class SAMLv2DestinationAssertionConfiguration {
  final List<String> alternates;
  final SAMLv2DestinationAssertionPolicy? policy;

  SAMLv2DestinationAssertionConfiguration(
      {List<String>? alternates, this.policy})
      : alternates = alternates ?? [];

  factory SAMLv2DestinationAssertionConfiguration.fromJson(
      Map<String, Object?> json) {
    return SAMLv2DestinationAssertionConfiguration(
      alternates: (json[r'alternates'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      policy: json[r'policy'] != null
          ? SAMLv2DestinationAssertionPolicy.fromValue(
              json[r'policy']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var alternates = this.alternates;
    var policy = this.policy;

    final json = <String, Object?>{};
    json[r'alternates'] = alternates;
    if (policy != null) {
      json[r'policy'] = policy.value;
    }
    return json;
  }

  SAMLv2DestinationAssertionConfiguration copyWith(
      {List<String>? alternates, SAMLv2DestinationAssertionPolicy? policy}) {
    return SAMLv2DestinationAssertionConfiguration(
      alternates: alternates ?? this.alternates,
      policy: policy ?? this.policy,
    );
  }
}

class SAMLv2IdPInitiatedApplicationConfiguration {
  final Map<String, dynamic>? data;
  final bool createRegistration;

  SAMLv2IdPInitiatedApplicationConfiguration(
      {this.data, bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory SAMLv2IdPInitiatedApplicationConfiguration.fromJson(
      Map<String, Object?> json) {
    return SAMLv2IdPInitiatedApplicationConfiguration(
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  SAMLv2IdPInitiatedApplicationConfiguration copyWith(
      {Map<String, dynamic>? data, bool? createRegistration}) {
    return SAMLv2IdPInitiatedApplicationConfiguration(
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

/// SAML v2 IdP Initiated identity provider configuration.
class SAMLv2IdPInitiatedIdentityProvider {
  final String? issuer;
  final String? emailClaim;
  final String? keyId;
  final String? uniqueIdClaim;
  final bool useNameIdForEmail;
  final String? usernameClaim;

  SAMLv2IdPInitiatedIdentityProvider(
      {this.issuer,
      this.emailClaim,
      this.keyId,
      this.uniqueIdClaim,
      bool? useNameIdForEmail,
      this.usernameClaim})
      : useNameIdForEmail = useNameIdForEmail ?? false;

  factory SAMLv2IdPInitiatedIdentityProvider.fromJson(
      Map<String, Object?> json) {
    return SAMLv2IdPInitiatedIdentityProvider(
      issuer: json[r'issuer'] as String?,
      emailClaim: json[r'emailClaim'] as String?,
      keyId: json[r'keyId'] as String?,
      uniqueIdClaim: json[r'uniqueIdClaim'] as String?,
      useNameIdForEmail: json[r'useNameIdForEmail'] as bool? ?? false,
      usernameClaim: json[r'usernameClaim'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var issuer = this.issuer;
    var emailClaim = this.emailClaim;
    var keyId = this.keyId;
    var uniqueIdClaim = this.uniqueIdClaim;
    var useNameIdForEmail = this.useNameIdForEmail;
    var usernameClaim = this.usernameClaim;

    final json = <String, Object?>{};
    if (issuer != null) {
      json[r'issuer'] = issuer;
    }
    if (emailClaim != null) {
      json[r'emailClaim'] = emailClaim;
    }
    if (keyId != null) {
      json[r'keyId'] = keyId;
    }
    if (uniqueIdClaim != null) {
      json[r'uniqueIdClaim'] = uniqueIdClaim;
    }
    json[r'useNameIdForEmail'] = useNameIdForEmail;
    if (usernameClaim != null) {
      json[r'usernameClaim'] = usernameClaim;
    }
    return json;
  }

  SAMLv2IdPInitiatedIdentityProvider copyWith(
      {String? issuer,
      String? emailClaim,
      String? keyId,
      String? uniqueIdClaim,
      bool? useNameIdForEmail,
      String? usernameClaim}) {
    return SAMLv2IdPInitiatedIdentityProvider(
      issuer: issuer ?? this.issuer,
      emailClaim: emailClaim ?? this.emailClaim,
      keyId: keyId ?? this.keyId,
      uniqueIdClaim: uniqueIdClaim ?? this.uniqueIdClaim,
      useNameIdForEmail: useNameIdForEmail ?? this.useNameIdForEmail,
      usernameClaim: usernameClaim ?? this.usernameClaim,
    );
  }
}

/// IdP Initiated login configuration
class SAMLv2IdPInitiatedLoginConfiguration {
  final String? nameIdFormat;
  final bool enabled;

  SAMLv2IdPInitiatedLoginConfiguration({this.nameIdFormat, bool? enabled})
      : enabled = enabled ?? false;

  factory SAMLv2IdPInitiatedLoginConfiguration.fromJson(
      Map<String, Object?> json) {
    return SAMLv2IdPInitiatedLoginConfiguration(
      nameIdFormat: json[r'nameIdFormat'] as String?,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var nameIdFormat = this.nameIdFormat;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (nameIdFormat != null) {
      json[r'nameIdFormat'] = nameIdFormat;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  SAMLv2IdPInitiatedLoginConfiguration copyWith(
      {String? nameIdFormat, bool? enabled}) {
    return SAMLv2IdPInitiatedLoginConfiguration(
      nameIdFormat: nameIdFormat ?? this.nameIdFormat,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// SAML v2 identity provider configuration.
class SAMLv2IdentityProvider {
  final List<dynamic> domains;
  final SAMLv2AssertionConfiguration? assertionConfiguration;
  final String? buttonImageUrl;
  final String? buttonText;
  final String? idpEndpoint;
  final SAMLv2IdpInitiatedConfiguration? idpInitiatedConfiguration;
  final String? issuer;
  final LoginHintConfiguration? loginHintConfiguration;
  final String? nameIdFormat;
  final bool postRequest;
  final String? requestSigningKeyId;
  final bool signRequest;
  final CanonicalizationMethod? xmlSignatureC14nMethod;
  final String? emailClaim;
  final String? keyId;
  final String? uniqueIdClaim;
  final bool useNameIdForEmail;
  final String? usernameClaim;

  SAMLv2IdentityProvider(
      {List<dynamic>? domains,
      this.assertionConfiguration,
      this.buttonImageUrl,
      this.buttonText,
      this.idpEndpoint,
      this.idpInitiatedConfiguration,
      this.issuer,
      this.loginHintConfiguration,
      this.nameIdFormat,
      bool? postRequest,
      this.requestSigningKeyId,
      bool? signRequest,
      this.xmlSignatureC14nMethod,
      this.emailClaim,
      this.keyId,
      this.uniqueIdClaim,
      bool? useNameIdForEmail,
      this.usernameClaim})
      : domains = domains ?? [],
        postRequest = postRequest ?? false,
        signRequest = signRequest ?? false,
        useNameIdForEmail = useNameIdForEmail ?? false;

  factory SAMLv2IdentityProvider.fromJson(Map<String, Object?> json) {
    return SAMLv2IdentityProvider(
      domains:
          (json[r'domains'] as List<Object?>?)?.map((i) => i).toList() ?? [],
      assertionConfiguration: json[r'assertionConfiguration'] != null
          ? SAMLv2AssertionConfiguration.fromJson(
              json[r'assertionConfiguration']! as Map<String, Object?>)
          : null,
      buttonImageUrl: json[r'buttonImageURL'] as String?,
      buttonText: json[r'buttonText'] as String?,
      idpEndpoint: json[r'idpEndpoint'] as String?,
      idpInitiatedConfiguration: json[r'idpInitiatedConfiguration'] != null
          ? SAMLv2IdpInitiatedConfiguration.fromJson(
              json[r'idpInitiatedConfiguration']! as Map<String, Object?>)
          : null,
      issuer: json[r'issuer'] as String?,
      loginHintConfiguration: json[r'loginHintConfiguration'] != null
          ? LoginHintConfiguration.fromJson(
              json[r'loginHintConfiguration']! as Map<String, Object?>)
          : null,
      nameIdFormat: json[r'nameIdFormat'] as String?,
      postRequest: json[r'postRequest'] as bool? ?? false,
      requestSigningKeyId: json[r'requestSigningKeyId'] as String?,
      signRequest: json[r'signRequest'] as bool? ?? false,
      xmlSignatureC14nMethod: json[r'xmlSignatureC14nMethod'] != null
          ? CanonicalizationMethod.fromValue(
              json[r'xmlSignatureC14nMethod']! as String)
          : null,
      emailClaim: json[r'emailClaim'] as String?,
      keyId: json[r'keyId'] as String?,
      uniqueIdClaim: json[r'uniqueIdClaim'] as String?,
      useNameIdForEmail: json[r'useNameIdForEmail'] as bool? ?? false,
      usernameClaim: json[r'usernameClaim'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var domains = this.domains;
    var assertionConfiguration = this.assertionConfiguration;
    var buttonImageUrl = this.buttonImageUrl;
    var buttonText = this.buttonText;
    var idpEndpoint = this.idpEndpoint;
    var idpInitiatedConfiguration = this.idpInitiatedConfiguration;
    var issuer = this.issuer;
    var loginHintConfiguration = this.loginHintConfiguration;
    var nameIdFormat = this.nameIdFormat;
    var postRequest = this.postRequest;
    var requestSigningKeyId = this.requestSigningKeyId;
    var signRequest = this.signRequest;
    var xmlSignatureC14nMethod = this.xmlSignatureC14nMethod;
    var emailClaim = this.emailClaim;
    var keyId = this.keyId;
    var uniqueIdClaim = this.uniqueIdClaim;
    var useNameIdForEmail = this.useNameIdForEmail;
    var usernameClaim = this.usernameClaim;

    final json = <String, Object?>{};
    json[r'domains'] = domains;
    if (assertionConfiguration != null) {
      json[r'assertionConfiguration'] = assertionConfiguration.toJson();
    }
    if (buttonImageUrl != null) {
      json[r'buttonImageURL'] = buttonImageUrl;
    }
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (idpEndpoint != null) {
      json[r'idpEndpoint'] = idpEndpoint;
    }
    if (idpInitiatedConfiguration != null) {
      json[r'idpInitiatedConfiguration'] = idpInitiatedConfiguration.toJson();
    }
    if (issuer != null) {
      json[r'issuer'] = issuer;
    }
    if (loginHintConfiguration != null) {
      json[r'loginHintConfiguration'] = loginHintConfiguration.toJson();
    }
    if (nameIdFormat != null) {
      json[r'nameIdFormat'] = nameIdFormat;
    }
    json[r'postRequest'] = postRequest;
    if (requestSigningKeyId != null) {
      json[r'requestSigningKeyId'] = requestSigningKeyId;
    }
    json[r'signRequest'] = signRequest;
    if (xmlSignatureC14nMethod != null) {
      json[r'xmlSignatureC14nMethod'] = xmlSignatureC14nMethod.value;
    }
    if (emailClaim != null) {
      json[r'emailClaim'] = emailClaim;
    }
    if (keyId != null) {
      json[r'keyId'] = keyId;
    }
    if (uniqueIdClaim != null) {
      json[r'uniqueIdClaim'] = uniqueIdClaim;
    }
    json[r'useNameIdForEmail'] = useNameIdForEmail;
    if (usernameClaim != null) {
      json[r'usernameClaim'] = usernameClaim;
    }
    return json;
  }

  SAMLv2IdentityProvider copyWith(
      {List<dynamic>? domains,
      SAMLv2AssertionConfiguration? assertionConfiguration,
      String? buttonImageUrl,
      String? buttonText,
      String? idpEndpoint,
      SAMLv2IdpInitiatedConfiguration? idpInitiatedConfiguration,
      String? issuer,
      LoginHintConfiguration? loginHintConfiguration,
      String? nameIdFormat,
      bool? postRequest,
      String? requestSigningKeyId,
      bool? signRequest,
      CanonicalizationMethod? xmlSignatureC14nMethod,
      String? emailClaim,
      String? keyId,
      String? uniqueIdClaim,
      bool? useNameIdForEmail,
      String? usernameClaim}) {
    return SAMLv2IdentityProvider(
      domains: domains ?? this.domains,
      assertionConfiguration:
          assertionConfiguration ?? this.assertionConfiguration,
      buttonImageUrl: buttonImageUrl ?? this.buttonImageUrl,
      buttonText: buttonText ?? this.buttonText,
      idpEndpoint: idpEndpoint ?? this.idpEndpoint,
      idpInitiatedConfiguration:
          idpInitiatedConfiguration ?? this.idpInitiatedConfiguration,
      issuer: issuer ?? this.issuer,
      loginHintConfiguration:
          loginHintConfiguration ?? this.loginHintConfiguration,
      nameIdFormat: nameIdFormat ?? this.nameIdFormat,
      postRequest: postRequest ?? this.postRequest,
      requestSigningKeyId: requestSigningKeyId ?? this.requestSigningKeyId,
      signRequest: signRequest ?? this.signRequest,
      xmlSignatureC14nMethod:
          xmlSignatureC14nMethod ?? this.xmlSignatureC14nMethod,
      emailClaim: emailClaim ?? this.emailClaim,
      keyId: keyId ?? this.keyId,
      uniqueIdClaim: uniqueIdClaim ?? this.uniqueIdClaim,
      useNameIdForEmail: useNameIdForEmail ?? this.useNameIdForEmail,
      usernameClaim: usernameClaim ?? this.usernameClaim,
    );
  }
}

/// Config for regular SAML IDP configurations that support IdP initiated
/// requests
class SAMLv2IdpInitiatedConfiguration {
  final String? issuer;
  final bool enabled;

  SAMLv2IdpInitiatedConfiguration({this.issuer, bool? enabled})
      : enabled = enabled ?? false;

  factory SAMLv2IdpInitiatedConfiguration.fromJson(Map<String, Object?> json) {
    return SAMLv2IdpInitiatedConfiguration(
      issuer: json[r'issuer'] as String?,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var issuer = this.issuer;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (issuer != null) {
      json[r'issuer'] = issuer;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  SAMLv2IdpInitiatedConfiguration copyWith({String? issuer, bool? enabled}) {
    return SAMLv2IdpInitiatedConfiguration(
      issuer: issuer ?? this.issuer,
      enabled: enabled ?? this.enabled,
    );
  }
}

class SAMLv2Logout {
  final SAMLLogoutBehavior? behavior;
  final String? defaultVerificationKeyId;
  final String? keyId;
  final bool requireSignedRequests;
  final SAMLv2SingleLogout? singleLogout;
  final CanonicalizationMethod? xmlSignatureC14nMethod;

  SAMLv2Logout(
      {this.behavior,
      this.defaultVerificationKeyId,
      this.keyId,
      bool? requireSignedRequests,
      this.singleLogout,
      this.xmlSignatureC14nMethod})
      : requireSignedRequests = requireSignedRequests ?? false;

  factory SAMLv2Logout.fromJson(Map<String, Object?> json) {
    return SAMLv2Logout(
      behavior: json[r'behavior'] != null
          ? SAMLLogoutBehavior.fromValue(json[r'behavior']! as String)
          : null,
      defaultVerificationKeyId: json[r'defaultVerificationKeyId'] as String?,
      keyId: json[r'keyId'] as String?,
      requireSignedRequests: json[r'requireSignedRequests'] as bool? ?? false,
      singleLogout: json[r'singleLogout'] != null
          ? SAMLv2SingleLogout.fromJson(
              json[r'singleLogout']! as Map<String, Object?>)
          : null,
      xmlSignatureC14nMethod: json[r'xmlSignatureC14nMethod'] != null
          ? CanonicalizationMethod.fromValue(
              json[r'xmlSignatureC14nMethod']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var behavior = this.behavior;
    var defaultVerificationKeyId = this.defaultVerificationKeyId;
    var keyId = this.keyId;
    var requireSignedRequests = this.requireSignedRequests;
    var singleLogout = this.singleLogout;
    var xmlSignatureC14nMethod = this.xmlSignatureC14nMethod;

    final json = <String, Object?>{};
    if (behavior != null) {
      json[r'behavior'] = behavior.value;
    }
    if (defaultVerificationKeyId != null) {
      json[r'defaultVerificationKeyId'] = defaultVerificationKeyId;
    }
    if (keyId != null) {
      json[r'keyId'] = keyId;
    }
    json[r'requireSignedRequests'] = requireSignedRequests;
    if (singleLogout != null) {
      json[r'singleLogout'] = singleLogout.toJson();
    }
    if (xmlSignatureC14nMethod != null) {
      json[r'xmlSignatureC14nMethod'] = xmlSignatureC14nMethod.value;
    }
    return json;
  }

  SAMLv2Logout copyWith(
      {SAMLLogoutBehavior? behavior,
      String? defaultVerificationKeyId,
      String? keyId,
      bool? requireSignedRequests,
      SAMLv2SingleLogout? singleLogout,
      CanonicalizationMethod? xmlSignatureC14nMethod}) {
    return SAMLv2Logout(
      behavior: behavior ?? this.behavior,
      defaultVerificationKeyId:
          defaultVerificationKeyId ?? this.defaultVerificationKeyId,
      keyId: keyId ?? this.keyId,
      requireSignedRequests:
          requireSignedRequests ?? this.requireSignedRequests,
      singleLogout: singleLogout ?? this.singleLogout,
      xmlSignatureC14nMethod:
          xmlSignatureC14nMethod ?? this.xmlSignatureC14nMethod,
    );
  }
}

class SAMLv2SingleLogout {
  final String? keyId;
  final String? url;
  final CanonicalizationMethod? xmlSignatureC14nMethod;
  final bool enabled;

  SAMLv2SingleLogout(
      {this.keyId, this.url, this.xmlSignatureC14nMethod, bool? enabled})
      : enabled = enabled ?? false;

  factory SAMLv2SingleLogout.fromJson(Map<String, Object?> json) {
    return SAMLv2SingleLogout(
      keyId: json[r'keyId'] as String?,
      url: json[r'url'] as String?,
      xmlSignatureC14nMethod: json[r'xmlSignatureC14nMethod'] != null
          ? CanonicalizationMethod.fromValue(
              json[r'xmlSignatureC14nMethod']! as String)
          : null,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var keyId = this.keyId;
    var url = this.url;
    var xmlSignatureC14nMethod = this.xmlSignatureC14nMethod;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (keyId != null) {
      json[r'keyId'] = keyId;
    }
    if (url != null) {
      json[r'url'] = url;
    }
    if (xmlSignatureC14nMethod != null) {
      json[r'xmlSignatureC14nMethod'] = xmlSignatureC14nMethod.value;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  SAMLv2SingleLogout copyWith(
      {String? keyId,
      String? url,
      CanonicalizationMethod? xmlSignatureC14nMethod,
      bool? enabled}) {
    return SAMLv2SingleLogout(
      keyId: keyId ?? this.keyId,
      url: url ?? this.url,
      xmlSignatureC14nMethod:
          xmlSignatureC14nMethod ?? this.xmlSignatureC14nMethod,
      enabled: enabled ?? this.enabled,
    );
  }
}

class SMSMessage {
  final String? phoneNumber;
  final String? textMessage;

  SMSMessage({this.phoneNumber, this.textMessage});

  factory SMSMessage.fromJson(Map<String, Object?> json) {
    return SMSMessage(
      phoneNumber: json[r'phoneNumber'] as String?,
      textMessage: json[r'textMessage'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var phoneNumber = this.phoneNumber;
    var textMessage = this.textMessage;

    final json = <String, Object?>{};
    if (phoneNumber != null) {
      json[r'phoneNumber'] = phoneNumber;
    }
    if (textMessage != null) {
      json[r'textMessage'] = textMessage;
    }
    return json;
  }

  SMSMessage copyWith({String? phoneNumber, String? textMessage}) {
    return SMSMessage(
      phoneNumber: phoneNumber ?? this.phoneNumber,
      textMessage: textMessage ?? this.textMessage,
    );
  }
}

class SMSMessageTemplate {
  final String? defaultTemplate;
  final LocalizedStrings? localizedTemplates;

  SMSMessageTemplate({this.defaultTemplate, this.localizedTemplates});

  factory SMSMessageTemplate.fromJson(Map<String, Object?> json) {
    return SMSMessageTemplate(
      defaultTemplate: json[r'defaultTemplate'] as String?,
      localizedTemplates: json[r'localizedTemplates'] != null
          ? LocalizedStrings.fromJson(
              json[r'localizedTemplates']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var defaultTemplate = this.defaultTemplate;
    var localizedTemplates = this.localizedTemplates;

    final json = <String, Object?>{};
    if (defaultTemplate != null) {
      json[r'defaultTemplate'] = defaultTemplate;
    }
    if (localizedTemplates != null) {
      json[r'localizedTemplates'] = localizedTemplates.toJson();
    }
    return json;
  }

  SMSMessageTemplate copyWith(
      {String? defaultTemplate, LocalizedStrings? localizedTemplates}) {
    return SMSMessageTemplate(
      defaultTemplate: defaultTemplate ?? this.defaultTemplate,
      localizedTemplates: localizedTemplates ?? this.localizedTemplates,
    );
  }
}

/// Search API request.
class SearchRequest {
  final UserSearchCriteria? search;
  final List<String> expand;

  SearchRequest({this.search, List<String>? expand}) : expand = expand ?? [];

  factory SearchRequest.fromJson(Map<String, Object?> json) {
    return SearchRequest(
      search: json[r'search'] != null
          ? UserSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
      expand: (json[r'expand'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;
    var expand = this.expand;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    json[r'expand'] = expand;
    return json;
  }

  SearchRequest copyWith({UserSearchCriteria? search, List<String>? expand}) {
    return SearchRequest(
      search: search ?? this.search,
      expand: expand ?? this.expand,
    );
  }
}

/// Search API response.
class SearchResponse {
  final int? total;
  final String? nextResults;
  final List<User> users;
  final List<String> expandable;

  SearchResponse(
      {this.total,
      this.nextResults,
      List<User>? users,
      List<String>? expandable})
      : users = users ?? [],
        expandable = expandable ?? [];

  factory SearchResponse.fromJson(Map<String, Object?> json) {
    return SearchResponse(
      total: (json[r'total'] as num?)?.toInt(),
      nextResults: json[r'nextResults'] as String?,
      users: (json[r'users'] as List<Object?>?)
              ?.map(
                  (i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      expandable: (json[r'expandable'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var total = this.total;
    var nextResults = this.nextResults;
    var users = this.users;
    var expandable = this.expandable;

    final json = <String, Object?>{};
    if (total != null) {
      json[r'total'] = total;
    }
    if (nextResults != null) {
      json[r'nextResults'] = nextResults;
    }
    json[r'users'] = users.map((i) => i.toJson()).toList();
    json[r'expandable'] = expandable;
    return json;
  }

  SearchResponse copyWith(
      {int? total,
      String? nextResults,
      List<User>? users,
      List<String>? expandable}) {
    return SearchResponse(
      total: total ?? this.total,
      nextResults: nextResults ?? this.nextResults,
      users: users ?? this.users,
      expandable: expandable ?? this.expandable,
    );
  }
}

/// Search results.
class SearchResults {
  final String? nextResults;
  final List<Map<String, dynamic>> results;
  final int? total;
  final bool totalEqualToActual;

  SearchResults(
      {this.nextResults,
      List<Map<String, dynamic>>? results,
      this.total,
      bool? totalEqualToActual})
      : results = results ?? [],
        totalEqualToActual = totalEqualToActual ?? false;

  factory SearchResults.fromJson(Map<String, Object?> json) {
    return SearchResults(
      nextResults: json[r'nextResults'] as String?,
      results: (json[r'results'] as List<Object?>?)
              ?.map((i) => i as Map<String, Object?>? ?? {})
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
      totalEqualToActual: json[r'totalEqualToActual'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var nextResults = this.nextResults;
    var results = this.results;
    var total = this.total;
    var totalEqualToActual = this.totalEqualToActual;

    final json = <String, Object?>{};
    if (nextResults != null) {
      json[r'nextResults'] = nextResults;
    }
    json[r'results'] = results;
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'totalEqualToActual'] = totalEqualToActual;
    return json;
  }

  SearchResults copyWith(
      {String? nextResults,
      List<Map<String, dynamic>>? results,
      int? total,
      bool? totalEqualToActual}) {
    return SearchResults(
      nextResults: nextResults ?? this.nextResults,
      results: results ?? this.results,
      total: total ?? this.total,
      totalEqualToActual: totalEqualToActual ?? this.totalEqualToActual,
    );
  }
}

class SecretResponse {
  final String? secret;
  final String? secretBase32Encoded;

  SecretResponse({this.secret, this.secretBase32Encoded});

  factory SecretResponse.fromJson(Map<String, Object?> json) {
    return SecretResponse(
      secret: json[r'secret'] as String?,
      secretBase32Encoded: json[r'secretBase32Encoded'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var secret = this.secret;
    var secretBase32Encoded = this.secretBase32Encoded;

    final json = <String, Object?>{};
    if (secret != null) {
      json[r'secret'] = secret;
    }
    if (secretBase32Encoded != null) {
      json[r'secretBase32Encoded'] = secretBase32Encoded;
    }
    return json;
  }

  SecretResponse copyWith({String? secret, String? secretBase32Encoded}) {
    return SecretResponse(
      secret: secret ?? this.secret,
      secretBase32Encoded: secretBase32Encoded ?? this.secretBase32Encoded,
    );
  }
}

class SecureGeneratorConfiguration {
  final int? length;
  final SecureGeneratorType? type;

  SecureGeneratorConfiguration({this.length, this.type});

  factory SecureGeneratorConfiguration.fromJson(Map<String, Object?> json) {
    return SecureGeneratorConfiguration(
      length: (json[r'length'] as num?)?.toInt(),
      type: json[r'type'] != null
          ? SecureGeneratorType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var length = this.length;
    var type = this.type;

    final json = <String, Object?>{};
    if (length != null) {
      json[r'length'] = length;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  SecureGeneratorConfiguration copyWith(
      {int? length, SecureGeneratorType? type}) {
    return SecureGeneratorConfiguration(
      length: length ?? this.length,
      type: type ?? this.type,
    );
  }
}

class SecureIdentity {
  final ZonedDateTime? breachedPasswordLastCheckedInstant;
  final BreachedPasswordStatus? breachedPasswordStatus;
  final String? connectorId;
  final String? encryptionScheme;
  final int? factor;
  final String? id;
  final ZonedDateTime? lastLoginInstant;
  final String? password;
  final ChangePasswordReason? passwordChangeReason;
  final bool passwordChangeRequired;
  final ZonedDateTime? passwordLastUpdateInstant;
  final String? salt;
  final String? uniqueUsername;
  final String? username;
  final ContentStatus? usernameStatus;
  final bool verified;
  final ZonedDateTime? verifiedInstant;

  SecureIdentity(
      {this.breachedPasswordLastCheckedInstant,
      this.breachedPasswordStatus,
      this.connectorId,
      this.encryptionScheme,
      this.factor,
      this.id,
      this.lastLoginInstant,
      this.password,
      this.passwordChangeReason,
      bool? passwordChangeRequired,
      this.passwordLastUpdateInstant,
      this.salt,
      this.uniqueUsername,
      this.username,
      this.usernameStatus,
      bool? verified,
      this.verifiedInstant})
      : passwordChangeRequired = passwordChangeRequired ?? false,
        verified = verified ?? false;

  factory SecureIdentity.fromJson(Map<String, Object?> json) {
    return SecureIdentity(
      breachedPasswordLastCheckedInstant:
          (json[r'breachedPasswordLastCheckedInstant'] as num?)?.toInt()
              as ZonedDateTime?,
      breachedPasswordStatus: json[r'breachedPasswordStatus'] != null
          ? BreachedPasswordStatus.fromValue(
              json[r'breachedPasswordStatus']! as String)
          : null,
      connectorId: json[r'connectorId'] as String?,
      encryptionScheme: json[r'encryptionScheme'] as String?,
      factor: (json[r'factor'] as num?)?.toInt(),
      id: json[r'id'] as String?,
      lastLoginInstant:
          (json[r'lastLoginInstant'] as num?)?.toInt() as ZonedDateTime?,
      password: json[r'password'] as String?,
      passwordChangeReason: json[r'passwordChangeReason'] != null
          ? ChangePasswordReason.fromValue(
              json[r'passwordChangeReason']! as String)
          : null,
      passwordChangeRequired: json[r'passwordChangeRequired'] as bool? ?? false,
      passwordLastUpdateInstant: (json[r'passwordLastUpdateInstant'] as num?)
          ?.toInt() as ZonedDateTime?,
      salt: json[r'salt'] as String?,
      uniqueUsername: json[r'uniqueUsername'] as String?,
      username: json[r'username'] as String?,
      usernameStatus: json[r'usernameStatus'] != null
          ? ContentStatus.fromValue(json[r'usernameStatus']! as String)
          : null,
      verified: json[r'verified'] as bool? ?? false,
      verifiedInstant:
          (json[r'verifiedInstant'] as num?)?.toInt() as ZonedDateTime?,
    );
  }

  Map<String, Object?> toJson() {
    var breachedPasswordLastCheckedInstant =
        this.breachedPasswordLastCheckedInstant;
    var breachedPasswordStatus = this.breachedPasswordStatus;
    var connectorId = this.connectorId;
    var encryptionScheme = this.encryptionScheme;
    var factor = this.factor;
    var id = this.id;
    var lastLoginInstant = this.lastLoginInstant;
    var password = this.password;
    var passwordChangeReason = this.passwordChangeReason;
    var passwordChangeRequired = this.passwordChangeRequired;
    var passwordLastUpdateInstant = this.passwordLastUpdateInstant;
    var salt = this.salt;
    var uniqueUsername = this.uniqueUsername;
    var username = this.username;
    var usernameStatus = this.usernameStatus;
    var verified = this.verified;
    var verifiedInstant = this.verifiedInstant;

    final json = <String, Object?>{};
    if (breachedPasswordLastCheckedInstant != null) {
      json[r'breachedPasswordLastCheckedInstant'] =
          breachedPasswordLastCheckedInstant.toJson();
    }
    if (breachedPasswordStatus != null) {
      json[r'breachedPasswordStatus'] = breachedPasswordStatus.value;
    }
    if (connectorId != null) {
      json[r'connectorId'] = connectorId;
    }
    if (encryptionScheme != null) {
      json[r'encryptionScheme'] = encryptionScheme;
    }
    if (factor != null) {
      json[r'factor'] = factor;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (lastLoginInstant != null) {
      json[r'lastLoginInstant'] = lastLoginInstant.toJson();
    }
    if (password != null) {
      json[r'password'] = password;
    }
    if (passwordChangeReason != null) {
      json[r'passwordChangeReason'] = passwordChangeReason.value;
    }
    json[r'passwordChangeRequired'] = passwordChangeRequired;
    if (passwordLastUpdateInstant != null) {
      json[r'passwordLastUpdateInstant'] = passwordLastUpdateInstant.toJson();
    }
    if (salt != null) {
      json[r'salt'] = salt;
    }
    if (uniqueUsername != null) {
      json[r'uniqueUsername'] = uniqueUsername;
    }
    if (username != null) {
      json[r'username'] = username;
    }
    if (usernameStatus != null) {
      json[r'usernameStatus'] = usernameStatus.value;
    }
    json[r'verified'] = verified;
    if (verifiedInstant != null) {
      json[r'verifiedInstant'] = verifiedInstant.toJson();
    }
    return json;
  }

  SecureIdentity copyWith(
      {ZonedDateTime? breachedPasswordLastCheckedInstant,
      BreachedPasswordStatus? breachedPasswordStatus,
      String? connectorId,
      String? encryptionScheme,
      int? factor,
      String? id,
      ZonedDateTime? lastLoginInstant,
      String? password,
      ChangePasswordReason? passwordChangeReason,
      bool? passwordChangeRequired,
      ZonedDateTime? passwordLastUpdateInstant,
      String? salt,
      String? uniqueUsername,
      String? username,
      ContentStatus? usernameStatus,
      bool? verified,
      ZonedDateTime? verifiedInstant}) {
    return SecureIdentity(
      breachedPasswordLastCheckedInstant: breachedPasswordLastCheckedInstant ??
          this.breachedPasswordLastCheckedInstant,
      breachedPasswordStatus:
          breachedPasswordStatus ?? this.breachedPasswordStatus,
      connectorId: connectorId ?? this.connectorId,
      encryptionScheme: encryptionScheme ?? this.encryptionScheme,
      factor: factor ?? this.factor,
      id: id ?? this.id,
      lastLoginInstant: lastLoginInstant ?? this.lastLoginInstant,
      password: password ?? this.password,
      passwordChangeReason: passwordChangeReason ?? this.passwordChangeReason,
      passwordChangeRequired:
          passwordChangeRequired ?? this.passwordChangeRequired,
      passwordLastUpdateInstant:
          passwordLastUpdateInstant ?? this.passwordLastUpdateInstant,
      salt: salt ?? this.salt,
      uniqueUsername: uniqueUsername ?? this.uniqueUsername,
      username: username ?? this.username,
      usernameStatus: usernameStatus ?? this.usernameStatus,
      verified: verified ?? this.verified,
      verifiedInstant: verifiedInstant ?? this.verifiedInstant,
    );
  }
}

class SelfServiceFormConfiguration {
  final bool requireCurrentPasswordOnPasswordChange;

  SelfServiceFormConfiguration({bool? requireCurrentPasswordOnPasswordChange})
      : requireCurrentPasswordOnPasswordChange =
            requireCurrentPasswordOnPasswordChange ?? false;

  factory SelfServiceFormConfiguration.fromJson(Map<String, Object?> json) {
    return SelfServiceFormConfiguration(
      requireCurrentPasswordOnPasswordChange:
          json[r'requireCurrentPasswordOnPasswordChange'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var requireCurrentPasswordOnPasswordChange =
        this.requireCurrentPasswordOnPasswordChange;

    final json = <String, Object?>{};
    json[r'requireCurrentPasswordOnPasswordChange'] =
        requireCurrentPasswordOnPasswordChange;
    return json;
  }

  SelfServiceFormConfiguration copyWith(
      {bool? requireCurrentPasswordOnPasswordChange}) {
    return SelfServiceFormConfiguration(
      requireCurrentPasswordOnPasswordChange:
          requireCurrentPasswordOnPasswordChange ??
              this.requireCurrentPasswordOnPasswordChange,
    );
  }
}

class SendRequest {
  final String? applicationId;
  final List<String> bccAddresses;
  final List<String> ccAddresses;
  final List<Locale> preferredLanguages;
  final Map<String, dynamic>? requestData;
  final List<EmailAddress> toAddresses;
  final List<String> userIds;

  SendRequest(
      {this.applicationId,
      List<String>? bccAddresses,
      List<String>? ccAddresses,
      List<Locale>? preferredLanguages,
      this.requestData,
      List<EmailAddress>? toAddresses,
      List<String>? userIds})
      : bccAddresses = bccAddresses ?? [],
        ccAddresses = ccAddresses ?? [],
        preferredLanguages = preferredLanguages ?? [],
        toAddresses = toAddresses ?? [],
        userIds = userIds ?? [];

  factory SendRequest.fromJson(Map<String, Object?> json) {
    return SendRequest(
      applicationId: json[r'applicationId'] as String?,
      bccAddresses: (json[r'bccAddresses'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      ccAddresses: (json[r'ccAddresses'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      preferredLanguages: (json[r'preferredLanguages'] as List<Object?>?)
              ?.map((i) => (i as Locale? ?? '') as Locale)
              .toList() ??
          [],
      requestData: json[r'requestData'] as Map<String, Object?>?,
      toAddresses: (json[r'toAddresses'] as List<Object?>?)
              ?.map((i) =>
                  EmailAddress.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      userIds: (json[r'userIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var bccAddresses = this.bccAddresses;
    var ccAddresses = this.ccAddresses;
    var preferredLanguages = this.preferredLanguages;
    var requestData = this.requestData;
    var toAddresses = this.toAddresses;
    var userIds = this.userIds;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    json[r'bccAddresses'] = bccAddresses;
    json[r'ccAddresses'] = ccAddresses;
    json[r'preferredLanguages'] =
        preferredLanguages.map((i) => i.toJson()).toList();
    if (requestData != null) {
      json[r'requestData'] = requestData;
    }
    json[r'toAddresses'] = toAddresses.map((i) => i.toJson()).toList();
    json[r'userIds'] = userIds;
    return json;
  }

  SendRequest copyWith(
      {String? applicationId,
      List<String>? bccAddresses,
      List<String>? ccAddresses,
      List<Locale>? preferredLanguages,
      Map<String, dynamic>? requestData,
      List<EmailAddress>? toAddresses,
      List<String>? userIds}) {
    return SendRequest(
      applicationId: applicationId ?? this.applicationId,
      bccAddresses: bccAddresses ?? this.bccAddresses,
      ccAddresses: ccAddresses ?? this.ccAddresses,
      preferredLanguages: preferredLanguages ?? this.preferredLanguages,
      requestData: requestData ?? this.requestData,
      toAddresses: toAddresses ?? this.toAddresses,
      userIds: userIds ?? this.userIds,
    );
  }
}

class SendResponse {
  final Map<String, dynamic>? anonymousResults;
  final Map<String, dynamic>? results;

  SendResponse({this.anonymousResults, this.results});

  factory SendResponse.fromJson(Map<String, Object?> json) {
    return SendResponse(
      anonymousResults: json[r'anonymousResults'] as Map<String, Object?>?,
      results: json[r'results'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var anonymousResults = this.anonymousResults;
    var results = this.results;

    final json = <String, Object?>{};
    if (anonymousResults != null) {
      json[r'anonymousResults'] = anonymousResults;
    }
    if (results != null) {
      json[r'results'] = results;
    }
    return json;
  }

  SendResponse copyWith(
      {Map<String, dynamic>? anonymousResults, Map<String, dynamic>? results}) {
    return SendResponse(
      anonymousResults: anonymousResults ?? this.anonymousResults,
      results: results ?? this.results,
    );
  }
}

/// Theme object for values used in the css variables for simple themes.
class SimpleThemeVariables {
  final String? alertBackgroundColor;
  final String? alertFontColor;
  final String? backgroundImageUrl;
  final String? backgroundSize;
  final String? borderRadius;
  final String? deleteButtonColor;
  final String? deleteButtonFocusColor;
  final String? deleteButtonTextColor;
  final String? deleteButtonTextFocusColor;
  final String? errorFontColor;
  final String? errorIconColor;
  final String? fontColor;
  final String? fontFamily;
  final bool footerDisplay;
  final String? iconBackgroundColor;
  final String? iconColor;
  final String? infoIconColor;
  final String? inputBackgroundColor;
  final String? inputIconColor;
  final String? inputTextColor;
  final String? linkTextColor;
  final String? linkTextFocusColor;
  final String? logoImageSize;
  final String? logoImageUrl;
  final String? monoFontColor;
  final String? monoFontFamily;
  final String? pageBackgroundColor;
  final String? panelBackgroundColor;
  final String? primaryButtonColor;
  final String? primaryButtonFocusColor;
  final String? primaryButtonTextColor;
  final String? primaryButtonTextFocusColor;

  SimpleThemeVariables(
      {this.alertBackgroundColor,
      this.alertFontColor,
      this.backgroundImageUrl,
      this.backgroundSize,
      this.borderRadius,
      this.deleteButtonColor,
      this.deleteButtonFocusColor,
      this.deleteButtonTextColor,
      this.deleteButtonTextFocusColor,
      this.errorFontColor,
      this.errorIconColor,
      this.fontColor,
      this.fontFamily,
      bool? footerDisplay,
      this.iconBackgroundColor,
      this.iconColor,
      this.infoIconColor,
      this.inputBackgroundColor,
      this.inputIconColor,
      this.inputTextColor,
      this.linkTextColor,
      this.linkTextFocusColor,
      this.logoImageSize,
      this.logoImageUrl,
      this.monoFontColor,
      this.monoFontFamily,
      this.pageBackgroundColor,
      this.panelBackgroundColor,
      this.primaryButtonColor,
      this.primaryButtonFocusColor,
      this.primaryButtonTextColor,
      this.primaryButtonTextFocusColor})
      : footerDisplay = footerDisplay ?? false;

  factory SimpleThemeVariables.fromJson(Map<String, Object?> json) {
    return SimpleThemeVariables(
      alertBackgroundColor: json[r'alertBackgroundColor'] as String?,
      alertFontColor: json[r'alertFontColor'] as String?,
      backgroundImageUrl: json[r'backgroundImageURL'] as String?,
      backgroundSize: json[r'backgroundSize'] as String?,
      borderRadius: json[r'borderRadius'] as String?,
      deleteButtonColor: json[r'deleteButtonColor'] as String?,
      deleteButtonFocusColor: json[r'deleteButtonFocusColor'] as String?,
      deleteButtonTextColor: json[r'deleteButtonTextColor'] as String?,
      deleteButtonTextFocusColor:
          json[r'deleteButtonTextFocusColor'] as String?,
      errorFontColor: json[r'errorFontColor'] as String?,
      errorIconColor: json[r'errorIconColor'] as String?,
      fontColor: json[r'fontColor'] as String?,
      fontFamily: json[r'fontFamily'] as String?,
      footerDisplay: json[r'footerDisplay'] as bool? ?? false,
      iconBackgroundColor: json[r'iconBackgroundColor'] as String?,
      iconColor: json[r'iconColor'] as String?,
      infoIconColor: json[r'infoIconColor'] as String?,
      inputBackgroundColor: json[r'inputBackgroundColor'] as String?,
      inputIconColor: json[r'inputIconColor'] as String?,
      inputTextColor: json[r'inputTextColor'] as String?,
      linkTextColor: json[r'linkTextColor'] as String?,
      linkTextFocusColor: json[r'linkTextFocusColor'] as String?,
      logoImageSize: json[r'logoImageSize'] as String?,
      logoImageUrl: json[r'logoImageURL'] as String?,
      monoFontColor: json[r'monoFontColor'] as String?,
      monoFontFamily: json[r'monoFontFamily'] as String?,
      pageBackgroundColor: json[r'pageBackgroundColor'] as String?,
      panelBackgroundColor: json[r'panelBackgroundColor'] as String?,
      primaryButtonColor: json[r'primaryButtonColor'] as String?,
      primaryButtonFocusColor: json[r'primaryButtonFocusColor'] as String?,
      primaryButtonTextColor: json[r'primaryButtonTextColor'] as String?,
      primaryButtonTextFocusColor:
          json[r'primaryButtonTextFocusColor'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var alertBackgroundColor = this.alertBackgroundColor;
    var alertFontColor = this.alertFontColor;
    var backgroundImageUrl = this.backgroundImageUrl;
    var backgroundSize = this.backgroundSize;
    var borderRadius = this.borderRadius;
    var deleteButtonColor = this.deleteButtonColor;
    var deleteButtonFocusColor = this.deleteButtonFocusColor;
    var deleteButtonTextColor = this.deleteButtonTextColor;
    var deleteButtonTextFocusColor = this.deleteButtonTextFocusColor;
    var errorFontColor = this.errorFontColor;
    var errorIconColor = this.errorIconColor;
    var fontColor = this.fontColor;
    var fontFamily = this.fontFamily;
    var footerDisplay = this.footerDisplay;
    var iconBackgroundColor = this.iconBackgroundColor;
    var iconColor = this.iconColor;
    var infoIconColor = this.infoIconColor;
    var inputBackgroundColor = this.inputBackgroundColor;
    var inputIconColor = this.inputIconColor;
    var inputTextColor = this.inputTextColor;
    var linkTextColor = this.linkTextColor;
    var linkTextFocusColor = this.linkTextFocusColor;
    var logoImageSize = this.logoImageSize;
    var logoImageUrl = this.logoImageUrl;
    var monoFontColor = this.monoFontColor;
    var monoFontFamily = this.monoFontFamily;
    var pageBackgroundColor = this.pageBackgroundColor;
    var panelBackgroundColor = this.panelBackgroundColor;
    var primaryButtonColor = this.primaryButtonColor;
    var primaryButtonFocusColor = this.primaryButtonFocusColor;
    var primaryButtonTextColor = this.primaryButtonTextColor;
    var primaryButtonTextFocusColor = this.primaryButtonTextFocusColor;

    final json = <String, Object?>{};
    if (alertBackgroundColor != null) {
      json[r'alertBackgroundColor'] = alertBackgroundColor;
    }
    if (alertFontColor != null) {
      json[r'alertFontColor'] = alertFontColor;
    }
    if (backgroundImageUrl != null) {
      json[r'backgroundImageURL'] = backgroundImageUrl;
    }
    if (backgroundSize != null) {
      json[r'backgroundSize'] = backgroundSize;
    }
    if (borderRadius != null) {
      json[r'borderRadius'] = borderRadius;
    }
    if (deleteButtonColor != null) {
      json[r'deleteButtonColor'] = deleteButtonColor;
    }
    if (deleteButtonFocusColor != null) {
      json[r'deleteButtonFocusColor'] = deleteButtonFocusColor;
    }
    if (deleteButtonTextColor != null) {
      json[r'deleteButtonTextColor'] = deleteButtonTextColor;
    }
    if (deleteButtonTextFocusColor != null) {
      json[r'deleteButtonTextFocusColor'] = deleteButtonTextFocusColor;
    }
    if (errorFontColor != null) {
      json[r'errorFontColor'] = errorFontColor;
    }
    if (errorIconColor != null) {
      json[r'errorIconColor'] = errorIconColor;
    }
    if (fontColor != null) {
      json[r'fontColor'] = fontColor;
    }
    if (fontFamily != null) {
      json[r'fontFamily'] = fontFamily;
    }
    json[r'footerDisplay'] = footerDisplay;
    if (iconBackgroundColor != null) {
      json[r'iconBackgroundColor'] = iconBackgroundColor;
    }
    if (iconColor != null) {
      json[r'iconColor'] = iconColor;
    }
    if (infoIconColor != null) {
      json[r'infoIconColor'] = infoIconColor;
    }
    if (inputBackgroundColor != null) {
      json[r'inputBackgroundColor'] = inputBackgroundColor;
    }
    if (inputIconColor != null) {
      json[r'inputIconColor'] = inputIconColor;
    }
    if (inputTextColor != null) {
      json[r'inputTextColor'] = inputTextColor;
    }
    if (linkTextColor != null) {
      json[r'linkTextColor'] = linkTextColor;
    }
    if (linkTextFocusColor != null) {
      json[r'linkTextFocusColor'] = linkTextFocusColor;
    }
    if (logoImageSize != null) {
      json[r'logoImageSize'] = logoImageSize;
    }
    if (logoImageUrl != null) {
      json[r'logoImageURL'] = logoImageUrl;
    }
    if (monoFontColor != null) {
      json[r'monoFontColor'] = monoFontColor;
    }
    if (monoFontFamily != null) {
      json[r'monoFontFamily'] = monoFontFamily;
    }
    if (pageBackgroundColor != null) {
      json[r'pageBackgroundColor'] = pageBackgroundColor;
    }
    if (panelBackgroundColor != null) {
      json[r'panelBackgroundColor'] = panelBackgroundColor;
    }
    if (primaryButtonColor != null) {
      json[r'primaryButtonColor'] = primaryButtonColor;
    }
    if (primaryButtonFocusColor != null) {
      json[r'primaryButtonFocusColor'] = primaryButtonFocusColor;
    }
    if (primaryButtonTextColor != null) {
      json[r'primaryButtonTextColor'] = primaryButtonTextColor;
    }
    if (primaryButtonTextFocusColor != null) {
      json[r'primaryButtonTextFocusColor'] = primaryButtonTextFocusColor;
    }
    return json;
  }

  SimpleThemeVariables copyWith(
      {String? alertBackgroundColor,
      String? alertFontColor,
      String? backgroundImageUrl,
      String? backgroundSize,
      String? borderRadius,
      String? deleteButtonColor,
      String? deleteButtonFocusColor,
      String? deleteButtonTextColor,
      String? deleteButtonTextFocusColor,
      String? errorFontColor,
      String? errorIconColor,
      String? fontColor,
      String? fontFamily,
      bool? footerDisplay,
      String? iconBackgroundColor,
      String? iconColor,
      String? infoIconColor,
      String? inputBackgroundColor,
      String? inputIconColor,
      String? inputTextColor,
      String? linkTextColor,
      String? linkTextFocusColor,
      String? logoImageSize,
      String? logoImageUrl,
      String? monoFontColor,
      String? monoFontFamily,
      String? pageBackgroundColor,
      String? panelBackgroundColor,
      String? primaryButtonColor,
      String? primaryButtonFocusColor,
      String? primaryButtonTextColor,
      String? primaryButtonTextFocusColor}) {
    return SimpleThemeVariables(
      alertBackgroundColor: alertBackgroundColor ?? this.alertBackgroundColor,
      alertFontColor: alertFontColor ?? this.alertFontColor,
      backgroundImageUrl: backgroundImageUrl ?? this.backgroundImageUrl,
      backgroundSize: backgroundSize ?? this.backgroundSize,
      borderRadius: borderRadius ?? this.borderRadius,
      deleteButtonColor: deleteButtonColor ?? this.deleteButtonColor,
      deleteButtonFocusColor:
          deleteButtonFocusColor ?? this.deleteButtonFocusColor,
      deleteButtonTextColor:
          deleteButtonTextColor ?? this.deleteButtonTextColor,
      deleteButtonTextFocusColor:
          deleteButtonTextFocusColor ?? this.deleteButtonTextFocusColor,
      errorFontColor: errorFontColor ?? this.errorFontColor,
      errorIconColor: errorIconColor ?? this.errorIconColor,
      fontColor: fontColor ?? this.fontColor,
      fontFamily: fontFamily ?? this.fontFamily,
      footerDisplay: footerDisplay ?? this.footerDisplay,
      iconBackgroundColor: iconBackgroundColor ?? this.iconBackgroundColor,
      iconColor: iconColor ?? this.iconColor,
      infoIconColor: infoIconColor ?? this.infoIconColor,
      inputBackgroundColor: inputBackgroundColor ?? this.inputBackgroundColor,
      inputIconColor: inputIconColor ?? this.inputIconColor,
      inputTextColor: inputTextColor ?? this.inputTextColor,
      linkTextColor: linkTextColor ?? this.linkTextColor,
      linkTextFocusColor: linkTextFocusColor ?? this.linkTextFocusColor,
      logoImageSize: logoImageSize ?? this.logoImageSize,
      logoImageUrl: logoImageUrl ?? this.logoImageUrl,
      monoFontColor: monoFontColor ?? this.monoFontColor,
      monoFontFamily: monoFontFamily ?? this.monoFontFamily,
      pageBackgroundColor: pageBackgroundColor ?? this.pageBackgroundColor,
      panelBackgroundColor: panelBackgroundColor ?? this.panelBackgroundColor,
      primaryButtonColor: primaryButtonColor ?? this.primaryButtonColor,
      primaryButtonFocusColor:
          primaryButtonFocusColor ?? this.primaryButtonFocusColor,
      primaryButtonTextColor:
          primaryButtonTextColor ?? this.primaryButtonTextColor,
      primaryButtonTextFocusColor:
          primaryButtonTextFocusColor ?? this.primaryButtonTextFocusColor,
    );
  }
}

class SonyPSNApplicationConfiguration {
  final String? buttonText;
  final String? clientId;
  final String? clientSecret;
  final String? scope;
  final Map<String, dynamic>? data;
  final bool createRegistration;

  SonyPSNApplicationConfiguration(
      {this.buttonText,
      this.clientId,
      this.clientSecret,
      this.scope,
      this.data,
      bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory SonyPSNApplicationConfiguration.fromJson(Map<String, Object?> json) {
    return SonyPSNApplicationConfiguration(
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      scope: json[r'scope'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var scope = this.scope;
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  SonyPSNApplicationConfiguration copyWith(
      {String? buttonText,
      String? clientId,
      String? clientSecret,
      String? scope,
      Map<String, dynamic>? data,
      bool? createRegistration}) {
    return SonyPSNApplicationConfiguration(
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      scope: scope ?? this.scope,
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

/// SonyPSN gaming login provider.
class SonyPSNIdentityProvider {
  final String? buttonText;
  final String? clientId;
  final String? clientSecret;
  final String? scope;
  final Map<String, dynamic>? data;
  final Map<String, dynamic>? applicationConfiguration;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ProviderLambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final IdentityProviderLinkingStrategy? linkingStrategy;
  final String? name;
  final Map<String, dynamic>? tenantConfiguration;
  final IdentityProviderType? type;

  SonyPSNIdentityProvider(
      {this.buttonText,
      this.clientId,
      this.clientSecret,
      this.scope,
      this.data,
      this.applicationConfiguration,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.linkingStrategy,
      this.name,
      this.tenantConfiguration,
      this.type})
      : debug = debug ?? false;

  factory SonyPSNIdentityProvider.fromJson(Map<String, Object?> json) {
    return SonyPSNIdentityProvider(
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      scope: json[r'scope'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      applicationConfiguration:
          json[r'applicationConfiguration'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? ProviderLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      linkingStrategy: json[r'linkingStrategy'] != null
          ? IdentityProviderLinkingStrategy.fromValue(
              json[r'linkingStrategy']! as String)
          : null,
      name: json[r'name'] as String?,
      tenantConfiguration:
          json[r'tenantConfiguration'] as Map<String, Object?>?,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var scope = this.scope;
    var data = this.data;
    var applicationConfiguration = this.applicationConfiguration;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var linkingStrategy = this.linkingStrategy;
    var name = this.name;
    var tenantConfiguration = this.tenantConfiguration;
    var type = this.type;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (applicationConfiguration != null) {
      json[r'applicationConfiguration'] = applicationConfiguration;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (linkingStrategy != null) {
      json[r'linkingStrategy'] = linkingStrategy.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (tenantConfiguration != null) {
      json[r'tenantConfiguration'] = tenantConfiguration;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  SonyPSNIdentityProvider copyWith(
      {String? buttonText,
      String? clientId,
      String? clientSecret,
      String? scope,
      Map<String, dynamic>? data,
      Map<String, dynamic>? applicationConfiguration,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ProviderLambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      IdentityProviderLinkingStrategy? linkingStrategy,
      String? name,
      Map<String, dynamic>? tenantConfiguration,
      IdentityProviderType? type}) {
    return SonyPSNIdentityProvider(
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      scope: scope ?? this.scope,
      data: data ?? this.data,
      applicationConfiguration:
          applicationConfiguration ?? this.applicationConfiguration,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      linkingStrategy: linkingStrategy ?? this.linkingStrategy,
      name: name ?? this.name,
      tenantConfiguration: tenantConfiguration ?? this.tenantConfiguration,
      type: type ?? this.type,
    );
  }
}

class SortField {
  final String? missing;
  final String? name;
  final Sort? order;

  SortField({this.missing, this.name, this.order});

  factory SortField.fromJson(Map<String, Object?> json) {
    return SortField(
      missing: json[r'missing'] as String?,
      name: json[r'name'] as String?,
      order: json[r'order'] != null
          ? Sort.fromValue(json[r'order']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var missing = this.missing;
    var name = this.name;
    var order = this.order;

    final json = <String, Object?>{};
    if (missing != null) {
      json[r'missing'] = missing;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (order != null) {
      json[r'order'] = order.value;
    }
    return json;
  }

  SortField copyWith({String? missing, String? name, Sort? order}) {
    return SortField(
      missing: missing ?? this.missing,
      name: name ?? this.name,
      order: order ?? this.order,
    );
  }
}

/// The public Status API response
class StatusResponse {
  StatusResponse();

  factory StatusResponse.fromJson(Map<String, Object?> json) {
    return StatusResponse();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class SteamApplicationConfiguration {
  final SteamAPIMode? apiMode;
  final String? buttonText;
  final String? clientId;
  final String? scope;
  final String? webApiKey;
  final Map<String, dynamic>? data;
  final bool createRegistration;

  SteamApplicationConfiguration(
      {this.apiMode,
      this.buttonText,
      this.clientId,
      this.scope,
      this.webApiKey,
      this.data,
      bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory SteamApplicationConfiguration.fromJson(Map<String, Object?> json) {
    return SteamApplicationConfiguration(
      apiMode: json[r'apiMode'] != null
          ? SteamAPIMode.fromValue(json[r'apiMode']! as String)
          : null,
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      scope: json[r'scope'] as String?,
      webApiKey: json[r'webAPIKey'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var apiMode = this.apiMode;
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var scope = this.scope;
    var webApiKey = this.webApiKey;
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (apiMode != null) {
      json[r'apiMode'] = apiMode.value;
    }
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (webApiKey != null) {
      json[r'webAPIKey'] = webApiKey;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  SteamApplicationConfiguration copyWith(
      {SteamAPIMode? apiMode,
      String? buttonText,
      String? clientId,
      String? scope,
      String? webApiKey,
      Map<String, dynamic>? data,
      bool? createRegistration}) {
    return SteamApplicationConfiguration(
      apiMode: apiMode ?? this.apiMode,
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      scope: scope ?? this.scope,
      webApiKey: webApiKey ?? this.webApiKey,
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

/// Steam gaming login provider.
class SteamIdentityProvider {
  final SteamAPIMode? apiMode;
  final String? buttonText;
  final String? clientId;
  final String? scope;
  final String? webApiKey;
  final Map<String, dynamic>? data;
  final Map<String, dynamic>? applicationConfiguration;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ProviderLambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final IdentityProviderLinkingStrategy? linkingStrategy;
  final String? name;
  final Map<String, dynamic>? tenantConfiguration;
  final IdentityProviderType? type;

  SteamIdentityProvider(
      {this.apiMode,
      this.buttonText,
      this.clientId,
      this.scope,
      this.webApiKey,
      this.data,
      this.applicationConfiguration,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.linkingStrategy,
      this.name,
      this.tenantConfiguration,
      this.type})
      : debug = debug ?? false;

  factory SteamIdentityProvider.fromJson(Map<String, Object?> json) {
    return SteamIdentityProvider(
      apiMode: json[r'apiMode'] != null
          ? SteamAPIMode.fromValue(json[r'apiMode']! as String)
          : null,
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      scope: json[r'scope'] as String?,
      webApiKey: json[r'webAPIKey'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      applicationConfiguration:
          json[r'applicationConfiguration'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? ProviderLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      linkingStrategy: json[r'linkingStrategy'] != null
          ? IdentityProviderLinkingStrategy.fromValue(
              json[r'linkingStrategy']! as String)
          : null,
      name: json[r'name'] as String?,
      tenantConfiguration:
          json[r'tenantConfiguration'] as Map<String, Object?>?,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var apiMode = this.apiMode;
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var scope = this.scope;
    var webApiKey = this.webApiKey;
    var data = this.data;
    var applicationConfiguration = this.applicationConfiguration;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var linkingStrategy = this.linkingStrategy;
    var name = this.name;
    var tenantConfiguration = this.tenantConfiguration;
    var type = this.type;

    final json = <String, Object?>{};
    if (apiMode != null) {
      json[r'apiMode'] = apiMode.value;
    }
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (webApiKey != null) {
      json[r'webAPIKey'] = webApiKey;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (applicationConfiguration != null) {
      json[r'applicationConfiguration'] = applicationConfiguration;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (linkingStrategy != null) {
      json[r'linkingStrategy'] = linkingStrategy.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (tenantConfiguration != null) {
      json[r'tenantConfiguration'] = tenantConfiguration;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  SteamIdentityProvider copyWith(
      {SteamAPIMode? apiMode,
      String? buttonText,
      String? clientId,
      String? scope,
      String? webApiKey,
      Map<String, dynamic>? data,
      Map<String, dynamic>? applicationConfiguration,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ProviderLambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      IdentityProviderLinkingStrategy? linkingStrategy,
      String? name,
      Map<String, dynamic>? tenantConfiguration,
      IdentityProviderType? type}) {
    return SteamIdentityProvider(
      apiMode: apiMode ?? this.apiMode,
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      scope: scope ?? this.scope,
      webApiKey: webApiKey ?? this.webApiKey,
      data: data ?? this.data,
      applicationConfiguration:
          applicationConfiguration ?? this.applicationConfiguration,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      linkingStrategy: linkingStrategy ?? this.linkingStrategy,
      name: name ?? this.name,
      tenantConfiguration: tenantConfiguration ?? this.tenantConfiguration,
      type: type ?? this.type,
    );
  }
}

/// Helper interface that indicates an identity provider can be federated to
/// using the HTTP POST method.
class SupportsPostBindings {
  SupportsPostBindings();

  factory SupportsPostBindings.fromJson(Map<String, Object?> json) {
    return SupportsPostBindings();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class SystemConfiguration {
  final AuditLogConfiguration? auditLogConfiguration;
  final CORSConfiguration? corsConfiguration;
  final Map<String, dynamic>? data;
  final EventLogConfiguration? eventLogConfiguration;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final LoginRecordConfiguration? loginRecordConfiguration;
  final ZoneId? reportTimezone;
  final SystemTrustedProxyConfiguration? trustedProxyConfiguration;
  final UIConfiguration? uiConfiguration;
  final WebhookEventLogConfiguration? webhookEventLogConfiguration;

  SystemConfiguration(
      {this.auditLogConfiguration,
      this.corsConfiguration,
      this.data,
      this.eventLogConfiguration,
      this.insertInstant,
      this.lastUpdateInstant,
      this.loginRecordConfiguration,
      this.reportTimezone,
      this.trustedProxyConfiguration,
      this.uiConfiguration,
      this.webhookEventLogConfiguration});

  factory SystemConfiguration.fromJson(Map<String, Object?> json) {
    return SystemConfiguration(
      auditLogConfiguration: json[r'auditLogConfiguration'] != null
          ? AuditLogConfiguration.fromJson(
              json[r'auditLogConfiguration']! as Map<String, Object?>)
          : null,
      corsConfiguration: json[r'corsConfiguration'] != null
          ? CORSConfiguration.fromJson(
              json[r'corsConfiguration']! as Map<String, Object?>)
          : null,
      data: json[r'data'] as Map<String, Object?>?,
      eventLogConfiguration: json[r'eventLogConfiguration'] != null
          ? EventLogConfiguration.fromJson(
              json[r'eventLogConfiguration']! as Map<String, Object?>)
          : null,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      loginRecordConfiguration: json[r'loginRecordConfiguration'] != null
          ? LoginRecordConfiguration.fromJson(
              json[r'loginRecordConfiguration']! as Map<String, Object?>)
          : null,
      reportTimezone: json[r'reportTimezone'] as ZoneId?,
      trustedProxyConfiguration: json[r'trustedProxyConfiguration'] != null
          ? SystemTrustedProxyConfiguration.fromJson(
              json[r'trustedProxyConfiguration']! as Map<String, Object?>)
          : null,
      uiConfiguration: json[r'uiConfiguration'] != null
          ? UIConfiguration.fromJson(
              json[r'uiConfiguration']! as Map<String, Object?>)
          : null,
      webhookEventLogConfiguration: json[r'webhookEventLogConfiguration'] !=
              null
          ? WebhookEventLogConfiguration.fromJson(
              json[r'webhookEventLogConfiguration']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var auditLogConfiguration = this.auditLogConfiguration;
    var corsConfiguration = this.corsConfiguration;
    var data = this.data;
    var eventLogConfiguration = this.eventLogConfiguration;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var loginRecordConfiguration = this.loginRecordConfiguration;
    var reportTimezone = this.reportTimezone;
    var trustedProxyConfiguration = this.trustedProxyConfiguration;
    var uiConfiguration = this.uiConfiguration;
    var webhookEventLogConfiguration = this.webhookEventLogConfiguration;

    final json = <String, Object?>{};
    if (auditLogConfiguration != null) {
      json[r'auditLogConfiguration'] = auditLogConfiguration.toJson();
    }
    if (corsConfiguration != null) {
      json[r'corsConfiguration'] = corsConfiguration.toJson();
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (eventLogConfiguration != null) {
      json[r'eventLogConfiguration'] = eventLogConfiguration.toJson();
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (loginRecordConfiguration != null) {
      json[r'loginRecordConfiguration'] = loginRecordConfiguration.toJson();
    }
    if (reportTimezone != null) {
      json[r'reportTimezone'] = reportTimezone.toJson();
    }
    if (trustedProxyConfiguration != null) {
      json[r'trustedProxyConfiguration'] = trustedProxyConfiguration.toJson();
    }
    if (uiConfiguration != null) {
      json[r'uiConfiguration'] = uiConfiguration.toJson();
    }
    if (webhookEventLogConfiguration != null) {
      json[r'webhookEventLogConfiguration'] =
          webhookEventLogConfiguration.toJson();
    }
    return json;
  }

  SystemConfiguration copyWith(
      {AuditLogConfiguration? auditLogConfiguration,
      CORSConfiguration? corsConfiguration,
      Map<String, dynamic>? data,
      EventLogConfiguration? eventLogConfiguration,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      LoginRecordConfiguration? loginRecordConfiguration,
      ZoneId? reportTimezone,
      SystemTrustedProxyConfiguration? trustedProxyConfiguration,
      UIConfiguration? uiConfiguration,
      WebhookEventLogConfiguration? webhookEventLogConfiguration}) {
    return SystemConfiguration(
      auditLogConfiguration:
          auditLogConfiguration ?? this.auditLogConfiguration,
      corsConfiguration: corsConfiguration ?? this.corsConfiguration,
      data: data ?? this.data,
      eventLogConfiguration:
          eventLogConfiguration ?? this.eventLogConfiguration,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      loginRecordConfiguration:
          loginRecordConfiguration ?? this.loginRecordConfiguration,
      reportTimezone: reportTimezone ?? this.reportTimezone,
      trustedProxyConfiguration:
          trustedProxyConfiguration ?? this.trustedProxyConfiguration,
      uiConfiguration: uiConfiguration ?? this.uiConfiguration,
      webhookEventLogConfiguration:
          webhookEventLogConfiguration ?? this.webhookEventLogConfiguration,
    );
  }
}

/// Request for the system configuration API.
class SystemConfigurationRequest {
  final SystemConfiguration? systemConfiguration;

  SystemConfigurationRequest({this.systemConfiguration});

  factory SystemConfigurationRequest.fromJson(Map<String, Object?> json) {
    return SystemConfigurationRequest(
      systemConfiguration: json[r'systemConfiguration'] != null
          ? SystemConfiguration.fromJson(
              json[r'systemConfiguration']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var systemConfiguration = this.systemConfiguration;

    final json = <String, Object?>{};
    if (systemConfiguration != null) {
      json[r'systemConfiguration'] = systemConfiguration.toJson();
    }
    return json;
  }

  SystemConfigurationRequest copyWith(
      {SystemConfiguration? systemConfiguration}) {
    return SystemConfigurationRequest(
      systemConfiguration: systemConfiguration ?? this.systemConfiguration,
    );
  }
}

/// Response for the system configuration API.
class SystemConfigurationResponse {
  final SystemConfiguration? systemConfiguration;

  SystemConfigurationResponse({this.systemConfiguration});

  factory SystemConfigurationResponse.fromJson(Map<String, Object?> json) {
    return SystemConfigurationResponse(
      systemConfiguration: json[r'systemConfiguration'] != null
          ? SystemConfiguration.fromJson(
              json[r'systemConfiguration']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var systemConfiguration = this.systemConfiguration;

    final json = <String, Object?>{};
    if (systemConfiguration != null) {
      json[r'systemConfiguration'] = systemConfiguration.toJson();
    }
    return json;
  }

  SystemConfigurationResponse copyWith(
      {SystemConfiguration? systemConfiguration}) {
    return SystemConfigurationResponse(
      systemConfiguration: systemConfiguration ?? this.systemConfiguration,
    );
  }
}

class SystemLogsExportRequest {
  final bool includeArchived;
  final int? lastnBytes;
  final String? dateTimeSecondsFormat;
  final ZoneId? zoneId;

  SystemLogsExportRequest(
      {bool? includeArchived,
      this.lastnBytes,
      this.dateTimeSecondsFormat,
      this.zoneId})
      : includeArchived = includeArchived ?? false;

  factory SystemLogsExportRequest.fromJson(Map<String, Object?> json) {
    return SystemLogsExportRequest(
      includeArchived: json[r'includeArchived'] as bool? ?? false,
      lastnBytes: (json[r'lastNBytes'] as num?)?.toInt(),
      dateTimeSecondsFormat: json[r'dateTimeSecondsFormat'] as String?,
      zoneId: json[r'zoneId'] as ZoneId?,
    );
  }

  Map<String, Object?> toJson() {
    var includeArchived = this.includeArchived;
    var lastnBytes = this.lastnBytes;
    var dateTimeSecondsFormat = this.dateTimeSecondsFormat;
    var zoneId = this.zoneId;

    final json = <String, Object?>{};
    json[r'includeArchived'] = includeArchived;
    if (lastnBytes != null) {
      json[r'lastNBytes'] = lastnBytes;
    }
    if (dateTimeSecondsFormat != null) {
      json[r'dateTimeSecondsFormat'] = dateTimeSecondsFormat;
    }
    if (zoneId != null) {
      json[r'zoneId'] = zoneId.toJson();
    }
    return json;
  }

  SystemLogsExportRequest copyWith(
      {bool? includeArchived,
      int? lastnBytes,
      String? dateTimeSecondsFormat,
      ZoneId? zoneId}) {
    return SystemLogsExportRequest(
      includeArchived: includeArchived ?? this.includeArchived,
      lastnBytes: lastnBytes ?? this.lastnBytes,
      dateTimeSecondsFormat:
          dateTimeSecondsFormat ?? this.dateTimeSecondsFormat,
      zoneId: zoneId ?? this.zoneId,
    );
  }
}

class SystemTrustedProxyConfiguration {
  final SystemTrustedProxyConfigurationPolicy? trustPolicy;
  final List<String> trusted;

  SystemTrustedProxyConfiguration({this.trustPolicy, List<String>? trusted})
      : trusted = trusted ?? [];

  factory SystemTrustedProxyConfiguration.fromJson(Map<String, Object?> json) {
    return SystemTrustedProxyConfiguration(
      trustPolicy: json[r'trustPolicy'] != null
          ? SystemTrustedProxyConfigurationPolicy.fromValue(
              json[r'trustPolicy']! as String)
          : null,
      trusted: (json[r'trusted'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var trustPolicy = this.trustPolicy;
    var trusted = this.trusted;

    final json = <String, Object?>{};
    if (trustPolicy != null) {
      json[r'trustPolicy'] = trustPolicy.value;
    }
    json[r'trusted'] = trusted;
    return json;
  }

  SystemTrustedProxyConfiguration copyWith(
      {SystemTrustedProxyConfigurationPolicy? trustPolicy,
      List<String>? trusted}) {
    return SystemTrustedProxyConfiguration(
      trustPolicy: trustPolicy ?? this.trustPolicy,
      trusted: trusted ?? this.trusted,
    );
  }
}

class Templates {
  final String? accountEdit;
  final String? accountIndex;
  final String? accountTwoFactorDisable;
  final String? accountTwoFactorEnable;
  final String? accountTwoFactorIndex;
  final String? accountWebAuthnAdd;
  final String? accountWebAuthnDelete;
  final String? accountWebAuthnIndex;
  final String? confirmationRequired;
  final String? emailComplete;
  final String? emailSent;
  final String? emailVerificationRequired;
  final String? emailVerify;
  final String? helpers;
  final String? index;
  final String? oauth2Authorize;
  final String? oauth2AuthorizedNotRegistered;
  final String? oauth2ChildRegistrationNotAllowed;
  final String? oauth2ChildRegistrationNotAllowedComplete;
  final String? oauth2CompleteRegistration;
  final String? oauth2Consent;
  final String? oauth2Device;
  final String? oauth2DeviceComplete;
  final String? oauth2Error;
  final String? oauth2Logout;
  final String? oauth2Passwordless;
  final String? oauth2Register;
  final String? oauth2StartIdpLink;
  final String? oauth2TwoFactor;
  final String? oauth2TwoFactorEnable;
  final String? oauth2TwoFactorEnableComplete;
  final String? oauth2TwoFactorMethods;
  final String? oauth2Wait;
  final String? oauth2WebAuthn;
  final String? oauth2WebAuthnReauth;
  final String? oauth2WebAuthnReauthEnable;
  final String? passwordChange;
  final String? passwordComplete;
  final String? passwordForgot;
  final String? passwordSent;
  final String? registrationComplete;
  final String? registrationSent;
  final String? registrationVerificationRequired;
  final String? registrationVerify;
  final String? samlv2Logout;
  final String? unauthorized;
  final String? emailSend;
  final String? registrationSend;

  Templates(
      {this.accountEdit,
      this.accountIndex,
      this.accountTwoFactorDisable,
      this.accountTwoFactorEnable,
      this.accountTwoFactorIndex,
      this.accountWebAuthnAdd,
      this.accountWebAuthnDelete,
      this.accountWebAuthnIndex,
      this.confirmationRequired,
      this.emailComplete,
      this.emailSent,
      this.emailVerificationRequired,
      this.emailVerify,
      this.helpers,
      this.index,
      this.oauth2Authorize,
      this.oauth2AuthorizedNotRegistered,
      this.oauth2ChildRegistrationNotAllowed,
      this.oauth2ChildRegistrationNotAllowedComplete,
      this.oauth2CompleteRegistration,
      this.oauth2Consent,
      this.oauth2Device,
      this.oauth2DeviceComplete,
      this.oauth2Error,
      this.oauth2Logout,
      this.oauth2Passwordless,
      this.oauth2Register,
      this.oauth2StartIdpLink,
      this.oauth2TwoFactor,
      this.oauth2TwoFactorEnable,
      this.oauth2TwoFactorEnableComplete,
      this.oauth2TwoFactorMethods,
      this.oauth2Wait,
      this.oauth2WebAuthn,
      this.oauth2WebAuthnReauth,
      this.oauth2WebAuthnReauthEnable,
      this.passwordChange,
      this.passwordComplete,
      this.passwordForgot,
      this.passwordSent,
      this.registrationComplete,
      this.registrationSent,
      this.registrationVerificationRequired,
      this.registrationVerify,
      this.samlv2Logout,
      this.unauthorized,
      this.emailSend,
      this.registrationSend});

  factory Templates.fromJson(Map<String, Object?> json) {
    return Templates(
      accountEdit: json[r'accountEdit'] as String?,
      accountIndex: json[r'accountIndex'] as String?,
      accountTwoFactorDisable: json[r'accountTwoFactorDisable'] as String?,
      accountTwoFactorEnable: json[r'accountTwoFactorEnable'] as String?,
      accountTwoFactorIndex: json[r'accountTwoFactorIndex'] as String?,
      accountWebAuthnAdd: json[r'accountWebAuthnAdd'] as String?,
      accountWebAuthnDelete: json[r'accountWebAuthnDelete'] as String?,
      accountWebAuthnIndex: json[r'accountWebAuthnIndex'] as String?,
      confirmationRequired: json[r'confirmationRequired'] as String?,
      emailComplete: json[r'emailComplete'] as String?,
      emailSent: json[r'emailSent'] as String?,
      emailVerificationRequired: json[r'emailVerificationRequired'] as String?,
      emailVerify: json[r'emailVerify'] as String?,
      helpers: json[r'helpers'] as String?,
      index: json[r'index'] as String?,
      oauth2Authorize: json[r'oauth2Authorize'] as String?,
      oauth2AuthorizedNotRegistered:
          json[r'oauth2AuthorizedNotRegistered'] as String?,
      oauth2ChildRegistrationNotAllowed:
          json[r'oauth2ChildRegistrationNotAllowed'] as String?,
      oauth2ChildRegistrationNotAllowedComplete:
          json[r'oauth2ChildRegistrationNotAllowedComplete'] as String?,
      oauth2CompleteRegistration:
          json[r'oauth2CompleteRegistration'] as String?,
      oauth2Consent: json[r'oauth2Consent'] as String?,
      oauth2Device: json[r'oauth2Device'] as String?,
      oauth2DeviceComplete: json[r'oauth2DeviceComplete'] as String?,
      oauth2Error: json[r'oauth2Error'] as String?,
      oauth2Logout: json[r'oauth2Logout'] as String?,
      oauth2Passwordless: json[r'oauth2Passwordless'] as String?,
      oauth2Register: json[r'oauth2Register'] as String?,
      oauth2StartIdpLink: json[r'oauth2StartIdPLink'] as String?,
      oauth2TwoFactor: json[r'oauth2TwoFactor'] as String?,
      oauth2TwoFactorEnable: json[r'oauth2TwoFactorEnable'] as String?,
      oauth2TwoFactorEnableComplete:
          json[r'oauth2TwoFactorEnableComplete'] as String?,
      oauth2TwoFactorMethods: json[r'oauth2TwoFactorMethods'] as String?,
      oauth2Wait: json[r'oauth2Wait'] as String?,
      oauth2WebAuthn: json[r'oauth2WebAuthn'] as String?,
      oauth2WebAuthnReauth: json[r'oauth2WebAuthnReauth'] as String?,
      oauth2WebAuthnReauthEnable:
          json[r'oauth2WebAuthnReauthEnable'] as String?,
      passwordChange: json[r'passwordChange'] as String?,
      passwordComplete: json[r'passwordComplete'] as String?,
      passwordForgot: json[r'passwordForgot'] as String?,
      passwordSent: json[r'passwordSent'] as String?,
      registrationComplete: json[r'registrationComplete'] as String?,
      registrationSent: json[r'registrationSent'] as String?,
      registrationVerificationRequired:
          json[r'registrationVerificationRequired'] as String?,
      registrationVerify: json[r'registrationVerify'] as String?,
      samlv2Logout: json[r'samlv2Logout'] as String?,
      unauthorized: json[r'unauthorized'] as String?,
      emailSend: json[r'emailSend'] as String?,
      registrationSend: json[r'registrationSend'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var accountEdit = this.accountEdit;
    var accountIndex = this.accountIndex;
    var accountTwoFactorDisable = this.accountTwoFactorDisable;
    var accountTwoFactorEnable = this.accountTwoFactorEnable;
    var accountTwoFactorIndex = this.accountTwoFactorIndex;
    var accountWebAuthnAdd = this.accountWebAuthnAdd;
    var accountWebAuthnDelete = this.accountWebAuthnDelete;
    var accountWebAuthnIndex = this.accountWebAuthnIndex;
    var confirmationRequired = this.confirmationRequired;
    var emailComplete = this.emailComplete;
    var emailSent = this.emailSent;
    var emailVerificationRequired = this.emailVerificationRequired;
    var emailVerify = this.emailVerify;
    var helpers = this.helpers;
    var index = this.index;
    var oauth2Authorize = this.oauth2Authorize;
    var oauth2AuthorizedNotRegistered = this.oauth2AuthorizedNotRegistered;
    var oauth2ChildRegistrationNotAllowed =
        this.oauth2ChildRegistrationNotAllowed;
    var oauth2ChildRegistrationNotAllowedComplete =
        this.oauth2ChildRegistrationNotAllowedComplete;
    var oauth2CompleteRegistration = this.oauth2CompleteRegistration;
    var oauth2Consent = this.oauth2Consent;
    var oauth2Device = this.oauth2Device;
    var oauth2DeviceComplete = this.oauth2DeviceComplete;
    var oauth2Error = this.oauth2Error;
    var oauth2Logout = this.oauth2Logout;
    var oauth2Passwordless = this.oauth2Passwordless;
    var oauth2Register = this.oauth2Register;
    var oauth2StartIdpLink = this.oauth2StartIdpLink;
    var oauth2TwoFactor = this.oauth2TwoFactor;
    var oauth2TwoFactorEnable = this.oauth2TwoFactorEnable;
    var oauth2TwoFactorEnableComplete = this.oauth2TwoFactorEnableComplete;
    var oauth2TwoFactorMethods = this.oauth2TwoFactorMethods;
    var oauth2Wait = this.oauth2Wait;
    var oauth2WebAuthn = this.oauth2WebAuthn;
    var oauth2WebAuthnReauth = this.oauth2WebAuthnReauth;
    var oauth2WebAuthnReauthEnable = this.oauth2WebAuthnReauthEnable;
    var passwordChange = this.passwordChange;
    var passwordComplete = this.passwordComplete;
    var passwordForgot = this.passwordForgot;
    var passwordSent = this.passwordSent;
    var registrationComplete = this.registrationComplete;
    var registrationSent = this.registrationSent;
    var registrationVerificationRequired =
        this.registrationVerificationRequired;
    var registrationVerify = this.registrationVerify;
    var samlv2Logout = this.samlv2Logout;
    var unauthorized = this.unauthorized;
    var emailSend = this.emailSend;
    var registrationSend = this.registrationSend;

    final json = <String, Object?>{};
    if (accountEdit != null) {
      json[r'accountEdit'] = accountEdit;
    }
    if (accountIndex != null) {
      json[r'accountIndex'] = accountIndex;
    }
    if (accountTwoFactorDisable != null) {
      json[r'accountTwoFactorDisable'] = accountTwoFactorDisable;
    }
    if (accountTwoFactorEnable != null) {
      json[r'accountTwoFactorEnable'] = accountTwoFactorEnable;
    }
    if (accountTwoFactorIndex != null) {
      json[r'accountTwoFactorIndex'] = accountTwoFactorIndex;
    }
    if (accountWebAuthnAdd != null) {
      json[r'accountWebAuthnAdd'] = accountWebAuthnAdd;
    }
    if (accountWebAuthnDelete != null) {
      json[r'accountWebAuthnDelete'] = accountWebAuthnDelete;
    }
    if (accountWebAuthnIndex != null) {
      json[r'accountWebAuthnIndex'] = accountWebAuthnIndex;
    }
    if (confirmationRequired != null) {
      json[r'confirmationRequired'] = confirmationRequired;
    }
    if (emailComplete != null) {
      json[r'emailComplete'] = emailComplete;
    }
    if (emailSent != null) {
      json[r'emailSent'] = emailSent;
    }
    if (emailVerificationRequired != null) {
      json[r'emailVerificationRequired'] = emailVerificationRequired;
    }
    if (emailVerify != null) {
      json[r'emailVerify'] = emailVerify;
    }
    if (helpers != null) {
      json[r'helpers'] = helpers;
    }
    if (index != null) {
      json[r'index'] = index;
    }
    if (oauth2Authorize != null) {
      json[r'oauth2Authorize'] = oauth2Authorize;
    }
    if (oauth2AuthorizedNotRegistered != null) {
      json[r'oauth2AuthorizedNotRegistered'] = oauth2AuthorizedNotRegistered;
    }
    if (oauth2ChildRegistrationNotAllowed != null) {
      json[r'oauth2ChildRegistrationNotAllowed'] =
          oauth2ChildRegistrationNotAllowed;
    }
    if (oauth2ChildRegistrationNotAllowedComplete != null) {
      json[r'oauth2ChildRegistrationNotAllowedComplete'] =
          oauth2ChildRegistrationNotAllowedComplete;
    }
    if (oauth2CompleteRegistration != null) {
      json[r'oauth2CompleteRegistration'] = oauth2CompleteRegistration;
    }
    if (oauth2Consent != null) {
      json[r'oauth2Consent'] = oauth2Consent;
    }
    if (oauth2Device != null) {
      json[r'oauth2Device'] = oauth2Device;
    }
    if (oauth2DeviceComplete != null) {
      json[r'oauth2DeviceComplete'] = oauth2DeviceComplete;
    }
    if (oauth2Error != null) {
      json[r'oauth2Error'] = oauth2Error;
    }
    if (oauth2Logout != null) {
      json[r'oauth2Logout'] = oauth2Logout;
    }
    if (oauth2Passwordless != null) {
      json[r'oauth2Passwordless'] = oauth2Passwordless;
    }
    if (oauth2Register != null) {
      json[r'oauth2Register'] = oauth2Register;
    }
    if (oauth2StartIdpLink != null) {
      json[r'oauth2StartIdPLink'] = oauth2StartIdpLink;
    }
    if (oauth2TwoFactor != null) {
      json[r'oauth2TwoFactor'] = oauth2TwoFactor;
    }
    if (oauth2TwoFactorEnable != null) {
      json[r'oauth2TwoFactorEnable'] = oauth2TwoFactorEnable;
    }
    if (oauth2TwoFactorEnableComplete != null) {
      json[r'oauth2TwoFactorEnableComplete'] = oauth2TwoFactorEnableComplete;
    }
    if (oauth2TwoFactorMethods != null) {
      json[r'oauth2TwoFactorMethods'] = oauth2TwoFactorMethods;
    }
    if (oauth2Wait != null) {
      json[r'oauth2Wait'] = oauth2Wait;
    }
    if (oauth2WebAuthn != null) {
      json[r'oauth2WebAuthn'] = oauth2WebAuthn;
    }
    if (oauth2WebAuthnReauth != null) {
      json[r'oauth2WebAuthnReauth'] = oauth2WebAuthnReauth;
    }
    if (oauth2WebAuthnReauthEnable != null) {
      json[r'oauth2WebAuthnReauthEnable'] = oauth2WebAuthnReauthEnable;
    }
    if (passwordChange != null) {
      json[r'passwordChange'] = passwordChange;
    }
    if (passwordComplete != null) {
      json[r'passwordComplete'] = passwordComplete;
    }
    if (passwordForgot != null) {
      json[r'passwordForgot'] = passwordForgot;
    }
    if (passwordSent != null) {
      json[r'passwordSent'] = passwordSent;
    }
    if (registrationComplete != null) {
      json[r'registrationComplete'] = registrationComplete;
    }
    if (registrationSent != null) {
      json[r'registrationSent'] = registrationSent;
    }
    if (registrationVerificationRequired != null) {
      json[r'registrationVerificationRequired'] =
          registrationVerificationRequired;
    }
    if (registrationVerify != null) {
      json[r'registrationVerify'] = registrationVerify;
    }
    if (samlv2Logout != null) {
      json[r'samlv2Logout'] = samlv2Logout;
    }
    if (unauthorized != null) {
      json[r'unauthorized'] = unauthorized;
    }
    if (emailSend != null) {
      json[r'emailSend'] = emailSend;
    }
    if (registrationSend != null) {
      json[r'registrationSend'] = registrationSend;
    }
    return json;
  }

  Templates copyWith(
      {String? accountEdit,
      String? accountIndex,
      String? accountTwoFactorDisable,
      String? accountTwoFactorEnable,
      String? accountTwoFactorIndex,
      String? accountWebAuthnAdd,
      String? accountWebAuthnDelete,
      String? accountWebAuthnIndex,
      String? confirmationRequired,
      String? emailComplete,
      String? emailSent,
      String? emailVerificationRequired,
      String? emailVerify,
      String? helpers,
      String? index,
      String? oauth2Authorize,
      String? oauth2AuthorizedNotRegistered,
      String? oauth2ChildRegistrationNotAllowed,
      String? oauth2ChildRegistrationNotAllowedComplete,
      String? oauth2CompleteRegistration,
      String? oauth2Consent,
      String? oauth2Device,
      String? oauth2DeviceComplete,
      String? oauth2Error,
      String? oauth2Logout,
      String? oauth2Passwordless,
      String? oauth2Register,
      String? oauth2StartIdpLink,
      String? oauth2TwoFactor,
      String? oauth2TwoFactorEnable,
      String? oauth2TwoFactorEnableComplete,
      String? oauth2TwoFactorMethods,
      String? oauth2Wait,
      String? oauth2WebAuthn,
      String? oauth2WebAuthnReauth,
      String? oauth2WebAuthnReauthEnable,
      String? passwordChange,
      String? passwordComplete,
      String? passwordForgot,
      String? passwordSent,
      String? registrationComplete,
      String? registrationSent,
      String? registrationVerificationRequired,
      String? registrationVerify,
      String? samlv2Logout,
      String? unauthorized,
      String? emailSend,
      String? registrationSend}) {
    return Templates(
      accountEdit: accountEdit ?? this.accountEdit,
      accountIndex: accountIndex ?? this.accountIndex,
      accountTwoFactorDisable:
          accountTwoFactorDisable ?? this.accountTwoFactorDisable,
      accountTwoFactorEnable:
          accountTwoFactorEnable ?? this.accountTwoFactorEnable,
      accountTwoFactorIndex:
          accountTwoFactorIndex ?? this.accountTwoFactorIndex,
      accountWebAuthnAdd: accountWebAuthnAdd ?? this.accountWebAuthnAdd,
      accountWebAuthnDelete:
          accountWebAuthnDelete ?? this.accountWebAuthnDelete,
      accountWebAuthnIndex: accountWebAuthnIndex ?? this.accountWebAuthnIndex,
      confirmationRequired: confirmationRequired ?? this.confirmationRequired,
      emailComplete: emailComplete ?? this.emailComplete,
      emailSent: emailSent ?? this.emailSent,
      emailVerificationRequired:
          emailVerificationRequired ?? this.emailVerificationRequired,
      emailVerify: emailVerify ?? this.emailVerify,
      helpers: helpers ?? this.helpers,
      index: index ?? this.index,
      oauth2Authorize: oauth2Authorize ?? this.oauth2Authorize,
      oauth2AuthorizedNotRegistered:
          oauth2AuthorizedNotRegistered ?? this.oauth2AuthorizedNotRegistered,
      oauth2ChildRegistrationNotAllowed: oauth2ChildRegistrationNotAllowed ??
          this.oauth2ChildRegistrationNotAllowed,
      oauth2ChildRegistrationNotAllowedComplete:
          oauth2ChildRegistrationNotAllowedComplete ??
              this.oauth2ChildRegistrationNotAllowedComplete,
      oauth2CompleteRegistration:
          oauth2CompleteRegistration ?? this.oauth2CompleteRegistration,
      oauth2Consent: oauth2Consent ?? this.oauth2Consent,
      oauth2Device: oauth2Device ?? this.oauth2Device,
      oauth2DeviceComplete: oauth2DeviceComplete ?? this.oauth2DeviceComplete,
      oauth2Error: oauth2Error ?? this.oauth2Error,
      oauth2Logout: oauth2Logout ?? this.oauth2Logout,
      oauth2Passwordless: oauth2Passwordless ?? this.oauth2Passwordless,
      oauth2Register: oauth2Register ?? this.oauth2Register,
      oauth2StartIdpLink: oauth2StartIdpLink ?? this.oauth2StartIdpLink,
      oauth2TwoFactor: oauth2TwoFactor ?? this.oauth2TwoFactor,
      oauth2TwoFactorEnable:
          oauth2TwoFactorEnable ?? this.oauth2TwoFactorEnable,
      oauth2TwoFactorEnableComplete:
          oauth2TwoFactorEnableComplete ?? this.oauth2TwoFactorEnableComplete,
      oauth2TwoFactorMethods:
          oauth2TwoFactorMethods ?? this.oauth2TwoFactorMethods,
      oauth2Wait: oauth2Wait ?? this.oauth2Wait,
      oauth2WebAuthn: oauth2WebAuthn ?? this.oauth2WebAuthn,
      oauth2WebAuthnReauth: oauth2WebAuthnReauth ?? this.oauth2WebAuthnReauth,
      oauth2WebAuthnReauthEnable:
          oauth2WebAuthnReauthEnable ?? this.oauth2WebAuthnReauthEnable,
      passwordChange: passwordChange ?? this.passwordChange,
      passwordComplete: passwordComplete ?? this.passwordComplete,
      passwordForgot: passwordForgot ?? this.passwordForgot,
      passwordSent: passwordSent ?? this.passwordSent,
      registrationComplete: registrationComplete ?? this.registrationComplete,
      registrationSent: registrationSent ?? this.registrationSent,
      registrationVerificationRequired: registrationVerificationRequired ??
          this.registrationVerificationRequired,
      registrationVerify: registrationVerify ?? this.registrationVerify,
      samlv2Logout: samlv2Logout ?? this.samlv2Logout,
      unauthorized: unauthorized ?? this.unauthorized,
      emailSend: emailSend ?? this.emailSend,
      registrationSend: registrationSend ?? this.registrationSend,
    );
  }
}

class Tenant {
  final Map<String, dynamic>? data;
  final TenantAccessControlConfiguration? accessControlConfiguration;
  final TenantCaptchaConfiguration? captchaConfiguration;
  final bool configured;
  final List<ConnectorPolicy> connectorPolicies;
  final EmailConfiguration? emailConfiguration;
  final EventConfiguration? eventConfiguration;
  final ExternalIdentifierConfiguration? externalIdentifierConfiguration;
  final FailedAuthenticationConfiguration? failedAuthenticationConfiguration;
  final FamilyConfiguration? familyConfiguration;
  final TenantFormConfiguration? formConfiguration;
  final int? httpSessionMaxInactiveInterval;
  final String? id;
  final ZonedDateTime? insertInstant;
  final String? issuer;
  final JWTConfiguration? jwtConfiguration;
  final TenantLambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final TenantLoginConfiguration? loginConfiguration;
  final String? logoutUrl;
  final MaximumPasswordAge? maximumPasswordAge;
  final MinimumPasswordAge? minimumPasswordAge;
  final TenantMultiFactorConfiguration? multiFactorConfiguration;
  final String? name;
  final TenantOAuth2Configuration? oauthConfiguration;
  final PasswordEncryptionConfiguration? passwordEncryptionConfiguration;
  final PasswordValidationRules? passwordValidationRules;
  final TenantRateLimitConfiguration? rateLimitConfiguration;
  final TenantRegistrationConfiguration? registrationConfiguration;
  final TenantSCIMServerConfiguration? scimServerConfiguration;
  final TenantSSOConfiguration? ssoConfiguration;
  final ObjectState? state;
  final String? themeId;
  final TenantUserDeletePolicy? userDeletePolicy;
  final TenantUsernameConfiguration? usernameConfiguration;
  final TenantWebAuthnConfiguration? webAuthnConfiguration;

  Tenant(
      {this.data,
      this.accessControlConfiguration,
      this.captchaConfiguration,
      bool? configured,
      List<ConnectorPolicy>? connectorPolicies,
      this.emailConfiguration,
      this.eventConfiguration,
      this.externalIdentifierConfiguration,
      this.failedAuthenticationConfiguration,
      this.familyConfiguration,
      this.formConfiguration,
      this.httpSessionMaxInactiveInterval,
      this.id,
      this.insertInstant,
      this.issuer,
      this.jwtConfiguration,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.loginConfiguration,
      this.logoutUrl,
      this.maximumPasswordAge,
      this.minimumPasswordAge,
      this.multiFactorConfiguration,
      this.name,
      this.oauthConfiguration,
      this.passwordEncryptionConfiguration,
      this.passwordValidationRules,
      this.rateLimitConfiguration,
      this.registrationConfiguration,
      this.scimServerConfiguration,
      this.ssoConfiguration,
      this.state,
      this.themeId,
      this.userDeletePolicy,
      this.usernameConfiguration,
      this.webAuthnConfiguration})
      : configured = configured ?? false,
        connectorPolicies = connectorPolicies ?? [];

  factory Tenant.fromJson(Map<String, Object?> json) {
    return Tenant(
      data: json[r'data'] as Map<String, Object?>?,
      accessControlConfiguration: json[r'accessControlConfiguration'] != null
          ? TenantAccessControlConfiguration.fromJson(
              json[r'accessControlConfiguration']! as Map<String, Object?>)
          : null,
      captchaConfiguration: json[r'captchaConfiguration'] != null
          ? TenantCaptchaConfiguration.fromJson(
              json[r'captchaConfiguration']! as Map<String, Object?>)
          : null,
      configured: json[r'configured'] as bool? ?? false,
      connectorPolicies: (json[r'connectorPolicies'] as List<Object?>?)
              ?.map((i) => ConnectorPolicy.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      emailConfiguration: json[r'emailConfiguration'] != null
          ? EmailConfiguration.fromJson(
              json[r'emailConfiguration']! as Map<String, Object?>)
          : null,
      eventConfiguration: json[r'eventConfiguration'] != null
          ? EventConfiguration.fromJson(
              json[r'eventConfiguration']! as Map<String, Object?>)
          : null,
      externalIdentifierConfiguration:
          json[r'externalIdentifierConfiguration'] != null
              ? ExternalIdentifierConfiguration.fromJson(
                  json[r'externalIdentifierConfiguration']!
                      as Map<String, Object?>)
              : null,
      failedAuthenticationConfiguration:
          json[r'failedAuthenticationConfiguration'] != null
              ? FailedAuthenticationConfiguration.fromJson(
                  json[r'failedAuthenticationConfiguration']!
                      as Map<String, Object?>)
              : null,
      familyConfiguration: json[r'familyConfiguration'] != null
          ? FamilyConfiguration.fromJson(
              json[r'familyConfiguration']! as Map<String, Object?>)
          : null,
      formConfiguration: json[r'formConfiguration'] != null
          ? TenantFormConfiguration.fromJson(
              json[r'formConfiguration']! as Map<String, Object?>)
          : null,
      httpSessionMaxInactiveInterval:
          (json[r'httpSessionMaxInactiveInterval'] as num?)?.toInt(),
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      issuer: json[r'issuer'] as String?,
      jwtConfiguration: json[r'jwtConfiguration'] != null
          ? JWTConfiguration.fromJson(
              json[r'jwtConfiguration']! as Map<String, Object?>)
          : null,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? TenantLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      loginConfiguration: json[r'loginConfiguration'] != null
          ? TenantLoginConfiguration.fromJson(
              json[r'loginConfiguration']! as Map<String, Object?>)
          : null,
      logoutUrl: json[r'logoutURL'] as String?,
      maximumPasswordAge: json[r'maximumPasswordAge'] != null
          ? MaximumPasswordAge.fromJson(
              json[r'maximumPasswordAge']! as Map<String, Object?>)
          : null,
      minimumPasswordAge: json[r'minimumPasswordAge'] != null
          ? MinimumPasswordAge.fromJson(
              json[r'minimumPasswordAge']! as Map<String, Object?>)
          : null,
      multiFactorConfiguration: json[r'multiFactorConfiguration'] != null
          ? TenantMultiFactorConfiguration.fromJson(
              json[r'multiFactorConfiguration']! as Map<String, Object?>)
          : null,
      name: json[r'name'] as String?,
      oauthConfiguration: json[r'oauthConfiguration'] != null
          ? TenantOAuth2Configuration.fromJson(
              json[r'oauthConfiguration']! as Map<String, Object?>)
          : null,
      passwordEncryptionConfiguration:
          json[r'passwordEncryptionConfiguration'] != null
              ? PasswordEncryptionConfiguration.fromJson(
                  json[r'passwordEncryptionConfiguration']!
                      as Map<String, Object?>)
              : null,
      passwordValidationRules: json[r'passwordValidationRules'] != null
          ? PasswordValidationRules.fromJson(
              json[r'passwordValidationRules']! as Map<String, Object?>)
          : null,
      rateLimitConfiguration: json[r'rateLimitConfiguration'] != null
          ? TenantRateLimitConfiguration.fromJson(
              json[r'rateLimitConfiguration']! as Map<String, Object?>)
          : null,
      registrationConfiguration: json[r'registrationConfiguration'] != null
          ? TenantRegistrationConfiguration.fromJson(
              json[r'registrationConfiguration']! as Map<String, Object?>)
          : null,
      scimServerConfiguration: json[r'scimServerConfiguration'] != null
          ? TenantSCIMServerConfiguration.fromJson(
              json[r'scimServerConfiguration']! as Map<String, Object?>)
          : null,
      ssoConfiguration: json[r'ssoConfiguration'] != null
          ? TenantSSOConfiguration.fromJson(
              json[r'ssoConfiguration']! as Map<String, Object?>)
          : null,
      state: json[r'state'] != null
          ? ObjectState.fromValue(json[r'state']! as String)
          : null,
      themeId: json[r'themeId'] as String?,
      userDeletePolicy: json[r'userDeletePolicy'] != null
          ? TenantUserDeletePolicy.fromJson(
              json[r'userDeletePolicy']! as Map<String, Object?>)
          : null,
      usernameConfiguration: json[r'usernameConfiguration'] != null
          ? TenantUsernameConfiguration.fromJson(
              json[r'usernameConfiguration']! as Map<String, Object?>)
          : null,
      webAuthnConfiguration: json[r'webAuthnConfiguration'] != null
          ? TenantWebAuthnConfiguration.fromJson(
              json[r'webAuthnConfiguration']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var accessControlConfiguration = this.accessControlConfiguration;
    var captchaConfiguration = this.captchaConfiguration;
    var configured = this.configured;
    var connectorPolicies = this.connectorPolicies;
    var emailConfiguration = this.emailConfiguration;
    var eventConfiguration = this.eventConfiguration;
    var externalIdentifierConfiguration = this.externalIdentifierConfiguration;
    var failedAuthenticationConfiguration =
        this.failedAuthenticationConfiguration;
    var familyConfiguration = this.familyConfiguration;
    var formConfiguration = this.formConfiguration;
    var httpSessionMaxInactiveInterval = this.httpSessionMaxInactiveInterval;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var issuer = this.issuer;
    var jwtConfiguration = this.jwtConfiguration;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var loginConfiguration = this.loginConfiguration;
    var logoutUrl = this.logoutUrl;
    var maximumPasswordAge = this.maximumPasswordAge;
    var minimumPasswordAge = this.minimumPasswordAge;
    var multiFactorConfiguration = this.multiFactorConfiguration;
    var name = this.name;
    var oauthConfiguration = this.oauthConfiguration;
    var passwordEncryptionConfiguration = this.passwordEncryptionConfiguration;
    var passwordValidationRules = this.passwordValidationRules;
    var rateLimitConfiguration = this.rateLimitConfiguration;
    var registrationConfiguration = this.registrationConfiguration;
    var scimServerConfiguration = this.scimServerConfiguration;
    var ssoConfiguration = this.ssoConfiguration;
    var state = this.state;
    var themeId = this.themeId;
    var userDeletePolicy = this.userDeletePolicy;
    var usernameConfiguration = this.usernameConfiguration;
    var webAuthnConfiguration = this.webAuthnConfiguration;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (accessControlConfiguration != null) {
      json[r'accessControlConfiguration'] = accessControlConfiguration.toJson();
    }
    if (captchaConfiguration != null) {
      json[r'captchaConfiguration'] = captchaConfiguration.toJson();
    }
    json[r'configured'] = configured;
    json[r'connectorPolicies'] =
        connectorPolicies.map((i) => i.toJson()).toList();
    if (emailConfiguration != null) {
      json[r'emailConfiguration'] = emailConfiguration.toJson();
    }
    if (eventConfiguration != null) {
      json[r'eventConfiguration'] = eventConfiguration.toJson();
    }
    if (externalIdentifierConfiguration != null) {
      json[r'externalIdentifierConfiguration'] =
          externalIdentifierConfiguration.toJson();
    }
    if (failedAuthenticationConfiguration != null) {
      json[r'failedAuthenticationConfiguration'] =
          failedAuthenticationConfiguration.toJson();
    }
    if (familyConfiguration != null) {
      json[r'familyConfiguration'] = familyConfiguration.toJson();
    }
    if (formConfiguration != null) {
      json[r'formConfiguration'] = formConfiguration.toJson();
    }
    if (httpSessionMaxInactiveInterval != null) {
      json[r'httpSessionMaxInactiveInterval'] = httpSessionMaxInactiveInterval;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (issuer != null) {
      json[r'issuer'] = issuer;
    }
    if (jwtConfiguration != null) {
      json[r'jwtConfiguration'] = jwtConfiguration.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (loginConfiguration != null) {
      json[r'loginConfiguration'] = loginConfiguration.toJson();
    }
    if (logoutUrl != null) {
      json[r'logoutURL'] = logoutUrl;
    }
    if (maximumPasswordAge != null) {
      json[r'maximumPasswordAge'] = maximumPasswordAge.toJson();
    }
    if (minimumPasswordAge != null) {
      json[r'minimumPasswordAge'] = minimumPasswordAge.toJson();
    }
    if (multiFactorConfiguration != null) {
      json[r'multiFactorConfiguration'] = multiFactorConfiguration.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (oauthConfiguration != null) {
      json[r'oauthConfiguration'] = oauthConfiguration.toJson();
    }
    if (passwordEncryptionConfiguration != null) {
      json[r'passwordEncryptionConfiguration'] =
          passwordEncryptionConfiguration.toJson();
    }
    if (passwordValidationRules != null) {
      json[r'passwordValidationRules'] = passwordValidationRules.toJson();
    }
    if (rateLimitConfiguration != null) {
      json[r'rateLimitConfiguration'] = rateLimitConfiguration.toJson();
    }
    if (registrationConfiguration != null) {
      json[r'registrationConfiguration'] = registrationConfiguration.toJson();
    }
    if (scimServerConfiguration != null) {
      json[r'scimServerConfiguration'] = scimServerConfiguration.toJson();
    }
    if (ssoConfiguration != null) {
      json[r'ssoConfiguration'] = ssoConfiguration.toJson();
    }
    if (state != null) {
      json[r'state'] = state.value;
    }
    if (themeId != null) {
      json[r'themeId'] = themeId;
    }
    if (userDeletePolicy != null) {
      json[r'userDeletePolicy'] = userDeletePolicy.toJson();
    }
    if (usernameConfiguration != null) {
      json[r'usernameConfiguration'] = usernameConfiguration.toJson();
    }
    if (webAuthnConfiguration != null) {
      json[r'webAuthnConfiguration'] = webAuthnConfiguration.toJson();
    }
    return json;
  }

  Tenant copyWith(
      {Map<String, dynamic>? data,
      TenantAccessControlConfiguration? accessControlConfiguration,
      TenantCaptchaConfiguration? captchaConfiguration,
      bool? configured,
      List<ConnectorPolicy>? connectorPolicies,
      EmailConfiguration? emailConfiguration,
      EventConfiguration? eventConfiguration,
      ExternalIdentifierConfiguration? externalIdentifierConfiguration,
      FailedAuthenticationConfiguration? failedAuthenticationConfiguration,
      FamilyConfiguration? familyConfiguration,
      TenantFormConfiguration? formConfiguration,
      int? httpSessionMaxInactiveInterval,
      String? id,
      ZonedDateTime? insertInstant,
      String? issuer,
      JWTConfiguration? jwtConfiguration,
      TenantLambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      TenantLoginConfiguration? loginConfiguration,
      String? logoutUrl,
      MaximumPasswordAge? maximumPasswordAge,
      MinimumPasswordAge? minimumPasswordAge,
      TenantMultiFactorConfiguration? multiFactorConfiguration,
      String? name,
      TenantOAuth2Configuration? oauthConfiguration,
      PasswordEncryptionConfiguration? passwordEncryptionConfiguration,
      PasswordValidationRules? passwordValidationRules,
      TenantRateLimitConfiguration? rateLimitConfiguration,
      TenantRegistrationConfiguration? registrationConfiguration,
      TenantSCIMServerConfiguration? scimServerConfiguration,
      TenantSSOConfiguration? ssoConfiguration,
      ObjectState? state,
      String? themeId,
      TenantUserDeletePolicy? userDeletePolicy,
      TenantUsernameConfiguration? usernameConfiguration,
      TenantWebAuthnConfiguration? webAuthnConfiguration}) {
    return Tenant(
      data: data ?? this.data,
      accessControlConfiguration:
          accessControlConfiguration ?? this.accessControlConfiguration,
      captchaConfiguration: captchaConfiguration ?? this.captchaConfiguration,
      configured: configured ?? this.configured,
      connectorPolicies: connectorPolicies ?? this.connectorPolicies,
      emailConfiguration: emailConfiguration ?? this.emailConfiguration,
      eventConfiguration: eventConfiguration ?? this.eventConfiguration,
      externalIdentifierConfiguration: externalIdentifierConfiguration ??
          this.externalIdentifierConfiguration,
      failedAuthenticationConfiguration: failedAuthenticationConfiguration ??
          this.failedAuthenticationConfiguration,
      familyConfiguration: familyConfiguration ?? this.familyConfiguration,
      formConfiguration: formConfiguration ?? this.formConfiguration,
      httpSessionMaxInactiveInterval:
          httpSessionMaxInactiveInterval ?? this.httpSessionMaxInactiveInterval,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      issuer: issuer ?? this.issuer,
      jwtConfiguration: jwtConfiguration ?? this.jwtConfiguration,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      loginConfiguration: loginConfiguration ?? this.loginConfiguration,
      logoutUrl: logoutUrl ?? this.logoutUrl,
      maximumPasswordAge: maximumPasswordAge ?? this.maximumPasswordAge,
      minimumPasswordAge: minimumPasswordAge ?? this.minimumPasswordAge,
      multiFactorConfiguration:
          multiFactorConfiguration ?? this.multiFactorConfiguration,
      name: name ?? this.name,
      oauthConfiguration: oauthConfiguration ?? this.oauthConfiguration,
      passwordEncryptionConfiguration: passwordEncryptionConfiguration ??
          this.passwordEncryptionConfiguration,
      passwordValidationRules:
          passwordValidationRules ?? this.passwordValidationRules,
      rateLimitConfiguration:
          rateLimitConfiguration ?? this.rateLimitConfiguration,
      registrationConfiguration:
          registrationConfiguration ?? this.registrationConfiguration,
      scimServerConfiguration:
          scimServerConfiguration ?? this.scimServerConfiguration,
      ssoConfiguration: ssoConfiguration ?? this.ssoConfiguration,
      state: state ?? this.state,
      themeId: themeId ?? this.themeId,
      userDeletePolicy: userDeletePolicy ?? this.userDeletePolicy,
      usernameConfiguration:
          usernameConfiguration ?? this.usernameConfiguration,
      webAuthnConfiguration:
          webAuthnConfiguration ?? this.webAuthnConfiguration,
    );
  }
}

class TenantAccessControlConfiguration {
  final String? uiIpAccessControlListId;

  TenantAccessControlConfiguration({this.uiIpAccessControlListId});

  factory TenantAccessControlConfiguration.fromJson(Map<String, Object?> json) {
    return TenantAccessControlConfiguration(
      uiIpAccessControlListId: json[r'uiIPAccessControlListId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var uiIpAccessControlListId = this.uiIpAccessControlListId;

    final json = <String, Object?>{};
    if (uiIpAccessControlListId != null) {
      json[r'uiIPAccessControlListId'] = uiIpAccessControlListId;
    }
    return json;
  }

  TenantAccessControlConfiguration copyWith({String? uiIpAccessControlListId}) {
    return TenantAccessControlConfiguration(
      uiIpAccessControlListId:
          uiIpAccessControlListId ?? this.uiIpAccessControlListId,
    );
  }
}

class TenantCaptchaConfiguration {
  final CaptchaMethod? captchaMethod;
  final String? secretKey;
  final String? siteKey;
  final num? threshold;
  final bool enabled;

  TenantCaptchaConfiguration(
      {this.captchaMethod,
      this.secretKey,
      this.siteKey,
      this.threshold,
      bool? enabled})
      : enabled = enabled ?? false;

  factory TenantCaptchaConfiguration.fromJson(Map<String, Object?> json) {
    return TenantCaptchaConfiguration(
      captchaMethod: json[r'captchaMethod'] != null
          ? CaptchaMethod.fromValue(json[r'captchaMethod']! as String)
          : null,
      secretKey: json[r'secretKey'] as String?,
      siteKey: json[r'siteKey'] as String?,
      threshold: json[r'threshold'] as num?,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var captchaMethod = this.captchaMethod;
    var secretKey = this.secretKey;
    var siteKey = this.siteKey;
    var threshold = this.threshold;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (captchaMethod != null) {
      json[r'captchaMethod'] = captchaMethod.value;
    }
    if (secretKey != null) {
      json[r'secretKey'] = secretKey;
    }
    if (siteKey != null) {
      json[r'siteKey'] = siteKey;
    }
    if (threshold != null) {
      json[r'threshold'] = threshold;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  TenantCaptchaConfiguration copyWith(
      {CaptchaMethod? captchaMethod,
      String? secretKey,
      String? siteKey,
      num? threshold,
      bool? enabled}) {
    return TenantCaptchaConfiguration(
      captchaMethod: captchaMethod ?? this.captchaMethod,
      secretKey: secretKey ?? this.secretKey,
      siteKey: siteKey ?? this.siteKey,
      threshold: threshold ?? this.threshold,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// Request for the Tenant API to delete a tenant rather than using the URL
/// parameters.
class TenantDeleteRequest {
  final bool async$;
  final EventInfo? eventInfo;

  TenantDeleteRequest({bool? async$, this.eventInfo})
      : async$ = async$ ?? false;

  factory TenantDeleteRequest.fromJson(Map<String, Object?> json) {
    return TenantDeleteRequest(
      async$: json[r'async'] as bool? ?? false,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var async$ = this.async$;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    json[r'async'] = async$;
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  TenantDeleteRequest copyWith({bool? async$, EventInfo? eventInfo}) {
    return TenantDeleteRequest(
      async$: async$ ?? this.async$,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

class TenantFormConfiguration {
  final String? adminUserFormId;

  TenantFormConfiguration({this.adminUserFormId});

  factory TenantFormConfiguration.fromJson(Map<String, Object?> json) {
    return TenantFormConfiguration(
      adminUserFormId: json[r'adminUserFormId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var adminUserFormId = this.adminUserFormId;

    final json = <String, Object?>{};
    if (adminUserFormId != null) {
      json[r'adminUserFormId'] = adminUserFormId;
    }
    return json;
  }

  TenantFormConfiguration copyWith({String? adminUserFormId}) {
    return TenantFormConfiguration(
      adminUserFormId: adminUserFormId ?? this.adminUserFormId,
    );
  }
}

class TenantLambdaConfiguration {
  final String? loginValidationId;
  final String? scimEnterpriseUserRequestConverterId;
  final String? scimEnterpriseUserResponseConverterId;
  final String? scimGroupRequestConverterId;
  final String? scimGroupResponseConverterId;
  final String? scimUserRequestConverterId;
  final String? scimUserResponseConverterId;

  TenantLambdaConfiguration(
      {this.loginValidationId,
      this.scimEnterpriseUserRequestConverterId,
      this.scimEnterpriseUserResponseConverterId,
      this.scimGroupRequestConverterId,
      this.scimGroupResponseConverterId,
      this.scimUserRequestConverterId,
      this.scimUserResponseConverterId});

  factory TenantLambdaConfiguration.fromJson(Map<String, Object?> json) {
    return TenantLambdaConfiguration(
      loginValidationId: json[r'loginValidationId'] as String?,
      scimEnterpriseUserRequestConverterId:
          json[r'scimEnterpriseUserRequestConverterId'] as String?,
      scimEnterpriseUserResponseConverterId:
          json[r'scimEnterpriseUserResponseConverterId'] as String?,
      scimGroupRequestConverterId:
          json[r'scimGroupRequestConverterId'] as String?,
      scimGroupResponseConverterId:
          json[r'scimGroupResponseConverterId'] as String?,
      scimUserRequestConverterId:
          json[r'scimUserRequestConverterId'] as String?,
      scimUserResponseConverterId:
          json[r'scimUserResponseConverterId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var loginValidationId = this.loginValidationId;
    var scimEnterpriseUserRequestConverterId =
        this.scimEnterpriseUserRequestConverterId;
    var scimEnterpriseUserResponseConverterId =
        this.scimEnterpriseUserResponseConverterId;
    var scimGroupRequestConverterId = this.scimGroupRequestConverterId;
    var scimGroupResponseConverterId = this.scimGroupResponseConverterId;
    var scimUserRequestConverterId = this.scimUserRequestConverterId;
    var scimUserResponseConverterId = this.scimUserResponseConverterId;

    final json = <String, Object?>{};
    if (loginValidationId != null) {
      json[r'loginValidationId'] = loginValidationId;
    }
    if (scimEnterpriseUserRequestConverterId != null) {
      json[r'scimEnterpriseUserRequestConverterId'] =
          scimEnterpriseUserRequestConverterId;
    }
    if (scimEnterpriseUserResponseConverterId != null) {
      json[r'scimEnterpriseUserResponseConverterId'] =
          scimEnterpriseUserResponseConverterId;
    }
    if (scimGroupRequestConverterId != null) {
      json[r'scimGroupRequestConverterId'] = scimGroupRequestConverterId;
    }
    if (scimGroupResponseConverterId != null) {
      json[r'scimGroupResponseConverterId'] = scimGroupResponseConverterId;
    }
    if (scimUserRequestConverterId != null) {
      json[r'scimUserRequestConverterId'] = scimUserRequestConverterId;
    }
    if (scimUserResponseConverterId != null) {
      json[r'scimUserResponseConverterId'] = scimUserResponseConverterId;
    }
    return json;
  }

  TenantLambdaConfiguration copyWith(
      {String? loginValidationId,
      String? scimEnterpriseUserRequestConverterId,
      String? scimEnterpriseUserResponseConverterId,
      String? scimGroupRequestConverterId,
      String? scimGroupResponseConverterId,
      String? scimUserRequestConverterId,
      String? scimUserResponseConverterId}) {
    return TenantLambdaConfiguration(
      loginValidationId: loginValidationId ?? this.loginValidationId,
      scimEnterpriseUserRequestConverterId:
          scimEnterpriseUserRequestConverterId ??
              this.scimEnterpriseUserRequestConverterId,
      scimEnterpriseUserResponseConverterId:
          scimEnterpriseUserResponseConverterId ??
              this.scimEnterpriseUserResponseConverterId,
      scimGroupRequestConverterId:
          scimGroupRequestConverterId ?? this.scimGroupRequestConverterId,
      scimGroupResponseConverterId:
          scimGroupResponseConverterId ?? this.scimGroupResponseConverterId,
      scimUserRequestConverterId:
          scimUserRequestConverterId ?? this.scimUserRequestConverterId,
      scimUserResponseConverterId:
          scimUserResponseConverterId ?? this.scimUserResponseConverterId,
    );
  }
}

class TenantLoginConfiguration {
  final bool requireAuthentication;

  TenantLoginConfiguration({bool? requireAuthentication})
      : requireAuthentication = requireAuthentication ?? false;

  factory TenantLoginConfiguration.fromJson(Map<String, Object?> json) {
    return TenantLoginConfiguration(
      requireAuthentication: json[r'requireAuthentication'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var requireAuthentication = this.requireAuthentication;

    final json = <String, Object?>{};
    json[r'requireAuthentication'] = requireAuthentication;
    return json;
  }

  TenantLoginConfiguration copyWith({bool? requireAuthentication}) {
    return TenantLoginConfiguration(
      requireAuthentication:
          requireAuthentication ?? this.requireAuthentication,
    );
  }
}

class TenantMultiFactorConfiguration {
  final MultiFactorAuthenticatorMethod? authenticator;
  final MultiFactorEmailMethod? email;
  final MultiFactorLoginPolicy? loginPolicy;
  final MultiFactorSMSMethod? sms;

  TenantMultiFactorConfiguration(
      {this.authenticator, this.email, this.loginPolicy, this.sms});

  factory TenantMultiFactorConfiguration.fromJson(Map<String, Object?> json) {
    return TenantMultiFactorConfiguration(
      authenticator: json[r'authenticator'] != null
          ? MultiFactorAuthenticatorMethod.fromJson(
              json[r'authenticator']! as Map<String, Object?>)
          : null,
      email: json[r'email'] != null
          ? MultiFactorEmailMethod.fromJson(
              json[r'email']! as Map<String, Object?>)
          : null,
      loginPolicy: json[r'loginPolicy'] != null
          ? MultiFactorLoginPolicy.fromValue(json[r'loginPolicy']! as String)
          : null,
      sms: json[r'sms'] != null
          ? MultiFactorSMSMethod.fromJson(json[r'sms']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var authenticator = this.authenticator;
    var email = this.email;
    var loginPolicy = this.loginPolicy;
    var sms = this.sms;

    final json = <String, Object?>{};
    if (authenticator != null) {
      json[r'authenticator'] = authenticator.toJson();
    }
    if (email != null) {
      json[r'email'] = email.toJson();
    }
    if (loginPolicy != null) {
      json[r'loginPolicy'] = loginPolicy.value;
    }
    if (sms != null) {
      json[r'sms'] = sms.toJson();
    }
    return json;
  }

  TenantMultiFactorConfiguration copyWith(
      {MultiFactorAuthenticatorMethod? authenticator,
      MultiFactorEmailMethod? email,
      MultiFactorLoginPolicy? loginPolicy,
      MultiFactorSMSMethod? sms}) {
    return TenantMultiFactorConfiguration(
      authenticator: authenticator ?? this.authenticator,
      email: email ?? this.email,
      loginPolicy: loginPolicy ?? this.loginPolicy,
      sms: sms ?? this.sms,
    );
  }
}

class TenantOAuth2Configuration {
  final String? clientCredentialsAccessTokenPopulateLambdaId;

  TenantOAuth2Configuration(
      {this.clientCredentialsAccessTokenPopulateLambdaId});

  factory TenantOAuth2Configuration.fromJson(Map<String, Object?> json) {
    return TenantOAuth2Configuration(
      clientCredentialsAccessTokenPopulateLambdaId:
          json[r'clientCredentialsAccessTokenPopulateLambdaId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var clientCredentialsAccessTokenPopulateLambdaId =
        this.clientCredentialsAccessTokenPopulateLambdaId;

    final json = <String, Object?>{};
    if (clientCredentialsAccessTokenPopulateLambdaId != null) {
      json[r'clientCredentialsAccessTokenPopulateLambdaId'] =
          clientCredentialsAccessTokenPopulateLambdaId;
    }
    return json;
  }

  TenantOAuth2Configuration copyWith(
      {String? clientCredentialsAccessTokenPopulateLambdaId}) {
    return TenantOAuth2Configuration(
      clientCredentialsAccessTokenPopulateLambdaId:
          clientCredentialsAccessTokenPopulateLambdaId ??
              this.clientCredentialsAccessTokenPopulateLambdaId,
    );
  }
}

class TenantRateLimitConfiguration {
  final RateLimitedRequestConfiguration? failedLogin;
  final RateLimitedRequestConfiguration? forgotPassword;
  final RateLimitedRequestConfiguration? sendEmailVerification;
  final RateLimitedRequestConfiguration? sendPasswordless;
  final RateLimitedRequestConfiguration? sendRegistrationVerification;
  final RateLimitedRequestConfiguration? sendTwoFactor;

  TenantRateLimitConfiguration(
      {this.failedLogin,
      this.forgotPassword,
      this.sendEmailVerification,
      this.sendPasswordless,
      this.sendRegistrationVerification,
      this.sendTwoFactor});

  factory TenantRateLimitConfiguration.fromJson(Map<String, Object?> json) {
    return TenantRateLimitConfiguration(
      failedLogin: json[r'failedLogin'] != null
          ? RateLimitedRequestConfiguration.fromJson(
              json[r'failedLogin']! as Map<String, Object?>)
          : null,
      forgotPassword: json[r'forgotPassword'] != null
          ? RateLimitedRequestConfiguration.fromJson(
              json[r'forgotPassword']! as Map<String, Object?>)
          : null,
      sendEmailVerification: json[r'sendEmailVerification'] != null
          ? RateLimitedRequestConfiguration.fromJson(
              json[r'sendEmailVerification']! as Map<String, Object?>)
          : null,
      sendPasswordless: json[r'sendPasswordless'] != null
          ? RateLimitedRequestConfiguration.fromJson(
              json[r'sendPasswordless']! as Map<String, Object?>)
          : null,
      sendRegistrationVerification: json[r'sendRegistrationVerification'] !=
              null
          ? RateLimitedRequestConfiguration.fromJson(
              json[r'sendRegistrationVerification']! as Map<String, Object?>)
          : null,
      sendTwoFactor: json[r'sendTwoFactor'] != null
          ? RateLimitedRequestConfiguration.fromJson(
              json[r'sendTwoFactor']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var failedLogin = this.failedLogin;
    var forgotPassword = this.forgotPassword;
    var sendEmailVerification = this.sendEmailVerification;
    var sendPasswordless = this.sendPasswordless;
    var sendRegistrationVerification = this.sendRegistrationVerification;
    var sendTwoFactor = this.sendTwoFactor;

    final json = <String, Object?>{};
    if (failedLogin != null) {
      json[r'failedLogin'] = failedLogin.toJson();
    }
    if (forgotPassword != null) {
      json[r'forgotPassword'] = forgotPassword.toJson();
    }
    if (sendEmailVerification != null) {
      json[r'sendEmailVerification'] = sendEmailVerification.toJson();
    }
    if (sendPasswordless != null) {
      json[r'sendPasswordless'] = sendPasswordless.toJson();
    }
    if (sendRegistrationVerification != null) {
      json[r'sendRegistrationVerification'] =
          sendRegistrationVerification.toJson();
    }
    if (sendTwoFactor != null) {
      json[r'sendTwoFactor'] = sendTwoFactor.toJson();
    }
    return json;
  }

  TenantRateLimitConfiguration copyWith(
      {RateLimitedRequestConfiguration? failedLogin,
      RateLimitedRequestConfiguration? forgotPassword,
      RateLimitedRequestConfiguration? sendEmailVerification,
      RateLimitedRequestConfiguration? sendPasswordless,
      RateLimitedRequestConfiguration? sendRegistrationVerification,
      RateLimitedRequestConfiguration? sendTwoFactor}) {
    return TenantRateLimitConfiguration(
      failedLogin: failedLogin ?? this.failedLogin,
      forgotPassword: forgotPassword ?? this.forgotPassword,
      sendEmailVerification:
          sendEmailVerification ?? this.sendEmailVerification,
      sendPasswordless: sendPasswordless ?? this.sendPasswordless,
      sendRegistrationVerification:
          sendRegistrationVerification ?? this.sendRegistrationVerification,
      sendTwoFactor: sendTwoFactor ?? this.sendTwoFactor,
    );
  }
}

class TenantRegistrationConfiguration {
  final List<dynamic> blockedDomains;

  TenantRegistrationConfiguration({List<dynamic>? blockedDomains})
      : blockedDomains = blockedDomains ?? [];

  factory TenantRegistrationConfiguration.fromJson(Map<String, Object?> json) {
    return TenantRegistrationConfiguration(
      blockedDomains:
          (json[r'blockedDomains'] as List<Object?>?)?.map((i) => i).toList() ??
              [],
    );
  }

  Map<String, Object?> toJson() {
    var blockedDomains = this.blockedDomains;

    final json = <String, Object?>{};
    json[r'blockedDomains'] = blockedDomains;
    return json;
  }

  TenantRegistrationConfiguration copyWith({List<dynamic>? blockedDomains}) {
    return TenantRegistrationConfiguration(
      blockedDomains: blockedDomains ?? this.blockedDomains,
    );
  }
}

class TenantRequest {
  final String? sourceTenantId;
  final Tenant? tenant;
  final List<String> webhookIds;
  final EventInfo? eventInfo;

  TenantRequest(
      {this.sourceTenantId,
      this.tenant,
      List<String>? webhookIds,
      this.eventInfo})
      : webhookIds = webhookIds ?? [];

  factory TenantRequest.fromJson(Map<String, Object?> json) {
    return TenantRequest(
      sourceTenantId: json[r'sourceTenantId'] as String?,
      tenant: json[r'tenant'] != null
          ? Tenant.fromJson(json[r'tenant']! as Map<String, Object?>)
          : null,
      webhookIds: (json[r'webhookIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var sourceTenantId = this.sourceTenantId;
    var tenant = this.tenant;
    var webhookIds = this.webhookIds;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (sourceTenantId != null) {
      json[r'sourceTenantId'] = sourceTenantId;
    }
    if (tenant != null) {
      json[r'tenant'] = tenant.toJson();
    }
    json[r'webhookIds'] = webhookIds;
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  TenantRequest copyWith(
      {String? sourceTenantId,
      Tenant? tenant,
      List<String>? webhookIds,
      EventInfo? eventInfo}) {
    return TenantRequest(
      sourceTenantId: sourceTenantId ?? this.sourceTenantId,
      tenant: tenant ?? this.tenant,
      webhookIds: webhookIds ?? this.webhookIds,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

class TenantResponse {
  final Tenant? tenant;
  final List<Tenant> tenants;

  TenantResponse({this.tenant, List<Tenant>? tenants})
      : tenants = tenants ?? [];

  factory TenantResponse.fromJson(Map<String, Object?> json) {
    return TenantResponse(
      tenant: json[r'tenant'] != null
          ? Tenant.fromJson(json[r'tenant']! as Map<String, Object?>)
          : null,
      tenants: (json[r'tenants'] as List<Object?>?)
              ?.map((i) =>
                  Tenant.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var tenant = this.tenant;
    var tenants = this.tenants;

    final json = <String, Object?>{};
    if (tenant != null) {
      json[r'tenant'] = tenant.toJson();
    }
    json[r'tenants'] = tenants.map((i) => i.toJson()).toList();
    return json;
  }

  TenantResponse copyWith({Tenant? tenant, List<Tenant>? tenants}) {
    return TenantResponse(
      tenant: tenant ?? this.tenant,
      tenants: tenants ?? this.tenants,
    );
  }
}

class TenantSCIMServerConfiguration {
  final String? clientEntityTypeId;
  final Map<String, dynamic>? schemas;
  final String? serverEntityTypeId;
  final bool enabled;

  TenantSCIMServerConfiguration(
      {this.clientEntityTypeId,
      this.schemas,
      this.serverEntityTypeId,
      bool? enabled})
      : enabled = enabled ?? false;

  factory TenantSCIMServerConfiguration.fromJson(Map<String, Object?> json) {
    return TenantSCIMServerConfiguration(
      clientEntityTypeId: json[r'clientEntityTypeId'] as String?,
      schemas: json[r'schemas'] as Map<String, Object?>?,
      serverEntityTypeId: json[r'serverEntityTypeId'] as String?,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var clientEntityTypeId = this.clientEntityTypeId;
    var schemas = this.schemas;
    var serverEntityTypeId = this.serverEntityTypeId;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (clientEntityTypeId != null) {
      json[r'clientEntityTypeId'] = clientEntityTypeId;
    }
    if (schemas != null) {
      json[r'schemas'] = schemas;
    }
    if (serverEntityTypeId != null) {
      json[r'serverEntityTypeId'] = serverEntityTypeId;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  TenantSCIMServerConfiguration copyWith(
      {String? clientEntityTypeId,
      Map<String, dynamic>? schemas,
      String? serverEntityTypeId,
      bool? enabled}) {
    return TenantSCIMServerConfiguration(
      clientEntityTypeId: clientEntityTypeId ?? this.clientEntityTypeId,
      schemas: schemas ?? this.schemas,
      serverEntityTypeId: serverEntityTypeId ?? this.serverEntityTypeId,
      enabled: enabled ?? this.enabled,
    );
  }
}

class TenantSSOConfiguration {
  final int? deviceTrustTimeToLiveInSeconds;

  TenantSSOConfiguration({this.deviceTrustTimeToLiveInSeconds});

  factory TenantSSOConfiguration.fromJson(Map<String, Object?> json) {
    return TenantSSOConfiguration(
      deviceTrustTimeToLiveInSeconds:
          (json[r'deviceTrustTimeToLiveInSeconds'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var deviceTrustTimeToLiveInSeconds = this.deviceTrustTimeToLiveInSeconds;

    final json = <String, Object?>{};
    if (deviceTrustTimeToLiveInSeconds != null) {
      json[r'deviceTrustTimeToLiveInSeconds'] = deviceTrustTimeToLiveInSeconds;
    }
    return json;
  }

  TenantSSOConfiguration copyWith({int? deviceTrustTimeToLiveInSeconds}) {
    return TenantSSOConfiguration(
      deviceTrustTimeToLiveInSeconds:
          deviceTrustTimeToLiveInSeconds ?? this.deviceTrustTimeToLiveInSeconds,
    );
  }
}

/// Search criteria for Tenants
class TenantSearchCriteria {
  final String? name;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  TenantSearchCriteria(
      {this.name, this.numberOfResults, this.orderBy, this.startRow});

  factory TenantSearchCriteria.fromJson(Map<String, Object?> json) {
    return TenantSearchCriteria(
      name: json[r'name'] as String?,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  TenantSearchCriteria copyWith(
      {String? name, int? numberOfResults, String? orderBy, int? startRow}) {
    return TenantSearchCriteria(
      name: name ?? this.name,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Search request for Tenants
class TenantSearchRequest {
  final TenantSearchCriteria? search;

  TenantSearchRequest({this.search});

  factory TenantSearchRequest.fromJson(Map<String, Object?> json) {
    return TenantSearchRequest(
      search: json[r'search'] != null
          ? TenantSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  TenantSearchRequest copyWith({TenantSearchCriteria? search}) {
    return TenantSearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Tenant search response
class TenantSearchResponse {
  final List<Tenant> tenants;
  final int? total;

  TenantSearchResponse({List<Tenant>? tenants, this.total})
      : tenants = tenants ?? [];

  factory TenantSearchResponse.fromJson(Map<String, Object?> json) {
    return TenantSearchResponse(
      tenants: (json[r'tenants'] as List<Object?>?)
              ?.map((i) =>
                  Tenant.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var tenants = this.tenants;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'tenants'] = tenants.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  TenantSearchResponse copyWith({List<Tenant>? tenants, int? total}) {
    return TenantSearchResponse(
      tenants: tenants ?? this.tenants,
      total: total ?? this.total,
    );
  }
}

class TenantUnverifiedConfiguration {
  final UnverifiedBehavior? email;
  final RegistrationUnverifiedOptions? whenGated;

  TenantUnverifiedConfiguration({this.email, this.whenGated});

  factory TenantUnverifiedConfiguration.fromJson(Map<String, Object?> json) {
    return TenantUnverifiedConfiguration(
      email: json[r'email'] != null
          ? UnverifiedBehavior.fromValue(json[r'email']! as String)
          : null,
      whenGated: json[r'whenGated'] != null
          ? RegistrationUnverifiedOptions.fromJson(
              json[r'whenGated']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var email = this.email;
    var whenGated = this.whenGated;

    final json = <String, Object?>{};
    if (email != null) {
      json[r'email'] = email.value;
    }
    if (whenGated != null) {
      json[r'whenGated'] = whenGated.toJson();
    }
    return json;
  }

  TenantUnverifiedConfiguration copyWith(
      {UnverifiedBehavior? email, RegistrationUnverifiedOptions? whenGated}) {
    return TenantUnverifiedConfiguration(
      email: email ?? this.email,
      whenGated: whenGated ?? this.whenGated,
    );
  }
}

/// A Tenant-level policy for deleting Users.
class TenantUserDeletePolicy {
  final TimeBasedDeletePolicy? unverified;

  TenantUserDeletePolicy({this.unverified});

  factory TenantUserDeletePolicy.fromJson(Map<String, Object?> json) {
    return TenantUserDeletePolicy(
      unverified: json[r'unverified'] != null
          ? TimeBasedDeletePolicy.fromJson(
              json[r'unverified']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var unverified = this.unverified;

    final json = <String, Object?>{};
    if (unverified != null) {
      json[r'unverified'] = unverified.toJson();
    }
    return json;
  }

  TenantUserDeletePolicy copyWith({TimeBasedDeletePolicy? unverified}) {
    return TenantUserDeletePolicy(
      unverified: unverified ?? this.unverified,
    );
  }
}

class TenantUsernameConfiguration {
  final UniqueUsernameConfiguration? unique;

  TenantUsernameConfiguration({this.unique});

  factory TenantUsernameConfiguration.fromJson(Map<String, Object?> json) {
    return TenantUsernameConfiguration(
      unique: json[r'unique'] != null
          ? UniqueUsernameConfiguration.fromJson(
              json[r'unique']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var unique = this.unique;

    final json = <String, Object?>{};
    if (unique != null) {
      json[r'unique'] = unique.toJson();
    }
    return json;
  }

  TenantUsernameConfiguration copyWith({UniqueUsernameConfiguration? unique}) {
    return TenantUsernameConfiguration(
      unique: unique ?? this.unique,
    );
  }
}

/// Tenant-level configuration for WebAuthn
class TenantWebAuthnConfiguration {
  final TenantWebAuthnWorkflowConfiguration? bootstrapWorkflow;
  final bool debug;
  final TenantWebAuthnWorkflowConfiguration? reauthenticationWorkflow;
  final String? relyingPartyId;
  final String? relyingPartyName;
  final bool enabled;

  TenantWebAuthnConfiguration(
      {this.bootstrapWorkflow,
      bool? debug,
      this.reauthenticationWorkflow,
      this.relyingPartyId,
      this.relyingPartyName,
      bool? enabled})
      : debug = debug ?? false,
        enabled = enabled ?? false;

  factory TenantWebAuthnConfiguration.fromJson(Map<String, Object?> json) {
    return TenantWebAuthnConfiguration(
      bootstrapWorkflow: json[r'bootstrapWorkflow'] != null
          ? TenantWebAuthnWorkflowConfiguration.fromJson(
              json[r'bootstrapWorkflow']! as Map<String, Object?>)
          : null,
      debug: json[r'debug'] as bool? ?? false,
      reauthenticationWorkflow: json[r'reauthenticationWorkflow'] != null
          ? TenantWebAuthnWorkflowConfiguration.fromJson(
              json[r'reauthenticationWorkflow']! as Map<String, Object?>)
          : null,
      relyingPartyId: json[r'relyingPartyId'] as String?,
      relyingPartyName: json[r'relyingPartyName'] as String?,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var bootstrapWorkflow = this.bootstrapWorkflow;
    var debug = this.debug;
    var reauthenticationWorkflow = this.reauthenticationWorkflow;
    var relyingPartyId = this.relyingPartyId;
    var relyingPartyName = this.relyingPartyName;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (bootstrapWorkflow != null) {
      json[r'bootstrapWorkflow'] = bootstrapWorkflow.toJson();
    }
    json[r'debug'] = debug;
    if (reauthenticationWorkflow != null) {
      json[r'reauthenticationWorkflow'] = reauthenticationWorkflow.toJson();
    }
    if (relyingPartyId != null) {
      json[r'relyingPartyId'] = relyingPartyId;
    }
    if (relyingPartyName != null) {
      json[r'relyingPartyName'] = relyingPartyName;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  TenantWebAuthnConfiguration copyWith(
      {TenantWebAuthnWorkflowConfiguration? bootstrapWorkflow,
      bool? debug,
      TenantWebAuthnWorkflowConfiguration? reauthenticationWorkflow,
      String? relyingPartyId,
      String? relyingPartyName,
      bool? enabled}) {
    return TenantWebAuthnConfiguration(
      bootstrapWorkflow: bootstrapWorkflow ?? this.bootstrapWorkflow,
      debug: debug ?? this.debug,
      reauthenticationWorkflow:
          reauthenticationWorkflow ?? this.reauthenticationWorkflow,
      relyingPartyId: relyingPartyId ?? this.relyingPartyId,
      relyingPartyName: relyingPartyName ?? this.relyingPartyName,
      enabled: enabled ?? this.enabled,
    );
  }
}

class TenantWebAuthnWorkflowConfiguration {
  final AuthenticatorAttachmentPreference? authenticatorAttachmentPreference;
  final UserVerificationRequirement? userVerificationRequirement;
  final bool enabled;

  TenantWebAuthnWorkflowConfiguration(
      {this.authenticatorAttachmentPreference,
      this.userVerificationRequirement,
      bool? enabled})
      : enabled = enabled ?? false;

  factory TenantWebAuthnWorkflowConfiguration.fromJson(
      Map<String, Object?> json) {
    return TenantWebAuthnWorkflowConfiguration(
      authenticatorAttachmentPreference:
          json[r'authenticatorAttachmentPreference'] != null
              ? AuthenticatorAttachmentPreference.fromValue(
                  json[r'authenticatorAttachmentPreference']! as String)
              : null,
      userVerificationRequirement: json[r'userVerificationRequirement'] != null
          ? UserVerificationRequirement.fromValue(
              json[r'userVerificationRequirement']! as String)
          : null,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var authenticatorAttachmentPreference =
        this.authenticatorAttachmentPreference;
    var userVerificationRequirement = this.userVerificationRequirement;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (authenticatorAttachmentPreference != null) {
      json[r'authenticatorAttachmentPreference'] =
          authenticatorAttachmentPreference.value;
    }
    if (userVerificationRequirement != null) {
      json[r'userVerificationRequirement'] = userVerificationRequirement.value;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  TenantWebAuthnWorkflowConfiguration copyWith(
      {AuthenticatorAttachmentPreference? authenticatorAttachmentPreference,
      UserVerificationRequirement? userVerificationRequirement,
      bool? enabled}) {
    return TenantWebAuthnWorkflowConfiguration(
      authenticatorAttachmentPreference: authenticatorAttachmentPreference ??
          this.authenticatorAttachmentPreference,
      userVerificationRequirement:
          userVerificationRequirement ?? this.userVerificationRequirement,
      enabled: enabled ?? this.enabled,
    );
  }
}

class Tenantable {
  Tenantable();

  factory Tenantable.fromJson(Map<String, Object?> json) {
    return Tenantable();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class TestEvent {
  final String? message;
  final ZonedDateTime? createInstant;
  final String? id;
  final EventInfo? info;
  final String? tenantId;
  final EventType? type;

  TestEvent(
      {this.message,
      this.createInstant,
      this.id,
      this.info,
      this.tenantId,
      this.type});

  factory TestEvent.fromJson(Map<String, Object?> json) {
    return TestEvent(
      message: json[r'message'] as String?,
      createInstant:
          (json[r'createInstant'] as num?)?.toInt() as ZonedDateTime?,
      id: json[r'id'] as String?,
      info: json[r'info'] != null
          ? EventInfo.fromJson(json[r'info']! as Map<String, Object?>)
          : null,
      tenantId: json[r'tenantId'] as String?,
      type: json[r'type'] != null
          ? EventType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var message = this.message;
    var createInstant = this.createInstant;
    var id = this.id;
    var info = this.info;
    var tenantId = this.tenantId;
    var type = this.type;

    final json = <String, Object?>{};
    if (message != null) {
      json[r'message'] = message;
    }
    if (createInstant != null) {
      json[r'createInstant'] = createInstant.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (info != null) {
      json[r'info'] = info.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  TestEvent copyWith(
      {String? message,
      ZonedDateTime? createInstant,
      String? id,
      EventInfo? info,
      String? tenantId,
      EventType? type}) {
    return TestEvent(
      message: message ?? this.message,
      createInstant: createInstant ?? this.createInstant,
      id: id ?? this.id,
      info: info ?? this.info,
      tenantId: tenantId ?? this.tenantId,
      type: type ?? this.type,
    );
  }
}

class Theme {
  final Map<String, dynamic>? data;
  final String? defaultMessages;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final LocalizedStrings? localizedMessages;
  final String? name;
  final String? stylesheet;
  final Templates? templates;
  final ThemeType? type;
  final SimpleThemeVariables? variables;

  Theme(
      {this.data,
      this.defaultMessages,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.localizedMessages,
      this.name,
      this.stylesheet,
      this.templates,
      this.type,
      this.variables});

  factory Theme.fromJson(Map<String, Object?> json) {
    return Theme(
      data: json[r'data'] as Map<String, Object?>?,
      defaultMessages: json[r'defaultMessages'] as String?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      localizedMessages: json[r'localizedMessages'] != null
          ? LocalizedStrings.fromJson(
              json[r'localizedMessages']! as Map<String, Object?>)
          : null,
      name: json[r'name'] as String?,
      stylesheet: json[r'stylesheet'] as String?,
      templates: json[r'templates'] != null
          ? Templates.fromJson(json[r'templates']! as Map<String, Object?>)
          : null,
      type: json[r'type'] != null
          ? ThemeType.fromValue(json[r'type']! as String)
          : null,
      variables: json[r'variables'] != null
          ? SimpleThemeVariables.fromJson(
              json[r'variables']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var defaultMessages = this.defaultMessages;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var localizedMessages = this.localizedMessages;
    var name = this.name;
    var stylesheet = this.stylesheet;
    var templates = this.templates;
    var type = this.type;
    var variables = this.variables;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (defaultMessages != null) {
      json[r'defaultMessages'] = defaultMessages;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (localizedMessages != null) {
      json[r'localizedMessages'] = localizedMessages.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (stylesheet != null) {
      json[r'stylesheet'] = stylesheet;
    }
    if (templates != null) {
      json[r'templates'] = templates.toJson();
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    if (variables != null) {
      json[r'variables'] = variables.toJson();
    }
    return json;
  }

  Theme copyWith(
      {Map<String, dynamic>? data,
      String? defaultMessages,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      LocalizedStrings? localizedMessages,
      String? name,
      String? stylesheet,
      Templates? templates,
      ThemeType? type,
      SimpleThemeVariables? variables}) {
    return Theme(
      data: data ?? this.data,
      defaultMessages: defaultMessages ?? this.defaultMessages,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      localizedMessages: localizedMessages ?? this.localizedMessages,
      name: name ?? this.name,
      stylesheet: stylesheet ?? this.stylesheet,
      templates: templates ?? this.templates,
      type: type ?? this.type,
      variables: variables ?? this.variables,
    );
  }
}

/// Theme API request object.
class ThemeRequest {
  final String? sourceThemeId;
  final Theme? theme;

  ThemeRequest({this.sourceThemeId, this.theme});

  factory ThemeRequest.fromJson(Map<String, Object?> json) {
    return ThemeRequest(
      sourceThemeId: json[r'sourceThemeId'] as String?,
      theme: json[r'theme'] != null
          ? Theme.fromJson(json[r'theme']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var sourceThemeId = this.sourceThemeId;
    var theme = this.theme;

    final json = <String, Object?>{};
    if (sourceThemeId != null) {
      json[r'sourceThemeId'] = sourceThemeId;
    }
    if (theme != null) {
      json[r'theme'] = theme.toJson();
    }
    return json;
  }

  ThemeRequest copyWith({String? sourceThemeId, Theme? theme}) {
    return ThemeRequest(
      sourceThemeId: sourceThemeId ?? this.sourceThemeId,
      theme: theme ?? this.theme,
    );
  }
}

/// Theme API response object.
class ThemeResponse {
  final Theme? theme;
  final List<Theme> themes;

  ThemeResponse({this.theme, List<Theme>? themes}) : themes = themes ?? [];

  factory ThemeResponse.fromJson(Map<String, Object?> json) {
    return ThemeResponse(
      theme: json[r'theme'] != null
          ? Theme.fromJson(json[r'theme']! as Map<String, Object?>)
          : null,
      themes: (json[r'themes'] as List<Object?>?)
              ?.map(
                  (i) => Theme.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var theme = this.theme;
    var themes = this.themes;

    final json = <String, Object?>{};
    if (theme != null) {
      json[r'theme'] = theme.toJson();
    }
    json[r'themes'] = themes.map((i) => i.toJson()).toList();
    return json;
  }

  ThemeResponse copyWith({Theme? theme, List<Theme>? themes}) {
    return ThemeResponse(
      theme: theme ?? this.theme,
      themes: themes ?? this.themes,
    );
  }
}

/// Search criteria for themes
class ThemeSearchCriteria {
  final String? name;
  final ThemeType? type;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  ThemeSearchCriteria(
      {this.name,
      this.type,
      this.numberOfResults,
      this.orderBy,
      this.startRow});

  factory ThemeSearchCriteria.fromJson(Map<String, Object?> json) {
    return ThemeSearchCriteria(
      name: json[r'name'] as String?,
      type: json[r'type'] != null
          ? ThemeType.fromValue(json[r'type']! as String)
          : null,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var type = this.type;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  ThemeSearchCriteria copyWith(
      {String? name,
      ThemeType? type,
      int? numberOfResults,
      String? orderBy,
      int? startRow}) {
    return ThemeSearchCriteria(
      name: name ?? this.name,
      type: type ?? this.type,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Search request for Themes.
class ThemeSearchRequest {
  final ThemeSearchCriteria? search;

  ThemeSearchRequest({this.search});

  factory ThemeSearchRequest.fromJson(Map<String, Object?> json) {
    return ThemeSearchRequest(
      search: json[r'search'] != null
          ? ThemeSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  ThemeSearchRequest copyWith({ThemeSearchCriteria? search}) {
    return ThemeSearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Search response for Themes
class ThemeSearchResponse {
  final List<Theme> themes;
  final int? total;

  ThemeSearchResponse({List<Theme>? themes, this.total})
      : themes = themes ?? [];

  factory ThemeSearchResponse.fromJson(Map<String, Object?> json) {
    return ThemeSearchResponse(
      themes: (json[r'themes'] as List<Object?>?)
              ?.map(
                  (i) => Theme.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var themes = this.themes;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'themes'] = themes.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  ThemeSearchResponse copyWith({List<Theme>? themes, int? total}) {
    return ThemeSearchResponse(
      themes: themes ?? this.themes,
      total: total ?? this.total,
    );
  }
}

/// A policy for deleting Users based upon some external criteria.
class TimeBasedDeletePolicy {
  final ZonedDateTime? enabledInstant;
  final int? numberOfDaysToRetain;
  final bool enabled;

  TimeBasedDeletePolicy(
      {this.enabledInstant, this.numberOfDaysToRetain, bool? enabled})
      : enabled = enabled ?? false;

  factory TimeBasedDeletePolicy.fromJson(Map<String, Object?> json) {
    return TimeBasedDeletePolicy(
      enabledInstant:
          (json[r'enabledInstant'] as num?)?.toInt() as ZonedDateTime?,
      numberOfDaysToRetain: (json[r'numberOfDaysToRetain'] as num?)?.toInt(),
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var enabledInstant = this.enabledInstant;
    var numberOfDaysToRetain = this.numberOfDaysToRetain;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (enabledInstant != null) {
      json[r'enabledInstant'] = enabledInstant.toJson();
    }
    if (numberOfDaysToRetain != null) {
      json[r'numberOfDaysToRetain'] = numberOfDaysToRetain;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  TimeBasedDeletePolicy copyWith(
      {ZonedDateTime? enabledInstant,
      int? numberOfDaysToRetain,
      bool? enabled}) {
    return TimeBasedDeletePolicy(
      enabledInstant: enabledInstant ?? this.enabledInstant,
      numberOfDaysToRetain: numberOfDaysToRetain ?? this.numberOfDaysToRetain,
      enabled: enabled ?? this.enabled,
    );
  }
}

class Totals {
  final int? logins;
  final int? registrations;
  final int? totalRegistrations;

  Totals({this.logins, this.registrations, this.totalRegistrations});

  factory Totals.fromJson(Map<String, Object?> json) {
    return Totals(
      logins: (json[r'logins'] as num?)?.toInt(),
      registrations: (json[r'registrations'] as num?)?.toInt(),
      totalRegistrations: (json[r'totalRegistrations'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var logins = this.logins;
    var registrations = this.registrations;
    var totalRegistrations = this.totalRegistrations;

    final json = <String, Object?>{};
    if (logins != null) {
      json[r'logins'] = logins;
    }
    if (registrations != null) {
      json[r'registrations'] = registrations;
    }
    if (totalRegistrations != null) {
      json[r'totalRegistrations'] = totalRegistrations;
    }
    return json;
  }

  Totals copyWith({int? logins, int? registrations, int? totalRegistrations}) {
    return Totals(
      logins: logins ?? this.logins,
      registrations: registrations ?? this.registrations,
      totalRegistrations: totalRegistrations ?? this.totalRegistrations,
    );
  }
}

/// The response from the total report. This report stores the total numbers for
/// each application.
class TotalsReportResponse {
  final Map<String, dynamic>? applicationTotals;
  final int? globalRegistrations;
  final int? totalGlobalRegistrations;

  TotalsReportResponse(
      {this.applicationTotals,
      this.globalRegistrations,
      this.totalGlobalRegistrations});

  factory TotalsReportResponse.fromJson(Map<String, Object?> json) {
    return TotalsReportResponse(
      applicationTotals: json[r'applicationTotals'] as Map<String, Object?>?,
      globalRegistrations: (json[r'globalRegistrations'] as num?)?.toInt(),
      totalGlobalRegistrations:
          (json[r'totalGlobalRegistrations'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var applicationTotals = this.applicationTotals;
    var globalRegistrations = this.globalRegistrations;
    var totalGlobalRegistrations = this.totalGlobalRegistrations;

    final json = <String, Object?>{};
    if (applicationTotals != null) {
      json[r'applicationTotals'] = applicationTotals;
    }
    if (globalRegistrations != null) {
      json[r'globalRegistrations'] = globalRegistrations;
    }
    if (totalGlobalRegistrations != null) {
      json[r'totalGlobalRegistrations'] = totalGlobalRegistrations;
    }
    return json;
  }

  TotalsReportResponse copyWith(
      {Map<String, dynamic>? applicationTotals,
      int? globalRegistrations,
      int? totalGlobalRegistrations}) {
    return TotalsReportResponse(
      applicationTotals: applicationTotals ?? this.applicationTotals,
      globalRegistrations: globalRegistrations ?? this.globalRegistrations,
      totalGlobalRegistrations:
          totalGlobalRegistrations ?? this.totalGlobalRegistrations,
    );
  }
}

class TwilioMessengerConfiguration {
  final String? accountSid;
  final String? authToken;
  final String? fromPhoneNumber;
  final String? messagingServiceSid;
  final String? url;
  final Map<String, dynamic>? data;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? name;
  final String? transport;
  final MessengerType? type;

  TwilioMessengerConfiguration(
      {this.accountSid,
      this.authToken,
      this.fromPhoneNumber,
      this.messagingServiceSid,
      this.url,
      this.data,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.name,
      this.transport,
      this.type})
      : debug = debug ?? false;

  factory TwilioMessengerConfiguration.fromJson(Map<String, Object?> json) {
    return TwilioMessengerConfiguration(
      accountSid: json[r'accountSID'] as String?,
      authToken: json[r'authToken'] as String?,
      fromPhoneNumber: json[r'fromPhoneNumber'] as String?,
      messagingServiceSid: json[r'messagingServiceSid'] as String?,
      url: json[r'url'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      transport: json[r'transport'] as String?,
      type: json[r'type'] != null
          ? MessengerType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var accountSid = this.accountSid;
    var authToken = this.authToken;
    var fromPhoneNumber = this.fromPhoneNumber;
    var messagingServiceSid = this.messagingServiceSid;
    var url = this.url;
    var data = this.data;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var name = this.name;
    var transport = this.transport;
    var type = this.type;

    final json = <String, Object?>{};
    if (accountSid != null) {
      json[r'accountSID'] = accountSid;
    }
    if (authToken != null) {
      json[r'authToken'] = authToken;
    }
    if (fromPhoneNumber != null) {
      json[r'fromPhoneNumber'] = fromPhoneNumber;
    }
    if (messagingServiceSid != null) {
      json[r'messagingServiceSid'] = messagingServiceSid;
    }
    if (url != null) {
      json[r'url'] = url;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (transport != null) {
      json[r'transport'] = transport;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  TwilioMessengerConfiguration copyWith(
      {String? accountSid,
      String? authToken,
      String? fromPhoneNumber,
      String? messagingServiceSid,
      String? url,
      Map<String, dynamic>? data,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      String? name,
      String? transport,
      MessengerType? type}) {
    return TwilioMessengerConfiguration(
      accountSid: accountSid ?? this.accountSid,
      authToken: authToken ?? this.authToken,
      fromPhoneNumber: fromPhoneNumber ?? this.fromPhoneNumber,
      messagingServiceSid: messagingServiceSid ?? this.messagingServiceSid,
      url: url ?? this.url,
      data: data ?? this.data,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      name: name ?? this.name,
      transport: transport ?? this.transport,
      type: type ?? this.type,
    );
  }
}

class TwitchApplicationConfiguration {
  final String? buttonText;
  final String? clientId;
  final String? clientSecret;
  final String? scope;
  final Map<String, dynamic>? data;
  final bool createRegistration;

  TwitchApplicationConfiguration(
      {this.buttonText,
      this.clientId,
      this.clientSecret,
      this.scope,
      this.data,
      bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory TwitchApplicationConfiguration.fromJson(Map<String, Object?> json) {
    return TwitchApplicationConfiguration(
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      scope: json[r'scope'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var scope = this.scope;
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  TwitchApplicationConfiguration copyWith(
      {String? buttonText,
      String? clientId,
      String? clientSecret,
      String? scope,
      Map<String, dynamic>? data,
      bool? createRegistration}) {
    return TwitchApplicationConfiguration(
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      scope: scope ?? this.scope,
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

/// Twitch gaming login provider.
class TwitchIdentityProvider {
  final String? buttonText;
  final String? clientId;
  final String? clientSecret;
  final String? scope;
  final Map<String, dynamic>? data;
  final Map<String, dynamic>? applicationConfiguration;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ProviderLambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final IdentityProviderLinkingStrategy? linkingStrategy;
  final String? name;
  final Map<String, dynamic>? tenantConfiguration;
  final IdentityProviderType? type;

  TwitchIdentityProvider(
      {this.buttonText,
      this.clientId,
      this.clientSecret,
      this.scope,
      this.data,
      this.applicationConfiguration,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.linkingStrategy,
      this.name,
      this.tenantConfiguration,
      this.type})
      : debug = debug ?? false;

  factory TwitchIdentityProvider.fromJson(Map<String, Object?> json) {
    return TwitchIdentityProvider(
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      scope: json[r'scope'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      applicationConfiguration:
          json[r'applicationConfiguration'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? ProviderLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      linkingStrategy: json[r'linkingStrategy'] != null
          ? IdentityProviderLinkingStrategy.fromValue(
              json[r'linkingStrategy']! as String)
          : null,
      name: json[r'name'] as String?,
      tenantConfiguration:
          json[r'tenantConfiguration'] as Map<String, Object?>?,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var scope = this.scope;
    var data = this.data;
    var applicationConfiguration = this.applicationConfiguration;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var linkingStrategy = this.linkingStrategy;
    var name = this.name;
    var tenantConfiguration = this.tenantConfiguration;
    var type = this.type;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (applicationConfiguration != null) {
      json[r'applicationConfiguration'] = applicationConfiguration;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (linkingStrategy != null) {
      json[r'linkingStrategy'] = linkingStrategy.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (tenantConfiguration != null) {
      json[r'tenantConfiguration'] = tenantConfiguration;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  TwitchIdentityProvider copyWith(
      {String? buttonText,
      String? clientId,
      String? clientSecret,
      String? scope,
      Map<String, dynamic>? data,
      Map<String, dynamic>? applicationConfiguration,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ProviderLambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      IdentityProviderLinkingStrategy? linkingStrategy,
      String? name,
      Map<String, dynamic>? tenantConfiguration,
      IdentityProviderType? type}) {
    return TwitchIdentityProvider(
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      scope: scope ?? this.scope,
      data: data ?? this.data,
      applicationConfiguration:
          applicationConfiguration ?? this.applicationConfiguration,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      linkingStrategy: linkingStrategy ?? this.linkingStrategy,
      name: name ?? this.name,
      tenantConfiguration: tenantConfiguration ?? this.tenantConfiguration,
      type: type ?? this.type,
    );
  }
}

class TwitterApplicationConfiguration {
  final String? buttonText;
  final String? consumerKey;
  final String? consumerSecret;
  final Map<String, dynamic>? data;
  final bool createRegistration;

  TwitterApplicationConfiguration(
      {this.buttonText,
      this.consumerKey,
      this.consumerSecret,
      this.data,
      bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory TwitterApplicationConfiguration.fromJson(Map<String, Object?> json) {
    return TwitterApplicationConfiguration(
      buttonText: json[r'buttonText'] as String?,
      consumerKey: json[r'consumerKey'] as String?,
      consumerSecret: json[r'consumerSecret'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var consumerKey = this.consumerKey;
    var consumerSecret = this.consumerSecret;
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (consumerKey != null) {
      json[r'consumerKey'] = consumerKey;
    }
    if (consumerSecret != null) {
      json[r'consumerSecret'] = consumerSecret;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  TwitterApplicationConfiguration copyWith(
      {String? buttonText,
      String? consumerKey,
      String? consumerSecret,
      Map<String, dynamic>? data,
      bool? createRegistration}) {
    return TwitterApplicationConfiguration(
      buttonText: buttonText ?? this.buttonText,
      consumerKey: consumerKey ?? this.consumerKey,
      consumerSecret: consumerSecret ?? this.consumerSecret,
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

/// Twitter social login provider.
class TwitterIdentityProvider {
  final String? buttonText;
  final String? consumerKey;
  final String? consumerSecret;
  final Map<String, dynamic>? data;
  final Map<String, dynamic>? applicationConfiguration;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ProviderLambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final IdentityProviderLinkingStrategy? linkingStrategy;
  final String? name;
  final Map<String, dynamic>? tenantConfiguration;
  final IdentityProviderType? type;

  TwitterIdentityProvider(
      {this.buttonText,
      this.consumerKey,
      this.consumerSecret,
      this.data,
      this.applicationConfiguration,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.linkingStrategy,
      this.name,
      this.tenantConfiguration,
      this.type})
      : debug = debug ?? false;

  factory TwitterIdentityProvider.fromJson(Map<String, Object?> json) {
    return TwitterIdentityProvider(
      buttonText: json[r'buttonText'] as String?,
      consumerKey: json[r'consumerKey'] as String?,
      consumerSecret: json[r'consumerSecret'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      applicationConfiguration:
          json[r'applicationConfiguration'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? ProviderLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      linkingStrategy: json[r'linkingStrategy'] != null
          ? IdentityProviderLinkingStrategy.fromValue(
              json[r'linkingStrategy']! as String)
          : null,
      name: json[r'name'] as String?,
      tenantConfiguration:
          json[r'tenantConfiguration'] as Map<String, Object?>?,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var consumerKey = this.consumerKey;
    var consumerSecret = this.consumerSecret;
    var data = this.data;
    var applicationConfiguration = this.applicationConfiguration;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var linkingStrategy = this.linkingStrategy;
    var name = this.name;
    var tenantConfiguration = this.tenantConfiguration;
    var type = this.type;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (consumerKey != null) {
      json[r'consumerKey'] = consumerKey;
    }
    if (consumerSecret != null) {
      json[r'consumerSecret'] = consumerSecret;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (applicationConfiguration != null) {
      json[r'applicationConfiguration'] = applicationConfiguration;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (linkingStrategy != null) {
      json[r'linkingStrategy'] = linkingStrategy.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (tenantConfiguration != null) {
      json[r'tenantConfiguration'] = tenantConfiguration;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  TwitterIdentityProvider copyWith(
      {String? buttonText,
      String? consumerKey,
      String? consumerSecret,
      Map<String, dynamic>? data,
      Map<String, dynamic>? applicationConfiguration,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ProviderLambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      IdentityProviderLinkingStrategy? linkingStrategy,
      String? name,
      Map<String, dynamic>? tenantConfiguration,
      IdentityProviderType? type}) {
    return TwitterIdentityProvider(
      buttonText: buttonText ?? this.buttonText,
      consumerKey: consumerKey ?? this.consumerKey,
      consumerSecret: consumerSecret ?? this.consumerSecret,
      data: data ?? this.data,
      applicationConfiguration:
          applicationConfiguration ?? this.applicationConfiguration,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      linkingStrategy: linkingStrategy ?? this.linkingStrategy,
      name: name ?? this.name,
      tenantConfiguration: tenantConfiguration ?? this.tenantConfiguration,
      type: type ?? this.type,
    );
  }
}

class TwoFactorDisableRequest {
  final String? applicationId;
  final String? code;
  final String? methodId;
  final EventInfo? eventInfo;

  TwoFactorDisableRequest(
      {this.applicationId, this.code, this.methodId, this.eventInfo});

  factory TwoFactorDisableRequest.fromJson(Map<String, Object?> json) {
    return TwoFactorDisableRequest(
      applicationId: json[r'applicationId'] as String?,
      code: json[r'code'] as String?,
      methodId: json[r'methodId'] as String?,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var code = this.code;
    var methodId = this.methodId;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (code != null) {
      json[r'code'] = code;
    }
    if (methodId != null) {
      json[r'methodId'] = methodId;
    }
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  TwoFactorDisableRequest copyWith(
      {String? applicationId,
      String? code,
      String? methodId,
      EventInfo? eventInfo}) {
    return TwoFactorDisableRequest(
      applicationId: applicationId ?? this.applicationId,
      code: code ?? this.code,
      methodId: methodId ?? this.methodId,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

class TwoFactorEnableDisableSendRequest {
  final String? email;
  final String? method;
  final String? methodId;
  final String? mobilePhone;

  TwoFactorEnableDisableSendRequest(
      {this.email, this.method, this.methodId, this.mobilePhone});

  factory TwoFactorEnableDisableSendRequest.fromJson(
      Map<String, Object?> json) {
    return TwoFactorEnableDisableSendRequest(
      email: json[r'email'] as String?,
      method: json[r'method'] as String?,
      methodId: json[r'methodId'] as String?,
      mobilePhone: json[r'mobilePhone'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var email = this.email;
    var method = this.method;
    var methodId = this.methodId;
    var mobilePhone = this.mobilePhone;

    final json = <String, Object?>{};
    if (email != null) {
      json[r'email'] = email;
    }
    if (method != null) {
      json[r'method'] = method;
    }
    if (methodId != null) {
      json[r'methodId'] = methodId;
    }
    if (mobilePhone != null) {
      json[r'mobilePhone'] = mobilePhone;
    }
    return json;
  }

  TwoFactorEnableDisableSendRequest copyWith(
      {String? email, String? method, String? methodId, String? mobilePhone}) {
    return TwoFactorEnableDisableSendRequest(
      email: email ?? this.email,
      method: method ?? this.method,
      methodId: methodId ?? this.methodId,
      mobilePhone: mobilePhone ?? this.mobilePhone,
    );
  }
}

class TwoFactorLoginRequest {
  final String? code;
  final bool trustComputer;
  final String? twoFactorId;
  final String? userId;
  final String? applicationId;
  final String? ipAddress;
  final MetaData? metaData;
  final bool newDevice;
  final bool noJwt;

  TwoFactorLoginRequest(
      {this.code,
      bool? trustComputer,
      this.twoFactorId,
      this.userId,
      this.applicationId,
      this.ipAddress,
      this.metaData,
      bool? newDevice,
      bool? noJwt})
      : trustComputer = trustComputer ?? false,
        newDevice = newDevice ?? false,
        noJwt = noJwt ?? false;

  factory TwoFactorLoginRequest.fromJson(Map<String, Object?> json) {
    return TwoFactorLoginRequest(
      code: json[r'code'] as String?,
      trustComputer: json[r'trustComputer'] as bool? ?? false,
      twoFactorId: json[r'twoFactorId'] as String?,
      userId: json[r'userId'] as String?,
      applicationId: json[r'applicationId'] as String?,
      ipAddress: json[r'ipAddress'] as String?,
      metaData: json[r'metaData'] != null
          ? MetaData.fromJson(json[r'metaData']! as Map<String, Object?>)
          : null,
      newDevice: json[r'newDevice'] as bool? ?? false,
      noJwt: json[r'noJWT'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var code = this.code;
    var trustComputer = this.trustComputer;
    var twoFactorId = this.twoFactorId;
    var userId = this.userId;
    var applicationId = this.applicationId;
    var ipAddress = this.ipAddress;
    var metaData = this.metaData;
    var newDevice = this.newDevice;
    var noJwt = this.noJwt;

    final json = <String, Object?>{};
    if (code != null) {
      json[r'code'] = code;
    }
    json[r'trustComputer'] = trustComputer;
    if (twoFactorId != null) {
      json[r'twoFactorId'] = twoFactorId;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (ipAddress != null) {
      json[r'ipAddress'] = ipAddress;
    }
    if (metaData != null) {
      json[r'metaData'] = metaData.toJson();
    }
    json[r'newDevice'] = newDevice;
    json[r'noJWT'] = noJwt;
    return json;
  }

  TwoFactorLoginRequest copyWith(
      {String? code,
      bool? trustComputer,
      String? twoFactorId,
      String? userId,
      String? applicationId,
      String? ipAddress,
      MetaData? metaData,
      bool? newDevice,
      bool? noJwt}) {
    return TwoFactorLoginRequest(
      code: code ?? this.code,
      trustComputer: trustComputer ?? this.trustComputer,
      twoFactorId: twoFactorId ?? this.twoFactorId,
      userId: userId ?? this.userId,
      applicationId: applicationId ?? this.applicationId,
      ipAddress: ipAddress ?? this.ipAddress,
      metaData: metaData ?? this.metaData,
      newDevice: newDevice ?? this.newDevice,
      noJwt: noJwt ?? this.noJwt,
    );
  }
}

class TwoFactorMethod {
  final AuthenticatorConfiguration? authenticator;
  final String? email;
  final String? id;
  final bool lastUsed;
  final String? method;
  final String? mobilePhone;
  final String? secret;

  TwoFactorMethod(
      {this.authenticator,
      this.email,
      this.id,
      bool? lastUsed,
      this.method,
      this.mobilePhone,
      this.secret})
      : lastUsed = lastUsed ?? false;

  factory TwoFactorMethod.fromJson(Map<String, Object?> json) {
    return TwoFactorMethod(
      authenticator: json[r'authenticator'] != null
          ? AuthenticatorConfiguration.fromJson(
              json[r'authenticator']! as Map<String, Object?>)
          : null,
      email: json[r'email'] as String?,
      id: json[r'id'] as String?,
      lastUsed: json[r'lastUsed'] as bool? ?? false,
      method: json[r'method'] as String?,
      mobilePhone: json[r'mobilePhone'] as String?,
      secret: json[r'secret'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var authenticator = this.authenticator;
    var email = this.email;
    var id = this.id;
    var lastUsed = this.lastUsed;
    var method = this.method;
    var mobilePhone = this.mobilePhone;
    var secret = this.secret;

    final json = <String, Object?>{};
    if (authenticator != null) {
      json[r'authenticator'] = authenticator.toJson();
    }
    if (email != null) {
      json[r'email'] = email;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'lastUsed'] = lastUsed;
    if (method != null) {
      json[r'method'] = method;
    }
    if (mobilePhone != null) {
      json[r'mobilePhone'] = mobilePhone;
    }
    if (secret != null) {
      json[r'secret'] = secret;
    }
    return json;
  }

  TwoFactorMethod copyWith(
      {AuthenticatorConfiguration? authenticator,
      String? email,
      String? id,
      bool? lastUsed,
      String? method,
      String? mobilePhone,
      String? secret}) {
    return TwoFactorMethod(
      authenticator: authenticator ?? this.authenticator,
      email: email ?? this.email,
      id: id ?? this.id,
      lastUsed: lastUsed ?? this.lastUsed,
      method: method ?? this.method,
      mobilePhone: mobilePhone ?? this.mobilePhone,
      secret: secret ?? this.secret,
    );
  }
}

class TwoFactorRecoveryCodeResponse {
  final List<String> recoveryCodes;

  TwoFactorRecoveryCodeResponse({List<String>? recoveryCodes})
      : recoveryCodes = recoveryCodes ?? [];

  factory TwoFactorRecoveryCodeResponse.fromJson(Map<String, Object?> json) {
    return TwoFactorRecoveryCodeResponse(
      recoveryCodes: (json[r'recoveryCodes'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var recoveryCodes = this.recoveryCodes;

    final json = <String, Object?>{};
    json[r'recoveryCodes'] = recoveryCodes;
    return json;
  }

  TwoFactorRecoveryCodeResponse copyWith({List<String>? recoveryCodes}) {
    return TwoFactorRecoveryCodeResponse(
      recoveryCodes: recoveryCodes ?? this.recoveryCodes,
    );
  }
}

class TwoFactorRequest {
  final String? applicationId;
  final String? authenticatorId;
  final String? code;
  final String? email;
  final String? method;
  final String? mobilePhone;
  final String? secret;
  final String? secretBase32Encoded;
  final String? twoFactorId;
  final EventInfo? eventInfo;

  TwoFactorRequest(
      {this.applicationId,
      this.authenticatorId,
      this.code,
      this.email,
      this.method,
      this.mobilePhone,
      this.secret,
      this.secretBase32Encoded,
      this.twoFactorId,
      this.eventInfo});

  factory TwoFactorRequest.fromJson(Map<String, Object?> json) {
    return TwoFactorRequest(
      applicationId: json[r'applicationId'] as String?,
      authenticatorId: json[r'authenticatorId'] as String?,
      code: json[r'code'] as String?,
      email: json[r'email'] as String?,
      method: json[r'method'] as String?,
      mobilePhone: json[r'mobilePhone'] as String?,
      secret: json[r'secret'] as String?,
      secretBase32Encoded: json[r'secretBase32Encoded'] as String?,
      twoFactorId: json[r'twoFactorId'] as String?,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var authenticatorId = this.authenticatorId;
    var code = this.code;
    var email = this.email;
    var method = this.method;
    var mobilePhone = this.mobilePhone;
    var secret = this.secret;
    var secretBase32Encoded = this.secretBase32Encoded;
    var twoFactorId = this.twoFactorId;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (authenticatorId != null) {
      json[r'authenticatorId'] = authenticatorId;
    }
    if (code != null) {
      json[r'code'] = code;
    }
    if (email != null) {
      json[r'email'] = email;
    }
    if (method != null) {
      json[r'method'] = method;
    }
    if (mobilePhone != null) {
      json[r'mobilePhone'] = mobilePhone;
    }
    if (secret != null) {
      json[r'secret'] = secret;
    }
    if (secretBase32Encoded != null) {
      json[r'secretBase32Encoded'] = secretBase32Encoded;
    }
    if (twoFactorId != null) {
      json[r'twoFactorId'] = twoFactorId;
    }
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  TwoFactorRequest copyWith(
      {String? applicationId,
      String? authenticatorId,
      String? code,
      String? email,
      String? method,
      String? mobilePhone,
      String? secret,
      String? secretBase32Encoded,
      String? twoFactorId,
      EventInfo? eventInfo}) {
    return TwoFactorRequest(
      applicationId: applicationId ?? this.applicationId,
      authenticatorId: authenticatorId ?? this.authenticatorId,
      code: code ?? this.code,
      email: email ?? this.email,
      method: method ?? this.method,
      mobilePhone: mobilePhone ?? this.mobilePhone,
      secret: secret ?? this.secret,
      secretBase32Encoded: secretBase32Encoded ?? this.secretBase32Encoded,
      twoFactorId: twoFactorId ?? this.twoFactorId,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

class TwoFactorResponse {
  final String? code;
  final List<String> recoveryCodes;

  TwoFactorResponse({this.code, List<String>? recoveryCodes})
      : recoveryCodes = recoveryCodes ?? [];

  factory TwoFactorResponse.fromJson(Map<String, Object?> json) {
    return TwoFactorResponse(
      code: json[r'code'] as String?,
      recoveryCodes: (json[r'recoveryCodes'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var code = this.code;
    var recoveryCodes = this.recoveryCodes;

    final json = <String, Object?>{};
    if (code != null) {
      json[r'code'] = code;
    }
    json[r'recoveryCodes'] = recoveryCodes;
    return json;
  }

  TwoFactorResponse copyWith({String? code, List<String>? recoveryCodes}) {
    return TwoFactorResponse(
      code: code ?? this.code,
      recoveryCodes: recoveryCodes ?? this.recoveryCodes,
    );
  }
}

class TwoFactorSendRequest {
  final String? applicationId;
  final String? email;
  final String? method;
  final String? methodId;
  final String? mobilePhone;
  final String? userId;

  TwoFactorSendRequest(
      {this.applicationId,
      this.email,
      this.method,
      this.methodId,
      this.mobilePhone,
      this.userId});

  factory TwoFactorSendRequest.fromJson(Map<String, Object?> json) {
    return TwoFactorSendRequest(
      applicationId: json[r'applicationId'] as String?,
      email: json[r'email'] as String?,
      method: json[r'method'] as String?,
      methodId: json[r'methodId'] as String?,
      mobilePhone: json[r'mobilePhone'] as String?,
      userId: json[r'userId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var email = this.email;
    var method = this.method;
    var methodId = this.methodId;
    var mobilePhone = this.mobilePhone;
    var userId = this.userId;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (email != null) {
      json[r'email'] = email;
    }
    if (method != null) {
      json[r'method'] = method;
    }
    if (methodId != null) {
      json[r'methodId'] = methodId;
    }
    if (mobilePhone != null) {
      json[r'mobilePhone'] = mobilePhone;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    return json;
  }

  TwoFactorSendRequest copyWith(
      {String? applicationId,
      String? email,
      String? method,
      String? methodId,
      String? mobilePhone,
      String? userId}) {
    return TwoFactorSendRequest(
      applicationId: applicationId ?? this.applicationId,
      email: email ?? this.email,
      method: method ?? this.method,
      methodId: methodId ?? this.methodId,
      mobilePhone: mobilePhone ?? this.mobilePhone,
      userId: userId ?? this.userId,
    );
  }
}

class TwoFactorStartRequest {
  final String? applicationId;
  final String? code;
  final String? loginId;
  final Map<String, dynamic>? state;
  final String? trustChallenge;
  final String? userId;

  TwoFactorStartRequest(
      {this.applicationId,
      this.code,
      this.loginId,
      this.state,
      this.trustChallenge,
      this.userId});

  factory TwoFactorStartRequest.fromJson(Map<String, Object?> json) {
    return TwoFactorStartRequest(
      applicationId: json[r'applicationId'] as String?,
      code: json[r'code'] as String?,
      loginId: json[r'loginId'] as String?,
      state: json[r'state'] as Map<String, Object?>?,
      trustChallenge: json[r'trustChallenge'] as String?,
      userId: json[r'userId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var code = this.code;
    var loginId = this.loginId;
    var state = this.state;
    var trustChallenge = this.trustChallenge;
    var userId = this.userId;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (code != null) {
      json[r'code'] = code;
    }
    if (loginId != null) {
      json[r'loginId'] = loginId;
    }
    if (state != null) {
      json[r'state'] = state;
    }
    if (trustChallenge != null) {
      json[r'trustChallenge'] = trustChallenge;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    return json;
  }

  TwoFactorStartRequest copyWith(
      {String? applicationId,
      String? code,
      String? loginId,
      Map<String, dynamic>? state,
      String? trustChallenge,
      String? userId}) {
    return TwoFactorStartRequest(
      applicationId: applicationId ?? this.applicationId,
      code: code ?? this.code,
      loginId: loginId ?? this.loginId,
      state: state ?? this.state,
      trustChallenge: trustChallenge ?? this.trustChallenge,
      userId: userId ?? this.userId,
    );
  }
}

class TwoFactorStartResponse {
  final String? code;
  final List<TwoFactorMethod> methods;
  final String? twoFactorId;

  TwoFactorStartResponse(
      {this.code, List<TwoFactorMethod>? methods, this.twoFactorId})
      : methods = methods ?? [];

  factory TwoFactorStartResponse.fromJson(Map<String, Object?> json) {
    return TwoFactorStartResponse(
      code: json[r'code'] as String?,
      methods: (json[r'methods'] as List<Object?>?)
              ?.map((i) => TwoFactorMethod.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      twoFactorId: json[r'twoFactorId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var code = this.code;
    var methods = this.methods;
    var twoFactorId = this.twoFactorId;

    final json = <String, Object?>{};
    if (code != null) {
      json[r'code'] = code;
    }
    json[r'methods'] = methods.map((i) => i.toJson()).toList();
    if (twoFactorId != null) {
      json[r'twoFactorId'] = twoFactorId;
    }
    return json;
  }

  TwoFactorStartResponse copyWith(
      {String? code, List<TwoFactorMethod>? methods, String? twoFactorId}) {
    return TwoFactorStartResponse(
      code: code ?? this.code,
      methods: methods ?? this.methods,
      twoFactorId: twoFactorId ?? this.twoFactorId,
    );
  }
}

class TwoFactorStatusResponse {
  final List<TwoFactorTrust> trusts;
  final String? twoFactorTrustId;

  TwoFactorStatusResponse({List<TwoFactorTrust>? trusts, this.twoFactorTrustId})
      : trusts = trusts ?? [];

  factory TwoFactorStatusResponse.fromJson(Map<String, Object?> json) {
    return TwoFactorStatusResponse(
      trusts: (json[r'trusts'] as List<Object?>?)
              ?.map((i) => TwoFactorTrust.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      twoFactorTrustId: json[r'twoFactorTrustId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var trusts = this.trusts;
    var twoFactorTrustId = this.twoFactorTrustId;

    final json = <String, Object?>{};
    json[r'trusts'] = trusts.map((i) => i.toJson()).toList();
    if (twoFactorTrustId != null) {
      json[r'twoFactorTrustId'] = twoFactorTrustId;
    }
    return json;
  }

  TwoFactorStatusResponse copyWith(
      {List<TwoFactorTrust>? trusts, String? twoFactorTrustId}) {
    return TwoFactorStatusResponse(
      trusts: trusts ?? this.trusts,
      twoFactorTrustId: twoFactorTrustId ?? this.twoFactorTrustId,
    );
  }
}

class TwoFactorTrust {
  final String? applicationId;
  final ZonedDateTime? expiration;
  final ZonedDateTime? startInstant;

  TwoFactorTrust({this.applicationId, this.expiration, this.startInstant});

  factory TwoFactorTrust.fromJson(Map<String, Object?> json) {
    return TwoFactorTrust(
      applicationId: json[r'applicationId'] as String?,
      expiration: (json[r'expiration'] as num?)?.toInt() as ZonedDateTime?,
      startInstant: (json[r'startInstant'] as num?)?.toInt() as ZonedDateTime?,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var expiration = this.expiration;
    var startInstant = this.startInstant;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (expiration != null) {
      json[r'expiration'] = expiration.toJson();
    }
    if (startInstant != null) {
      json[r'startInstant'] = startInstant.toJson();
    }
    return json;
  }

  TwoFactorTrust copyWith(
      {String? applicationId,
      ZonedDateTime? expiration,
      ZonedDateTime? startInstant}) {
    return TwoFactorTrust(
      applicationId: applicationId ?? this.applicationId,
      expiration: expiration ?? this.expiration,
      startInstant: startInstant ?? this.startInstant,
    );
  }
}

class UIConfiguration {
  final String? headerColor;
  final String? logoUrl;
  final String? menuFontColor;

  UIConfiguration({this.headerColor, this.logoUrl, this.menuFontColor});

  factory UIConfiguration.fromJson(Map<String, Object?> json) {
    return UIConfiguration(
      headerColor: json[r'headerColor'] as String?,
      logoUrl: json[r'logoURL'] as String?,
      menuFontColor: json[r'menuFontColor'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var headerColor = this.headerColor;
    var logoUrl = this.logoUrl;
    var menuFontColor = this.menuFontColor;

    final json = <String, Object?>{};
    if (headerColor != null) {
      json[r'headerColor'] = headerColor;
    }
    if (logoUrl != null) {
      json[r'logoURL'] = logoUrl;
    }
    if (menuFontColor != null) {
      json[r'menuFontColor'] = menuFontColor;
    }
    return json;
  }

  UIConfiguration copyWith(
      {String? headerColor, String? logoUrl, String? menuFontColor}) {
    return UIConfiguration(
      headerColor: headerColor ?? this.headerColor,
      logoUrl: logoUrl ?? this.logoUrl,
      menuFontColor: menuFontColor ?? this.menuFontColor,
    );
  }
}

class UniqueUsernameConfiguration {
  final int? numberOfDigits;
  final String? separator;
  final UniqueUsernameStrategy? strategy;
  final bool enabled;

  UniqueUsernameConfiguration(
      {this.numberOfDigits, this.separator, this.strategy, bool? enabled})
      : enabled = enabled ?? false;

  factory UniqueUsernameConfiguration.fromJson(Map<String, Object?> json) {
    return UniqueUsernameConfiguration(
      numberOfDigits: (json[r'numberOfDigits'] as num?)?.toInt(),
      separator: json[r'separator'] as String?,
      strategy: json[r'strategy'] != null
          ? UniqueUsernameStrategy.fromValue(json[r'strategy']! as String)
          : null,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var numberOfDigits = this.numberOfDigits;
    var separator = this.separator;
    var strategy = this.strategy;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (numberOfDigits != null) {
      json[r'numberOfDigits'] = numberOfDigits;
    }
    if (separator != null) {
      json[r'separator'] = separator;
    }
    if (strategy != null) {
      json[r'strategy'] = strategy.value;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  UniqueUsernameConfiguration copyWith(
      {int? numberOfDigits,
      String? separator,
      UniqueUsernameStrategy? strategy,
      bool? enabled}) {
    return UniqueUsernameConfiguration(
      numberOfDigits: numberOfDigits ?? this.numberOfDigits,
      separator: separator ?? this.separator,
      strategy: strategy ?? this.strategy,
      enabled: enabled ?? this.enabled,
    );
  }
}

/// The global view of a User. This object contains all global information about
/// the user including birthdate, registration information  preferred languages,
/// global attributes, etc.
class User {
  final List<Locale> preferredLanguages;
  final bool active;
  final LocalDate? birthDate;
  final String? cleanSpeakId;
  final Map<String, dynamic>? data;
  final String? email;
  final ZonedDateTime? expiry;
  final String? firstName;
  final String? fullName;
  final String? imageUrl;
  final ZonedDateTime? insertInstant;
  final String? lastName;
  final ZonedDateTime? lastUpdateInstant;
  final String? middleName;
  final String? mobilePhone;
  final String? parentEmail;
  final String? tenantId;
  final ZoneId? timezone;
  final UserTwoFactorConfiguration? twoFactor;
  final List<GroupMember> memberships;
  final List<UserRegistration> registrations;
  final ZonedDateTime? breachedPasswordLastCheckedInstant;
  final BreachedPasswordStatus? breachedPasswordStatus;
  final String? connectorId;
  final String? encryptionScheme;
  final int? factor;
  final String? id;
  final ZonedDateTime? lastLoginInstant;
  final String? password;
  final ChangePasswordReason? passwordChangeReason;
  final bool passwordChangeRequired;
  final ZonedDateTime? passwordLastUpdateInstant;
  final String? salt;
  final String? uniqueUsername;
  final String? username;
  final ContentStatus? usernameStatus;
  final bool verified;
  final ZonedDateTime? verifiedInstant;

  User(
      {List<Locale>? preferredLanguages,
      bool? active,
      this.birthDate,
      this.cleanSpeakId,
      this.data,
      this.email,
      this.expiry,
      this.firstName,
      this.fullName,
      this.imageUrl,
      this.insertInstant,
      this.lastName,
      this.lastUpdateInstant,
      this.middleName,
      this.mobilePhone,
      this.parentEmail,
      this.tenantId,
      this.timezone,
      this.twoFactor,
      List<GroupMember>? memberships,
      List<UserRegistration>? registrations,
      this.breachedPasswordLastCheckedInstant,
      this.breachedPasswordStatus,
      this.connectorId,
      this.encryptionScheme,
      this.factor,
      this.id,
      this.lastLoginInstant,
      this.password,
      this.passwordChangeReason,
      bool? passwordChangeRequired,
      this.passwordLastUpdateInstant,
      this.salt,
      this.uniqueUsername,
      this.username,
      this.usernameStatus,
      bool? verified,
      this.verifiedInstant})
      : preferredLanguages = preferredLanguages ?? [],
        active = active ?? false,
        memberships = memberships ?? [],
        registrations = registrations ?? [],
        passwordChangeRequired = passwordChangeRequired ?? false,
        verified = verified ?? false;

  factory User.fromJson(Map<String, Object?> json) {
    return User(
      preferredLanguages: (json[r'preferredLanguages'] as List<Object?>?)
              ?.map((i) => (i as Locale? ?? '') as Locale)
              .toList() ??
          [],
      active: json[r'active'] as bool? ?? false,
      birthDate: json[r'birthDate'] as LocalDate?,
      cleanSpeakId: json[r'cleanSpeakId'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      email: json[r'email'] as String?,
      expiry: (json[r'expiry'] as num?)?.toInt() as ZonedDateTime?,
      firstName: json[r'firstName'] as String?,
      fullName: json[r'fullName'] as String?,
      imageUrl: json[r'imageUrl'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastName: json[r'lastName'] as String?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      middleName: json[r'middleName'] as String?,
      mobilePhone: json[r'mobilePhone'] as String?,
      parentEmail: json[r'parentEmail'] as String?,
      tenantId: json[r'tenantId'] as String?,
      timezone: json[r'timezone'] as ZoneId?,
      twoFactor: json[r'twoFactor'] != null
          ? UserTwoFactorConfiguration.fromJson(
              json[r'twoFactor']! as Map<String, Object?>)
          : null,
      memberships: (json[r'memberships'] as List<Object?>?)
              ?.map((i) =>
                  GroupMember.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      registrations: (json[r'registrations'] as List<Object?>?)
              ?.map((i) => UserRegistration.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      breachedPasswordLastCheckedInstant:
          (json[r'breachedPasswordLastCheckedInstant'] as num?)?.toInt()
              as ZonedDateTime?,
      breachedPasswordStatus: json[r'breachedPasswordStatus'] != null
          ? BreachedPasswordStatus.fromValue(
              json[r'breachedPasswordStatus']! as String)
          : null,
      connectorId: json[r'connectorId'] as String?,
      encryptionScheme: json[r'encryptionScheme'] as String?,
      factor: (json[r'factor'] as num?)?.toInt(),
      id: json[r'id'] as String?,
      lastLoginInstant:
          (json[r'lastLoginInstant'] as num?)?.toInt() as ZonedDateTime?,
      password: json[r'password'] as String?,
      passwordChangeReason: json[r'passwordChangeReason'] != null
          ? ChangePasswordReason.fromValue(
              json[r'passwordChangeReason']! as String)
          : null,
      passwordChangeRequired: json[r'passwordChangeRequired'] as bool? ?? false,
      passwordLastUpdateInstant: (json[r'passwordLastUpdateInstant'] as num?)
          ?.toInt() as ZonedDateTime?,
      salt: json[r'salt'] as String?,
      uniqueUsername: json[r'uniqueUsername'] as String?,
      username: json[r'username'] as String?,
      usernameStatus: json[r'usernameStatus'] != null
          ? ContentStatus.fromValue(json[r'usernameStatus']! as String)
          : null,
      verified: json[r'verified'] as bool? ?? false,
      verifiedInstant:
          (json[r'verifiedInstant'] as num?)?.toInt() as ZonedDateTime?,
    );
  }

  Map<String, Object?> toJson() {
    var preferredLanguages = this.preferredLanguages;
    var active = this.active;
    var birthDate = this.birthDate;
    var cleanSpeakId = this.cleanSpeakId;
    var data = this.data;
    var email = this.email;
    var expiry = this.expiry;
    var firstName = this.firstName;
    var fullName = this.fullName;
    var imageUrl = this.imageUrl;
    var insertInstant = this.insertInstant;
    var lastName = this.lastName;
    var lastUpdateInstant = this.lastUpdateInstant;
    var middleName = this.middleName;
    var mobilePhone = this.mobilePhone;
    var parentEmail = this.parentEmail;
    var tenantId = this.tenantId;
    var timezone = this.timezone;
    var twoFactor = this.twoFactor;
    var memberships = this.memberships;
    var registrations = this.registrations;
    var breachedPasswordLastCheckedInstant =
        this.breachedPasswordLastCheckedInstant;
    var breachedPasswordStatus = this.breachedPasswordStatus;
    var connectorId = this.connectorId;
    var encryptionScheme = this.encryptionScheme;
    var factor = this.factor;
    var id = this.id;
    var lastLoginInstant = this.lastLoginInstant;
    var password = this.password;
    var passwordChangeReason = this.passwordChangeReason;
    var passwordChangeRequired = this.passwordChangeRequired;
    var passwordLastUpdateInstant = this.passwordLastUpdateInstant;
    var salt = this.salt;
    var uniqueUsername = this.uniqueUsername;
    var username = this.username;
    var usernameStatus = this.usernameStatus;
    var verified = this.verified;
    var verifiedInstant = this.verifiedInstant;

    final json = <String, Object?>{};
    json[r'preferredLanguages'] =
        preferredLanguages.map((i) => i.toJson()).toList();
    json[r'active'] = active;
    if (birthDate != null) {
      json[r'birthDate'] = birthDate.toJson();
    }
    if (cleanSpeakId != null) {
      json[r'cleanSpeakId'] = cleanSpeakId;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (email != null) {
      json[r'email'] = email;
    }
    if (expiry != null) {
      json[r'expiry'] = expiry.toJson();
    }
    if (firstName != null) {
      json[r'firstName'] = firstName;
    }
    if (fullName != null) {
      json[r'fullName'] = fullName;
    }
    if (imageUrl != null) {
      json[r'imageUrl'] = imageUrl;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastName != null) {
      json[r'lastName'] = lastName;
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (middleName != null) {
      json[r'middleName'] = middleName;
    }
    if (mobilePhone != null) {
      json[r'mobilePhone'] = mobilePhone;
    }
    if (parentEmail != null) {
      json[r'parentEmail'] = parentEmail;
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (timezone != null) {
      json[r'timezone'] = timezone.toJson();
    }
    if (twoFactor != null) {
      json[r'twoFactor'] = twoFactor.toJson();
    }
    json[r'memberships'] = memberships.map((i) => i.toJson()).toList();
    json[r'registrations'] = registrations.map((i) => i.toJson()).toList();
    if (breachedPasswordLastCheckedInstant != null) {
      json[r'breachedPasswordLastCheckedInstant'] =
          breachedPasswordLastCheckedInstant.toJson();
    }
    if (breachedPasswordStatus != null) {
      json[r'breachedPasswordStatus'] = breachedPasswordStatus.value;
    }
    if (connectorId != null) {
      json[r'connectorId'] = connectorId;
    }
    if (encryptionScheme != null) {
      json[r'encryptionScheme'] = encryptionScheme;
    }
    if (factor != null) {
      json[r'factor'] = factor;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (lastLoginInstant != null) {
      json[r'lastLoginInstant'] = lastLoginInstant.toJson();
    }
    if (password != null) {
      json[r'password'] = password;
    }
    if (passwordChangeReason != null) {
      json[r'passwordChangeReason'] = passwordChangeReason.value;
    }
    json[r'passwordChangeRequired'] = passwordChangeRequired;
    if (passwordLastUpdateInstant != null) {
      json[r'passwordLastUpdateInstant'] = passwordLastUpdateInstant.toJson();
    }
    if (salt != null) {
      json[r'salt'] = salt;
    }
    if (uniqueUsername != null) {
      json[r'uniqueUsername'] = uniqueUsername;
    }
    if (username != null) {
      json[r'username'] = username;
    }
    if (usernameStatus != null) {
      json[r'usernameStatus'] = usernameStatus.value;
    }
    json[r'verified'] = verified;
    if (verifiedInstant != null) {
      json[r'verifiedInstant'] = verifiedInstant.toJson();
    }
    return json;
  }

  User copyWith(
      {List<Locale>? preferredLanguages,
      bool? active,
      LocalDate? birthDate,
      String? cleanSpeakId,
      Map<String, dynamic>? data,
      String? email,
      ZonedDateTime? expiry,
      String? firstName,
      String? fullName,
      String? imageUrl,
      ZonedDateTime? insertInstant,
      String? lastName,
      ZonedDateTime? lastUpdateInstant,
      String? middleName,
      String? mobilePhone,
      String? parentEmail,
      String? tenantId,
      ZoneId? timezone,
      UserTwoFactorConfiguration? twoFactor,
      List<GroupMember>? memberships,
      List<UserRegistration>? registrations,
      ZonedDateTime? breachedPasswordLastCheckedInstant,
      BreachedPasswordStatus? breachedPasswordStatus,
      String? connectorId,
      String? encryptionScheme,
      int? factor,
      String? id,
      ZonedDateTime? lastLoginInstant,
      String? password,
      ChangePasswordReason? passwordChangeReason,
      bool? passwordChangeRequired,
      ZonedDateTime? passwordLastUpdateInstant,
      String? salt,
      String? uniqueUsername,
      String? username,
      ContentStatus? usernameStatus,
      bool? verified,
      ZonedDateTime? verifiedInstant}) {
    return User(
      preferredLanguages: preferredLanguages ?? this.preferredLanguages,
      active: active ?? this.active,
      birthDate: birthDate ?? this.birthDate,
      cleanSpeakId: cleanSpeakId ?? this.cleanSpeakId,
      data: data ?? this.data,
      email: email ?? this.email,
      expiry: expiry ?? this.expiry,
      firstName: firstName ?? this.firstName,
      fullName: fullName ?? this.fullName,
      imageUrl: imageUrl ?? this.imageUrl,
      insertInstant: insertInstant ?? this.insertInstant,
      lastName: lastName ?? this.lastName,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      middleName: middleName ?? this.middleName,
      mobilePhone: mobilePhone ?? this.mobilePhone,
      parentEmail: parentEmail ?? this.parentEmail,
      tenantId: tenantId ?? this.tenantId,
      timezone: timezone ?? this.timezone,
      twoFactor: twoFactor ?? this.twoFactor,
      memberships: memberships ?? this.memberships,
      registrations: registrations ?? this.registrations,
      breachedPasswordLastCheckedInstant: breachedPasswordLastCheckedInstant ??
          this.breachedPasswordLastCheckedInstant,
      breachedPasswordStatus:
          breachedPasswordStatus ?? this.breachedPasswordStatus,
      connectorId: connectorId ?? this.connectorId,
      encryptionScheme: encryptionScheme ?? this.encryptionScheme,
      factor: factor ?? this.factor,
      id: id ?? this.id,
      lastLoginInstant: lastLoginInstant ?? this.lastLoginInstant,
      password: password ?? this.password,
      passwordChangeReason: passwordChangeReason ?? this.passwordChangeReason,
      passwordChangeRequired:
          passwordChangeRequired ?? this.passwordChangeRequired,
      passwordLastUpdateInstant:
          passwordLastUpdateInstant ?? this.passwordLastUpdateInstant,
      salt: salt ?? this.salt,
      uniqueUsername: uniqueUsername ?? this.uniqueUsername,
      username: username ?? this.username,
      usernameStatus: usernameStatus ?? this.usernameStatus,
      verified: verified ?? this.verified,
      verifiedInstant: verifiedInstant ?? this.verifiedInstant,
    );
  }
}

/// An action that can be executed on a user (discipline or reward potentially).
class UserAction {
  final bool active;
  final String? cancelEmailTemplateId;
  final String? endEmailTemplateId;
  final String? id;
  final bool includeEmailInEventJson;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final LocalizedStrings? localizedNames;
  final String? modifyEmailTemplateId;
  final String? name;
  final List<UserActionOption> options;
  final bool preventLogin;
  final bool sendEndEvent;
  final String? startEmailTemplateId;
  final bool temporal;
  final TransactionType? transactionType;
  final bool userEmailingEnabled;
  final bool userNotificationsEnabled;

  UserAction(
      {bool? active,
      this.cancelEmailTemplateId,
      this.endEmailTemplateId,
      this.id,
      bool? includeEmailInEventJson,
      this.insertInstant,
      this.lastUpdateInstant,
      this.localizedNames,
      this.modifyEmailTemplateId,
      this.name,
      List<UserActionOption>? options,
      bool? preventLogin,
      bool? sendEndEvent,
      this.startEmailTemplateId,
      bool? temporal,
      this.transactionType,
      bool? userEmailingEnabled,
      bool? userNotificationsEnabled})
      : active = active ?? false,
        includeEmailInEventJson = includeEmailInEventJson ?? false,
        options = options ?? [],
        preventLogin = preventLogin ?? false,
        sendEndEvent = sendEndEvent ?? false,
        temporal = temporal ?? false,
        userEmailingEnabled = userEmailingEnabled ?? false,
        userNotificationsEnabled = userNotificationsEnabled ?? false;

  factory UserAction.fromJson(Map<String, Object?> json) {
    return UserAction(
      active: json[r'active'] as bool? ?? false,
      cancelEmailTemplateId: json[r'cancelEmailTemplateId'] as String?,
      endEmailTemplateId: json[r'endEmailTemplateId'] as String?,
      id: json[r'id'] as String?,
      includeEmailInEventJson:
          json[r'includeEmailInEventJSON'] as bool? ?? false,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      localizedNames: json[r'localizedNames'] != null
          ? LocalizedStrings.fromJson(
              json[r'localizedNames']! as Map<String, Object?>)
          : null,
      modifyEmailTemplateId: json[r'modifyEmailTemplateId'] as String?,
      name: json[r'name'] as String?,
      options: (json[r'options'] as List<Object?>?)
              ?.map((i) => UserActionOption.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      preventLogin: json[r'preventLogin'] as bool? ?? false,
      sendEndEvent: json[r'sendEndEvent'] as bool? ?? false,
      startEmailTemplateId: json[r'startEmailTemplateId'] as String?,
      temporal: json[r'temporal'] as bool? ?? false,
      transactionType: json[r'transactionType'] != null
          ? TransactionType.fromValue(json[r'transactionType']! as String)
          : null,
      userEmailingEnabled: json[r'userEmailingEnabled'] as bool? ?? false,
      userNotificationsEnabled:
          json[r'userNotificationsEnabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var active = this.active;
    var cancelEmailTemplateId = this.cancelEmailTemplateId;
    var endEmailTemplateId = this.endEmailTemplateId;
    var id = this.id;
    var includeEmailInEventJson = this.includeEmailInEventJson;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var localizedNames = this.localizedNames;
    var modifyEmailTemplateId = this.modifyEmailTemplateId;
    var name = this.name;
    var options = this.options;
    var preventLogin = this.preventLogin;
    var sendEndEvent = this.sendEndEvent;
    var startEmailTemplateId = this.startEmailTemplateId;
    var temporal = this.temporal;
    var transactionType = this.transactionType;
    var userEmailingEnabled = this.userEmailingEnabled;
    var userNotificationsEnabled = this.userNotificationsEnabled;

    final json = <String, Object?>{};
    json[r'active'] = active;
    if (cancelEmailTemplateId != null) {
      json[r'cancelEmailTemplateId'] = cancelEmailTemplateId;
    }
    if (endEmailTemplateId != null) {
      json[r'endEmailTemplateId'] = endEmailTemplateId;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'includeEmailInEventJSON'] = includeEmailInEventJson;
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (localizedNames != null) {
      json[r'localizedNames'] = localizedNames.toJson();
    }
    if (modifyEmailTemplateId != null) {
      json[r'modifyEmailTemplateId'] = modifyEmailTemplateId;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'options'] = options.map((i) => i.toJson()).toList();
    json[r'preventLogin'] = preventLogin;
    json[r'sendEndEvent'] = sendEndEvent;
    if (startEmailTemplateId != null) {
      json[r'startEmailTemplateId'] = startEmailTemplateId;
    }
    json[r'temporal'] = temporal;
    if (transactionType != null) {
      json[r'transactionType'] = transactionType.value;
    }
    json[r'userEmailingEnabled'] = userEmailingEnabled;
    json[r'userNotificationsEnabled'] = userNotificationsEnabled;
    return json;
  }

  UserAction copyWith(
      {bool? active,
      String? cancelEmailTemplateId,
      String? endEmailTemplateId,
      String? id,
      bool? includeEmailInEventJson,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      LocalizedStrings? localizedNames,
      String? modifyEmailTemplateId,
      String? name,
      List<UserActionOption>? options,
      bool? preventLogin,
      bool? sendEndEvent,
      String? startEmailTemplateId,
      bool? temporal,
      TransactionType? transactionType,
      bool? userEmailingEnabled,
      bool? userNotificationsEnabled}) {
    return UserAction(
      active: active ?? this.active,
      cancelEmailTemplateId:
          cancelEmailTemplateId ?? this.cancelEmailTemplateId,
      endEmailTemplateId: endEmailTemplateId ?? this.endEmailTemplateId,
      id: id ?? this.id,
      includeEmailInEventJson:
          includeEmailInEventJson ?? this.includeEmailInEventJson,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      localizedNames: localizedNames ?? this.localizedNames,
      modifyEmailTemplateId:
          modifyEmailTemplateId ?? this.modifyEmailTemplateId,
      name: name ?? this.name,
      options: options ?? this.options,
      preventLogin: preventLogin ?? this.preventLogin,
      sendEndEvent: sendEndEvent ?? this.sendEndEvent,
      startEmailTemplateId: startEmailTemplateId ?? this.startEmailTemplateId,
      temporal: temporal ?? this.temporal,
      transactionType: transactionType ?? this.transactionType,
      userEmailingEnabled: userEmailingEnabled ?? this.userEmailingEnabled,
      userNotificationsEnabled:
          userNotificationsEnabled ?? this.userNotificationsEnabled,
    );
  }
}

/// Models the user action Event.
class UserActionEvent {
  final List<String> applicationIds;
  final String? action;
  final String? actionId;
  final String? actioneeUserId;
  final String? actionerUserId;
  final String? comment;
  final Email? email;
  final bool emailedUser;
  final ZonedDateTime? expiry;
  final String? localizedAction;
  final String? localizedDuration;
  final String? localizedOption;
  final String? localizedReason;
  final bool notifyUser;
  final String? option;
  final UserActionPhase? phase;
  final String? reason;
  final String? reasonCode;
  final ZonedDateTime? createInstant;
  final String? id;
  final EventInfo? info;
  final String? tenantId;
  final EventType? type;

  UserActionEvent(
      {List<String>? applicationIds,
      this.action,
      this.actionId,
      this.actioneeUserId,
      this.actionerUserId,
      this.comment,
      this.email,
      bool? emailedUser,
      this.expiry,
      this.localizedAction,
      this.localizedDuration,
      this.localizedOption,
      this.localizedReason,
      bool? notifyUser,
      this.option,
      this.phase,
      this.reason,
      this.reasonCode,
      this.createInstant,
      this.id,
      this.info,
      this.tenantId,
      this.type})
      : applicationIds = applicationIds ?? [],
        emailedUser = emailedUser ?? false,
        notifyUser = notifyUser ?? false;

  factory UserActionEvent.fromJson(Map<String, Object?> json) {
    return UserActionEvent(
      applicationIds: (json[r'applicationIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      action: json[r'action'] as String?,
      actionId: json[r'actionId'] as String?,
      actioneeUserId: json[r'actioneeUserId'] as String?,
      actionerUserId: json[r'actionerUserId'] as String?,
      comment: json[r'comment'] as String?,
      email: json[r'email'] != null
          ? Email.fromJson(json[r'email']! as Map<String, Object?>)
          : null,
      emailedUser: json[r'emailedUser'] as bool? ?? false,
      expiry: (json[r'expiry'] as num?)?.toInt() as ZonedDateTime?,
      localizedAction: json[r'localizedAction'] as String?,
      localizedDuration: json[r'localizedDuration'] as String?,
      localizedOption: json[r'localizedOption'] as String?,
      localizedReason: json[r'localizedReason'] as String?,
      notifyUser: json[r'notifyUser'] as bool? ?? false,
      option: json[r'option'] as String?,
      phase: json[r'phase'] != null
          ? UserActionPhase.fromValue(json[r'phase']! as String)
          : null,
      reason: json[r'reason'] as String?,
      reasonCode: json[r'reasonCode'] as String?,
      createInstant:
          (json[r'createInstant'] as num?)?.toInt() as ZonedDateTime?,
      id: json[r'id'] as String?,
      info: json[r'info'] != null
          ? EventInfo.fromJson(json[r'info']! as Map<String, Object?>)
          : null,
      tenantId: json[r'tenantId'] as String?,
      type: json[r'type'] != null
          ? EventType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationIds = this.applicationIds;
    var action = this.action;
    var actionId = this.actionId;
    var actioneeUserId = this.actioneeUserId;
    var actionerUserId = this.actionerUserId;
    var comment = this.comment;
    var email = this.email;
    var emailedUser = this.emailedUser;
    var expiry = this.expiry;
    var localizedAction = this.localizedAction;
    var localizedDuration = this.localizedDuration;
    var localizedOption = this.localizedOption;
    var localizedReason = this.localizedReason;
    var notifyUser = this.notifyUser;
    var option = this.option;
    var phase = this.phase;
    var reason = this.reason;
    var reasonCode = this.reasonCode;
    var createInstant = this.createInstant;
    var id = this.id;
    var info = this.info;
    var tenantId = this.tenantId;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'applicationIds'] = applicationIds;
    if (action != null) {
      json[r'action'] = action;
    }
    if (actionId != null) {
      json[r'actionId'] = actionId;
    }
    if (actioneeUserId != null) {
      json[r'actioneeUserId'] = actioneeUserId;
    }
    if (actionerUserId != null) {
      json[r'actionerUserId'] = actionerUserId;
    }
    if (comment != null) {
      json[r'comment'] = comment;
    }
    if (email != null) {
      json[r'email'] = email.toJson();
    }
    json[r'emailedUser'] = emailedUser;
    if (expiry != null) {
      json[r'expiry'] = expiry.toJson();
    }
    if (localizedAction != null) {
      json[r'localizedAction'] = localizedAction;
    }
    if (localizedDuration != null) {
      json[r'localizedDuration'] = localizedDuration;
    }
    if (localizedOption != null) {
      json[r'localizedOption'] = localizedOption;
    }
    if (localizedReason != null) {
      json[r'localizedReason'] = localizedReason;
    }
    json[r'notifyUser'] = notifyUser;
    if (option != null) {
      json[r'option'] = option;
    }
    if (phase != null) {
      json[r'phase'] = phase.value;
    }
    if (reason != null) {
      json[r'reason'] = reason;
    }
    if (reasonCode != null) {
      json[r'reasonCode'] = reasonCode;
    }
    if (createInstant != null) {
      json[r'createInstant'] = createInstant.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (info != null) {
      json[r'info'] = info.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  UserActionEvent copyWith(
      {List<String>? applicationIds,
      String? action,
      String? actionId,
      String? actioneeUserId,
      String? actionerUserId,
      String? comment,
      Email? email,
      bool? emailedUser,
      ZonedDateTime? expiry,
      String? localizedAction,
      String? localizedDuration,
      String? localizedOption,
      String? localizedReason,
      bool? notifyUser,
      String? option,
      UserActionPhase? phase,
      String? reason,
      String? reasonCode,
      ZonedDateTime? createInstant,
      String? id,
      EventInfo? info,
      String? tenantId,
      EventType? type}) {
    return UserActionEvent(
      applicationIds: applicationIds ?? this.applicationIds,
      action: action ?? this.action,
      actionId: actionId ?? this.actionId,
      actioneeUserId: actioneeUserId ?? this.actioneeUserId,
      actionerUserId: actionerUserId ?? this.actionerUserId,
      comment: comment ?? this.comment,
      email: email ?? this.email,
      emailedUser: emailedUser ?? this.emailedUser,
      expiry: expiry ?? this.expiry,
      localizedAction: localizedAction ?? this.localizedAction,
      localizedDuration: localizedDuration ?? this.localizedDuration,
      localizedOption: localizedOption ?? this.localizedOption,
      localizedReason: localizedReason ?? this.localizedReason,
      notifyUser: notifyUser ?? this.notifyUser,
      option: option ?? this.option,
      phase: phase ?? this.phase,
      reason: reason ?? this.reason,
      reasonCode: reasonCode ?? this.reasonCode,
      createInstant: createInstant ?? this.createInstant,
      id: id ?? this.id,
      info: info ?? this.info,
      tenantId: tenantId ?? this.tenantId,
      type: type ?? this.type,
    );
  }
}

/// A log for an action that was taken on a User.
class UserActionLog {
  final String? actioneeUserId;
  final String? actionerUserId;
  final List<String> applicationIds;
  final String? comment;
  final bool emailUserOnEnd;
  final bool endEventSent;
  final ZonedDateTime? expiry;
  final LogHistory? history;
  final String? id;
  final ZonedDateTime? insertInstant;
  final String? localizedName;
  final String? localizedOption;
  final String? localizedReason;
  final String? name;
  final bool notifyUserOnEnd;
  final String? option;
  final String? reason;
  final String? reasonCode;
  final String? userActionId;

  UserActionLog(
      {this.actioneeUserId,
      this.actionerUserId,
      List<String>? applicationIds,
      this.comment,
      bool? emailUserOnEnd,
      bool? endEventSent,
      this.expiry,
      this.history,
      this.id,
      this.insertInstant,
      this.localizedName,
      this.localizedOption,
      this.localizedReason,
      this.name,
      bool? notifyUserOnEnd,
      this.option,
      this.reason,
      this.reasonCode,
      this.userActionId})
      : applicationIds = applicationIds ?? [],
        emailUserOnEnd = emailUserOnEnd ?? false,
        endEventSent = endEventSent ?? false,
        notifyUserOnEnd = notifyUserOnEnd ?? false;

  factory UserActionLog.fromJson(Map<String, Object?> json) {
    return UserActionLog(
      actioneeUserId: json[r'actioneeUserId'] as String?,
      actionerUserId: json[r'actionerUserId'] as String?,
      applicationIds: (json[r'applicationIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      comment: json[r'comment'] as String?,
      emailUserOnEnd: json[r'emailUserOnEnd'] as bool? ?? false,
      endEventSent: json[r'endEventSent'] as bool? ?? false,
      expiry: (json[r'expiry'] as num?)?.toInt() as ZonedDateTime?,
      history: json[r'history'] != null
          ? LogHistory.fromJson(json[r'history']! as Map<String, Object?>)
          : null,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      localizedName: json[r'localizedName'] as String?,
      localizedOption: json[r'localizedOption'] as String?,
      localizedReason: json[r'localizedReason'] as String?,
      name: json[r'name'] as String?,
      notifyUserOnEnd: json[r'notifyUserOnEnd'] as bool? ?? false,
      option: json[r'option'] as String?,
      reason: json[r'reason'] as String?,
      reasonCode: json[r'reasonCode'] as String?,
      userActionId: json[r'userActionId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var actioneeUserId = this.actioneeUserId;
    var actionerUserId = this.actionerUserId;
    var applicationIds = this.applicationIds;
    var comment = this.comment;
    var emailUserOnEnd = this.emailUserOnEnd;
    var endEventSent = this.endEventSent;
    var expiry = this.expiry;
    var history = this.history;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var localizedName = this.localizedName;
    var localizedOption = this.localizedOption;
    var localizedReason = this.localizedReason;
    var name = this.name;
    var notifyUserOnEnd = this.notifyUserOnEnd;
    var option = this.option;
    var reason = this.reason;
    var reasonCode = this.reasonCode;
    var userActionId = this.userActionId;

    final json = <String, Object?>{};
    if (actioneeUserId != null) {
      json[r'actioneeUserId'] = actioneeUserId;
    }
    if (actionerUserId != null) {
      json[r'actionerUserId'] = actionerUserId;
    }
    json[r'applicationIds'] = applicationIds;
    if (comment != null) {
      json[r'comment'] = comment;
    }
    json[r'emailUserOnEnd'] = emailUserOnEnd;
    json[r'endEventSent'] = endEventSent;
    if (expiry != null) {
      json[r'expiry'] = expiry.toJson();
    }
    if (history != null) {
      json[r'history'] = history.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (localizedName != null) {
      json[r'localizedName'] = localizedName;
    }
    if (localizedOption != null) {
      json[r'localizedOption'] = localizedOption;
    }
    if (localizedReason != null) {
      json[r'localizedReason'] = localizedReason;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'notifyUserOnEnd'] = notifyUserOnEnd;
    if (option != null) {
      json[r'option'] = option;
    }
    if (reason != null) {
      json[r'reason'] = reason;
    }
    if (reasonCode != null) {
      json[r'reasonCode'] = reasonCode;
    }
    if (userActionId != null) {
      json[r'userActionId'] = userActionId;
    }
    return json;
  }

  UserActionLog copyWith(
      {String? actioneeUserId,
      String? actionerUserId,
      List<String>? applicationIds,
      String? comment,
      bool? emailUserOnEnd,
      bool? endEventSent,
      ZonedDateTime? expiry,
      LogHistory? history,
      String? id,
      ZonedDateTime? insertInstant,
      String? localizedName,
      String? localizedOption,
      String? localizedReason,
      String? name,
      bool? notifyUserOnEnd,
      String? option,
      String? reason,
      String? reasonCode,
      String? userActionId}) {
    return UserActionLog(
      actioneeUserId: actioneeUserId ?? this.actioneeUserId,
      actionerUserId: actionerUserId ?? this.actionerUserId,
      applicationIds: applicationIds ?? this.applicationIds,
      comment: comment ?? this.comment,
      emailUserOnEnd: emailUserOnEnd ?? this.emailUserOnEnd,
      endEventSent: endEventSent ?? this.endEventSent,
      expiry: expiry ?? this.expiry,
      history: history ?? this.history,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      localizedName: localizedName ?? this.localizedName,
      localizedOption: localizedOption ?? this.localizedOption,
      localizedReason: localizedReason ?? this.localizedReason,
      name: name ?? this.name,
      notifyUserOnEnd: notifyUserOnEnd ?? this.notifyUserOnEnd,
      option: option ?? this.option,
      reason: reason ?? this.reason,
      reasonCode: reasonCode ?? this.reasonCode,
      userActionId: userActionId ?? this.userActionId,
    );
  }
}

/// Models content user action options.
class UserActionOption {
  final LocalizedStrings? localizedNames;
  final String? name;

  UserActionOption({this.localizedNames, this.name});

  factory UserActionOption.fromJson(Map<String, Object?> json) {
    return UserActionOption(
      localizedNames: json[r'localizedNames'] != null
          ? LocalizedStrings.fromJson(
              json[r'localizedNames']! as Map<String, Object?>)
          : null,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var localizedNames = this.localizedNames;
    var name = this.name;

    final json = <String, Object?>{};
    if (localizedNames != null) {
      json[r'localizedNames'] = localizedNames.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  UserActionOption copyWith({LocalizedStrings? localizedNames, String? name}) {
    return UserActionOption(
      localizedNames: localizedNames ?? this.localizedNames,
      name: name ?? this.name,
    );
  }
}

/// Models action reasons.
class UserActionReason {
  final String? code;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final LocalizedStrings? localizedTexts;
  final String? text;

  UserActionReason(
      {this.code,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.localizedTexts,
      this.text});

  factory UserActionReason.fromJson(Map<String, Object?> json) {
    return UserActionReason(
      code: json[r'code'] as String?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      localizedTexts: json[r'localizedTexts'] != null
          ? LocalizedStrings.fromJson(
              json[r'localizedTexts']! as Map<String, Object?>)
          : null,
      text: json[r'text'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var code = this.code;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var localizedTexts = this.localizedTexts;
    var text = this.text;

    final json = <String, Object?>{};
    if (code != null) {
      json[r'code'] = code;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (localizedTexts != null) {
      json[r'localizedTexts'] = localizedTexts.toJson();
    }
    if (text != null) {
      json[r'text'] = text;
    }
    return json;
  }

  UserActionReason copyWith(
      {String? code,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      LocalizedStrings? localizedTexts,
      String? text}) {
    return UserActionReason(
      code: code ?? this.code,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      localizedTexts: localizedTexts ?? this.localizedTexts,
      text: text ?? this.text,
    );
  }
}

/// User Action Reason API request object.
class UserActionReasonRequest {
  final UserActionReason? userActionReason;

  UserActionReasonRequest({this.userActionReason});

  factory UserActionReasonRequest.fromJson(Map<String, Object?> json) {
    return UserActionReasonRequest(
      userActionReason: json[r'userActionReason'] != null
          ? UserActionReason.fromJson(
              json[r'userActionReason']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var userActionReason = this.userActionReason;

    final json = <String, Object?>{};
    if (userActionReason != null) {
      json[r'userActionReason'] = userActionReason.toJson();
    }
    return json;
  }

  UserActionReasonRequest copyWith({UserActionReason? userActionReason}) {
    return UserActionReasonRequest(
      userActionReason: userActionReason ?? this.userActionReason,
    );
  }
}

/// User Action Reason API response object.
class UserActionReasonResponse {
  final UserActionReason? userActionReason;
  final List<UserActionReason> userActionReasons;

  UserActionReasonResponse(
      {this.userActionReason, List<UserActionReason>? userActionReasons})
      : userActionReasons = userActionReasons ?? [];

  factory UserActionReasonResponse.fromJson(Map<String, Object?> json) {
    return UserActionReasonResponse(
      userActionReason: json[r'userActionReason'] != null
          ? UserActionReason.fromJson(
              json[r'userActionReason']! as Map<String, Object?>)
          : null,
      userActionReasons: (json[r'userActionReasons'] as List<Object?>?)
              ?.map((i) => UserActionReason.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var userActionReason = this.userActionReason;
    var userActionReasons = this.userActionReasons;

    final json = <String, Object?>{};
    if (userActionReason != null) {
      json[r'userActionReason'] = userActionReason.toJson();
    }
    json[r'userActionReasons'] =
        userActionReasons.map((i) => i.toJson()).toList();
    return json;
  }

  UserActionReasonResponse copyWith(
      {UserActionReason? userActionReason,
      List<UserActionReason>? userActionReasons}) {
    return UserActionReasonResponse(
      userActionReason: userActionReason ?? this.userActionReason,
      userActionReasons: userActionReasons ?? this.userActionReasons,
    );
  }
}

/// User Action API request object.
class UserActionRequest {
  final UserAction? userAction;

  UserActionRequest({this.userAction});

  factory UserActionRequest.fromJson(Map<String, Object?> json) {
    return UserActionRequest(
      userAction: json[r'userAction'] != null
          ? UserAction.fromJson(json[r'userAction']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var userAction = this.userAction;

    final json = <String, Object?>{};
    if (userAction != null) {
      json[r'userAction'] = userAction.toJson();
    }
    return json;
  }

  UserActionRequest copyWith({UserAction? userAction}) {
    return UserActionRequest(
      userAction: userAction ?? this.userAction,
    );
  }
}

/// User Action API response object.
class UserActionResponse {
  final UserAction? userAction;
  final List<UserAction> userActions;

  UserActionResponse({this.userAction, List<UserAction>? userActions})
      : userActions = userActions ?? [];

  factory UserActionResponse.fromJson(Map<String, Object?> json) {
    return UserActionResponse(
      userAction: json[r'userAction'] != null
          ? UserAction.fromJson(json[r'userAction']! as Map<String, Object?>)
          : null,
      userActions: (json[r'userActions'] as List<Object?>?)
              ?.map((i) =>
                  UserAction.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var userAction = this.userAction;
    var userActions = this.userActions;

    final json = <String, Object?>{};
    if (userAction != null) {
      json[r'userAction'] = userAction.toJson();
    }
    json[r'userActions'] = userActions.map((i) => i.toJson()).toList();
    return json;
  }

  UserActionResponse copyWith(
      {UserAction? userAction, List<UserAction>? userActions}) {
    return UserActionResponse(
      userAction: userAction ?? this.userAction,
      userActions: userActions ?? this.userActions,
    );
  }
}

/// Models the User Bulk Create Event.
class UserBulkCreateEvent {
  final List<User> users;
  final ZonedDateTime? createInstant;
  final String? id;
  final EventInfo? info;
  final String? tenantId;
  final EventType? type;

  UserBulkCreateEvent(
      {List<User>? users,
      this.createInstant,
      this.id,
      this.info,
      this.tenantId,
      this.type})
      : users = users ?? [];

  factory UserBulkCreateEvent.fromJson(Map<String, Object?> json) {
    return UserBulkCreateEvent(
      users: (json[r'users'] as List<Object?>?)
              ?.map(
                  (i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      createInstant:
          (json[r'createInstant'] as num?)?.toInt() as ZonedDateTime?,
      id: json[r'id'] as String?,
      info: json[r'info'] != null
          ? EventInfo.fromJson(json[r'info']! as Map<String, Object?>)
          : null,
      tenantId: json[r'tenantId'] as String?,
      type: json[r'type'] != null
          ? EventType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var users = this.users;
    var createInstant = this.createInstant;
    var id = this.id;
    var info = this.info;
    var tenantId = this.tenantId;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'users'] = users.map((i) => i.toJson()).toList();
    if (createInstant != null) {
      json[r'createInstant'] = createInstant.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (info != null) {
      json[r'info'] = info.toJson();
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  UserBulkCreateEvent copyWith(
      {List<User>? users,
      ZonedDateTime? createInstant,
      String? id,
      EventInfo? info,
      String? tenantId,
      EventType? type}) {
    return UserBulkCreateEvent(
      users: users ?? this.users,
      createInstant: createInstant ?? this.createInstant,
      id: id ?? this.id,
      info: info ?? this.info,
      tenantId: tenantId ?? this.tenantId,
      type: type ?? this.type,
    );
  }
}

/// A log for an event that happened to a User.
class UserComment {
  final String? comment;
  final String? commenterId;
  final String? id;
  final ZonedDateTime? insertInstant;
  final String? userId;

  UserComment(
      {this.comment,
      this.commenterId,
      this.id,
      this.insertInstant,
      this.userId});

  factory UserComment.fromJson(Map<String, Object?> json) {
    return UserComment(
      comment: json[r'comment'] as String?,
      commenterId: json[r'commenterId'] as String?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      userId: json[r'userId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var comment = this.comment;
    var commenterId = this.commenterId;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var userId = this.userId;

    final json = <String, Object?>{};
    if (comment != null) {
      json[r'comment'] = comment;
    }
    if (commenterId != null) {
      json[r'commenterId'] = commenterId;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    return json;
  }

  UserComment copyWith(
      {String? comment,
      String? commenterId,
      String? id,
      ZonedDateTime? insertInstant,
      String? userId}) {
    return UserComment(
      comment: comment ?? this.comment,
      commenterId: commenterId ?? this.commenterId,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      userId: userId ?? this.userId,
    );
  }
}

class UserCommentRequest {
  final UserComment? userComment;

  UserCommentRequest({this.userComment});

  factory UserCommentRequest.fromJson(Map<String, Object?> json) {
    return UserCommentRequest(
      userComment: json[r'userComment'] != null
          ? UserComment.fromJson(json[r'userComment']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var userComment = this.userComment;

    final json = <String, Object?>{};
    if (userComment != null) {
      json[r'userComment'] = userComment.toJson();
    }
    return json;
  }

  UserCommentRequest copyWith({UserComment? userComment}) {
    return UserCommentRequest(
      userComment: userComment ?? this.userComment,
    );
  }
}

/// User Comment Response
class UserCommentResponse {
  final UserComment? userComment;
  final List<UserComment> userComments;

  UserCommentResponse({this.userComment, List<UserComment>? userComments})
      : userComments = userComments ?? [];

  factory UserCommentResponse.fromJson(Map<String, Object?> json) {
    return UserCommentResponse(
      userComment: json[r'userComment'] != null
          ? UserComment.fromJson(json[r'userComment']! as Map<String, Object?>)
          : null,
      userComments: (json[r'userComments'] as List<Object?>?)
              ?.map((i) =>
                  UserComment.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var userComment = this.userComment;
    var userComments = this.userComments;

    final json = <String, Object?>{};
    if (userComment != null) {
      json[r'userComment'] = userComment.toJson();
    }
    json[r'userComments'] = userComments.map((i) => i.toJson()).toList();
    return json;
  }

  UserCommentResponse copyWith(
      {UserComment? userComment, List<UserComment>? userComments}) {
    return UserCommentResponse(
      userComment: userComment ?? this.userComment,
      userComments: userComments ?? this.userComments,
    );
  }
}

/// Search criteria for user comments.
class UserCommentSearchCriteria {
  final String? comment;
  final String? commenterId;
  final String? tenantId;
  final String? userId;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  UserCommentSearchCriteria(
      {this.comment,
      this.commenterId,
      this.tenantId,
      this.userId,
      this.numberOfResults,
      this.orderBy,
      this.startRow});

  factory UserCommentSearchCriteria.fromJson(Map<String, Object?> json) {
    return UserCommentSearchCriteria(
      comment: json[r'comment'] as String?,
      commenterId: json[r'commenterId'] as String?,
      tenantId: json[r'tenantId'] as String?,
      userId: json[r'userId'] as String?,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var comment = this.comment;
    var commenterId = this.commenterId;
    var tenantId = this.tenantId;
    var userId = this.userId;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (comment != null) {
      json[r'comment'] = comment;
    }
    if (commenterId != null) {
      json[r'commenterId'] = commenterId;
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  UserCommentSearchCriteria copyWith(
      {String? comment,
      String? commenterId,
      String? tenantId,
      String? userId,
      int? numberOfResults,
      String? orderBy,
      int? startRow}) {
    return UserCommentSearchCriteria(
      comment: comment ?? this.comment,
      commenterId: commenterId ?? this.commenterId,
      tenantId: tenantId ?? this.tenantId,
      userId: userId ?? this.userId,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Search request for user comments
class UserCommentSearchRequest {
  final UserCommentSearchCriteria? search;

  UserCommentSearchRequest({this.search});

  factory UserCommentSearchRequest.fromJson(Map<String, Object?> json) {
    return UserCommentSearchRequest(
      search: json[r'search'] != null
          ? UserCommentSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  UserCommentSearchRequest copyWith({UserCommentSearchCriteria? search}) {
    return UserCommentSearchRequest(
      search: search ?? this.search,
    );
  }
}

/// User comment search response
class UserCommentSearchResponse {
  final int? total;
  final List<UserComment> userComments;

  UserCommentSearchResponse({this.total, List<UserComment>? userComments})
      : userComments = userComments ?? [];

  factory UserCommentSearchResponse.fromJson(Map<String, Object?> json) {
    return UserCommentSearchResponse(
      total: (json[r'total'] as num?)?.toInt(),
      userComments: (json[r'userComments'] as List<Object?>?)
              ?.map((i) =>
                  UserComment.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var total = this.total;
    var userComments = this.userComments;

    final json = <String, Object?>{};
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'userComments'] = userComments.map((i) => i.toJson()).toList();
    return json;
  }

  UserCommentSearchResponse copyWith(
      {int? total, List<UserComment>? userComments}) {
    return UserCommentSearchResponse(
      total: total ?? this.total,
      userComments: userComments ?? this.userComments,
    );
  }
}

/// Models a User consent.
class UserConsent {
  final Map<String, dynamic>? data;
  final Consent? consent;
  final String? consentId;
  final String? giverUserId;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final ConsentStatus? status;
  final String? userId;
  final List<String> values;

  UserConsent(
      {this.data,
      this.consent,
      this.consentId,
      this.giverUserId,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.status,
      this.userId,
      List<String>? values})
      : values = values ?? [];

  factory UserConsent.fromJson(Map<String, Object?> json) {
    return UserConsent(
      data: json[r'data'] as Map<String, Object?>?,
      consent: json[r'consent'] != null
          ? Consent.fromJson(json[r'consent']! as Map<String, Object?>)
          : null,
      consentId: json[r'consentId'] as String?,
      giverUserId: json[r'giverUserId'] as String?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      status: json[r'status'] != null
          ? ConsentStatus.fromValue(json[r'status']! as String)
          : null,
      userId: json[r'userId'] as String?,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var consent = this.consent;
    var consentId = this.consentId;
    var giverUserId = this.giverUserId;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var status = this.status;
    var userId = this.userId;
    var values = this.values;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (consent != null) {
      json[r'consent'] = consent.toJson();
    }
    if (consentId != null) {
      json[r'consentId'] = consentId;
    }
    if (giverUserId != null) {
      json[r'giverUserId'] = giverUserId;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (status != null) {
      json[r'status'] = status.value;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    json[r'values'] = values;
    return json;
  }

  UserConsent copyWith(
      {Map<String, dynamic>? data,
      Consent? consent,
      String? consentId,
      String? giverUserId,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      ConsentStatus? status,
      String? userId,
      List<String>? values}) {
    return UserConsent(
      data: data ?? this.data,
      consent: consent ?? this.consent,
      consentId: consentId ?? this.consentId,
      giverUserId: giverUserId ?? this.giverUserId,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      status: status ?? this.status,
      userId: userId ?? this.userId,
      values: values ?? this.values,
    );
  }
}

/// API response for User consent.
class UserConsentRequest {
  final UserConsent? userConsent;

  UserConsentRequest({this.userConsent});

  factory UserConsentRequest.fromJson(Map<String, Object?> json) {
    return UserConsentRequest(
      userConsent: json[r'userConsent'] != null
          ? UserConsent.fromJson(json[r'userConsent']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var userConsent = this.userConsent;

    final json = <String, Object?>{};
    if (userConsent != null) {
      json[r'userConsent'] = userConsent.toJson();
    }
    return json;
  }

  UserConsentRequest copyWith({UserConsent? userConsent}) {
    return UserConsentRequest(
      userConsent: userConsent ?? this.userConsent,
    );
  }
}

/// API response for User consent.
class UserConsentResponse {
  final UserConsent? userConsent;
  final List<UserConsent> userConsents;

  UserConsentResponse({this.userConsent, List<UserConsent>? userConsents})
      : userConsents = userConsents ?? [];

  factory UserConsentResponse.fromJson(Map<String, Object?> json) {
    return UserConsentResponse(
      userConsent: json[r'userConsent'] != null
          ? UserConsent.fromJson(json[r'userConsent']! as Map<String, Object?>)
          : null,
      userConsents: (json[r'userConsents'] as List<Object?>?)
              ?.map((i) =>
                  UserConsent.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var userConsent = this.userConsent;
    var userConsents = this.userConsents;

    final json = <String, Object?>{};
    if (userConsent != null) {
      json[r'userConsent'] = userConsent.toJson();
    }
    json[r'userConsents'] = userConsents.map((i) => i.toJson()).toList();
    return json;
  }

  UserConsentResponse copyWith(
      {UserConsent? userConsent, List<UserConsent>? userConsents}) {
    return UserConsentResponse(
      userConsent: userConsent ?? this.userConsent,
      userConsents: userConsents ?? this.userConsents,
    );
  }
}

/// Models the User Created Event.  <p>  This is different than the user.create
/// event in that it will be sent after the user has been created. This event
/// cannot be made transactional.
class UserCreateCompleteEvent {
  final User? user;

  UserCreateCompleteEvent({this.user});

  factory UserCreateCompleteEvent.fromJson(Map<String, Object?> json) {
    return UserCreateCompleteEvent(
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var user = this.user;

    final json = <String, Object?>{};
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserCreateCompleteEvent copyWith({User? user}) {
    return UserCreateCompleteEvent(
      user: user ?? this.user,
    );
  }
}

/// Models the User Create Event.
class UserCreateEvent {
  final User? user;

  UserCreateEvent({this.user});

  factory UserCreateEvent.fromJson(Map<String, Object?> json) {
    return UserCreateEvent(
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var user = this.user;

    final json = <String, Object?>{};
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserCreateEvent copyWith({User? user}) {
    return UserCreateEvent(
      user: user ?? this.user,
    );
  }
}

/// Models the User Deactivate Event.
class UserDeactivateEvent {
  final User? user;

  UserDeactivateEvent({this.user});

  factory UserDeactivateEvent.fromJson(Map<String, Object?> json) {
    return UserDeactivateEvent(
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var user = this.user;

    final json = <String, Object?>{};
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserDeactivateEvent copyWith({User? user}) {
    return UserDeactivateEvent(
      user: user ?? this.user,
    );
  }
}

/// Models the User Event (and can be converted to JSON) that is used for all
/// user modifications (create, update,  delete).  <p>  This is different than
/// user.delete because it is sent after the tx is committed, this cannot be
/// transactional.
class UserDeleteCompleteEvent {
  final User? user;

  UserDeleteCompleteEvent({this.user});

  factory UserDeleteCompleteEvent.fromJson(Map<String, Object?> json) {
    return UserDeleteCompleteEvent(
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var user = this.user;

    final json = <String, Object?>{};
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserDeleteCompleteEvent copyWith({User? user}) {
    return UserDeleteCompleteEvent(
      user: user ?? this.user,
    );
  }
}

/// Models the User Event (and can be converted to JSON) that is used for all
/// user modifications (create, update,  delete).
class UserDeleteEvent {
  final User? user;

  UserDeleteEvent({this.user});

  factory UserDeleteEvent.fromJson(Map<String, Object?> json) {
    return UserDeleteEvent(
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var user = this.user;

    final json = <String, Object?>{};
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserDeleteEvent copyWith({User? user}) {
    return UserDeleteEvent(
      user: user ?? this.user,
    );
  }
}

/// User API delete request object.
class UserDeleteRequest {
  final bool dryRun;
  final bool hardDelete;
  final int? limit;
  final String? query;
  final String? queryString;
  final List<String> userIds;
  final EventInfo? eventInfo;

  UserDeleteRequest(
      {bool? dryRun,
      bool? hardDelete,
      this.limit,
      this.query,
      this.queryString,
      List<String>? userIds,
      this.eventInfo})
      : dryRun = dryRun ?? false,
        hardDelete = hardDelete ?? false,
        userIds = userIds ?? [];

  factory UserDeleteRequest.fromJson(Map<String, Object?> json) {
    return UserDeleteRequest(
      dryRun: json[r'dryRun'] as bool? ?? false,
      hardDelete: json[r'hardDelete'] as bool? ?? false,
      limit: (json[r'limit'] as num?)?.toInt(),
      query: json[r'query'] as String?,
      queryString: json[r'queryString'] as String?,
      userIds: (json[r'userIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var dryRun = this.dryRun;
    var hardDelete = this.hardDelete;
    var limit = this.limit;
    var query = this.query;
    var queryString = this.queryString;
    var userIds = this.userIds;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    json[r'dryRun'] = dryRun;
    json[r'hardDelete'] = hardDelete;
    if (limit != null) {
      json[r'limit'] = limit;
    }
    if (query != null) {
      json[r'query'] = query;
    }
    if (queryString != null) {
      json[r'queryString'] = queryString;
    }
    json[r'userIds'] = userIds;
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  UserDeleteRequest copyWith(
      {bool? dryRun,
      bool? hardDelete,
      int? limit,
      String? query,
      String? queryString,
      List<String>? userIds,
      EventInfo? eventInfo}) {
    return UserDeleteRequest(
      dryRun: dryRun ?? this.dryRun,
      hardDelete: hardDelete ?? this.hardDelete,
      limit: limit ?? this.limit,
      query: query ?? this.query,
      queryString: queryString ?? this.queryString,
      userIds: userIds ?? this.userIds,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

/// User API bulk response object.
class UserDeleteResponse {
  final bool dryRun;
  final bool hardDelete;
  final int? total;
  final List<String> userIds;

  UserDeleteResponse(
      {bool? dryRun, bool? hardDelete, this.total, List<String>? userIds})
      : dryRun = dryRun ?? false,
        hardDelete = hardDelete ?? false,
        userIds = userIds ?? [];

  factory UserDeleteResponse.fromJson(Map<String, Object?> json) {
    return UserDeleteResponse(
      dryRun: json[r'dryRun'] as bool? ?? false,
      hardDelete: json[r'hardDelete'] as bool? ?? false,
      total: (json[r'total'] as num?)?.toInt(),
      userIds: (json[r'userIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var dryRun = this.dryRun;
    var hardDelete = this.hardDelete;
    var total = this.total;
    var userIds = this.userIds;

    final json = <String, Object?>{};
    json[r'dryRun'] = dryRun;
    json[r'hardDelete'] = hardDelete;
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'userIds'] = userIds;
    return json;
  }

  UserDeleteResponse copyWith(
      {bool? dryRun, bool? hardDelete, int? total, List<String>? userIds}) {
    return UserDeleteResponse(
      dryRun: dryRun ?? this.dryRun,
      hardDelete: hardDelete ?? this.hardDelete,
      total: total ?? this.total,
      userIds: userIds ?? this.userIds,
    );
  }
}

/// User API delete request object for a single user.
class UserDeleteSingleRequest {
  final bool hardDelete;
  final EventInfo? eventInfo;

  UserDeleteSingleRequest({bool? hardDelete, this.eventInfo})
      : hardDelete = hardDelete ?? false;

  factory UserDeleteSingleRequest.fromJson(Map<String, Object?> json) {
    return UserDeleteSingleRequest(
      hardDelete: json[r'hardDelete'] as bool? ?? false,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var hardDelete = this.hardDelete;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    json[r'hardDelete'] = hardDelete;
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  UserDeleteSingleRequest copyWith({bool? hardDelete, EventInfo? eventInfo}) {
    return UserDeleteSingleRequest(
      hardDelete: hardDelete ?? this.hardDelete,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

/// Models an event where a user's email is updated outside of a forgot  change
/// password workflow.
class UserEmailUpdateEvent {
  final String? previousEmail;
  final User? user;

  UserEmailUpdateEvent({this.previousEmail, this.user});

  factory UserEmailUpdateEvent.fromJson(Map<String, Object?> json) {
    return UserEmailUpdateEvent(
      previousEmail: json[r'previousEmail'] as String?,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var previousEmail = this.previousEmail;
    var user = this.user;

    final json = <String, Object?>{};
    if (previousEmail != null) {
      json[r'previousEmail'] = previousEmail;
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserEmailUpdateEvent copyWith({String? previousEmail, User? user}) {
    return UserEmailUpdateEvent(
      previousEmail: previousEmail ?? this.previousEmail,
      user: user ?? this.user,
    );
  }
}

/// Models the User Email Verify Event.
class UserEmailVerifiedEvent {
  final User? user;

  UserEmailVerifiedEvent({this.user});

  factory UserEmailVerifiedEvent.fromJson(Map<String, Object?> json) {
    return UserEmailVerifiedEvent(
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var user = this.user;

    final json = <String, Object?>{};
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserEmailVerifiedEvent copyWith({User? user}) {
    return UserEmailVerifiedEvent(
      user: user ?? this.user,
    );
  }
}

/// Models the User Identity Provider Link Event.
class UserIdentityProviderLinkEvent {
  final IdentityProviderLink? identityProviderLink;
  final User? user;

  UserIdentityProviderLinkEvent({this.identityProviderLink, this.user});

  factory UserIdentityProviderLinkEvent.fromJson(Map<String, Object?> json) {
    return UserIdentityProviderLinkEvent(
      identityProviderLink: json[r'identityProviderLink'] != null
          ? IdentityProviderLink.fromJson(
              json[r'identityProviderLink']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var identityProviderLink = this.identityProviderLink;
    var user = this.user;

    final json = <String, Object?>{};
    if (identityProviderLink != null) {
      json[r'identityProviderLink'] = identityProviderLink.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserIdentityProviderLinkEvent copyWith(
      {IdentityProviderLink? identityProviderLink, User? user}) {
    return UserIdentityProviderLinkEvent(
      identityProviderLink: identityProviderLink ?? this.identityProviderLink,
      user: user ?? this.user,
    );
  }
}

/// Models the User Identity Provider Unlink Event.
class UserIdentityProviderUnlinkEvent {
  final IdentityProviderLink? identityProviderLink;
  final User? user;

  UserIdentityProviderUnlinkEvent({this.identityProviderLink, this.user});

  factory UserIdentityProviderUnlinkEvent.fromJson(Map<String, Object?> json) {
    return UserIdentityProviderUnlinkEvent(
      identityProviderLink: json[r'identityProviderLink'] != null
          ? IdentityProviderLink.fromJson(
              json[r'identityProviderLink']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var identityProviderLink = this.identityProviderLink;
    var user = this.user;

    final json = <String, Object?>{};
    if (identityProviderLink != null) {
      json[r'identityProviderLink'] = identityProviderLink.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserIdentityProviderUnlinkEvent copyWith(
      {IdentityProviderLink? identityProviderLink, User? user}) {
    return UserIdentityProviderUnlinkEvent(
      identityProviderLink: identityProviderLink ?? this.identityProviderLink,
      user: user ?? this.user,
    );
  }
}

/// Models the User Login Failed Event.
class UserLoginFailedEvent {
  final String? applicationId;
  final String? authenticationType;
  final String? ipAddress;
  final UserLoginFailedReason? reason;
  final User? user;

  UserLoginFailedEvent(
      {this.applicationId,
      this.authenticationType,
      this.ipAddress,
      this.reason,
      this.user});

  factory UserLoginFailedEvent.fromJson(Map<String, Object?> json) {
    return UserLoginFailedEvent(
      applicationId: json[r'applicationId'] as String?,
      authenticationType: json[r'authenticationType'] as String?,
      ipAddress: json[r'ipAddress'] as String?,
      reason: json[r'reason'] != null
          ? UserLoginFailedReason.fromJson(
              json[r'reason']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var authenticationType = this.authenticationType;
    var ipAddress = this.ipAddress;
    var reason = this.reason;
    var user = this.user;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (authenticationType != null) {
      json[r'authenticationType'] = authenticationType;
    }
    if (ipAddress != null) {
      json[r'ipAddress'] = ipAddress;
    }
    if (reason != null) {
      json[r'reason'] = reason.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserLoginFailedEvent copyWith(
      {String? applicationId,
      String? authenticationType,
      String? ipAddress,
      UserLoginFailedReason? reason,
      User? user}) {
    return UserLoginFailedEvent(
      applicationId: applicationId ?? this.applicationId,
      authenticationType: authenticationType ?? this.authenticationType,
      ipAddress: ipAddress ?? this.ipAddress,
      reason: reason ?? this.reason,
      user: user ?? this.user,
    );
  }
}

/// The reason for the login failure.
class UserLoginFailedReason {
  final String? code;
  final String? lambdaId;
  final Errors? lambdaResult;

  UserLoginFailedReason({this.code, this.lambdaId, this.lambdaResult});

  factory UserLoginFailedReason.fromJson(Map<String, Object?> json) {
    return UserLoginFailedReason(
      code: json[r'code'] as String?,
      lambdaId: json[r'lambdaId'] as String?,
      lambdaResult: json[r'lambdaResult'] != null
          ? Errors.fromJson(json[r'lambdaResult']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var code = this.code;
    var lambdaId = this.lambdaId;
    var lambdaResult = this.lambdaResult;

    final json = <String, Object?>{};
    if (code != null) {
      json[r'code'] = code;
    }
    if (lambdaId != null) {
      json[r'lambdaId'] = lambdaId;
    }
    if (lambdaResult != null) {
      json[r'lambdaResult'] = lambdaResult.toJson();
    }
    return json;
  }

  UserLoginFailedReason copyWith(
      {String? code, String? lambdaId, Errors? lambdaResult}) {
    return UserLoginFailedReason(
      code: code ?? this.code,
      lambdaId: lambdaId ?? this.lambdaId,
      lambdaResult: lambdaResult ?? this.lambdaResult,
    );
  }
}

/// User login failed reason codes.
class UserLoginFailedReasonCode {
  UserLoginFailedReasonCode();

  factory UserLoginFailedReasonCode.fromJson(Map<String, Object?> json) {
    return UserLoginFailedReasonCode();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// Models an event where a user is being created with an "in-use" login Id
/// (email or username).
class UserLoginIdDuplicateOnCreateEvent {
  final String? duplicateEmail;
  final String? duplicateUsername;
  final User? existing;
  final User? user;

  UserLoginIdDuplicateOnCreateEvent(
      {this.duplicateEmail, this.duplicateUsername, this.existing, this.user});

  factory UserLoginIdDuplicateOnCreateEvent.fromJson(
      Map<String, Object?> json) {
    return UserLoginIdDuplicateOnCreateEvent(
      duplicateEmail: json[r'duplicateEmail'] as String?,
      duplicateUsername: json[r'duplicateUsername'] as String?,
      existing: json[r'existing'] != null
          ? User.fromJson(json[r'existing']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var duplicateEmail = this.duplicateEmail;
    var duplicateUsername = this.duplicateUsername;
    var existing = this.existing;
    var user = this.user;

    final json = <String, Object?>{};
    if (duplicateEmail != null) {
      json[r'duplicateEmail'] = duplicateEmail;
    }
    if (duplicateUsername != null) {
      json[r'duplicateUsername'] = duplicateUsername;
    }
    if (existing != null) {
      json[r'existing'] = existing.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserLoginIdDuplicateOnCreateEvent copyWith(
      {String? duplicateEmail,
      String? duplicateUsername,
      User? existing,
      User? user}) {
    return UserLoginIdDuplicateOnCreateEvent(
      duplicateEmail: duplicateEmail ?? this.duplicateEmail,
      duplicateUsername: duplicateUsername ?? this.duplicateUsername,
      existing: existing ?? this.existing,
      user: user ?? this.user,
    );
  }
}

/// Models an event where a user is being updated and tries to use an "in-use"
/// login Id (email or username).
class UserLoginIdDuplicateOnUpdateEvent {
  final String? duplicateEmail;
  final String? duplicateUsername;
  final User? existing;

  UserLoginIdDuplicateOnUpdateEvent(
      {this.duplicateEmail, this.duplicateUsername, this.existing});

  factory UserLoginIdDuplicateOnUpdateEvent.fromJson(
      Map<String, Object?> json) {
    return UserLoginIdDuplicateOnUpdateEvent(
      duplicateEmail: json[r'duplicateEmail'] as String?,
      duplicateUsername: json[r'duplicateUsername'] as String?,
      existing: json[r'existing'] != null
          ? User.fromJson(json[r'existing']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var duplicateEmail = this.duplicateEmail;
    var duplicateUsername = this.duplicateUsername;
    var existing = this.existing;

    final json = <String, Object?>{};
    if (duplicateEmail != null) {
      json[r'duplicateEmail'] = duplicateEmail;
    }
    if (duplicateUsername != null) {
      json[r'duplicateUsername'] = duplicateUsername;
    }
    if (existing != null) {
      json[r'existing'] = existing.toJson();
    }
    return json;
  }

  UserLoginIdDuplicateOnUpdateEvent copyWith(
      {String? duplicateEmail, String? duplicateUsername, User? existing}) {
    return UserLoginIdDuplicateOnUpdateEvent(
      duplicateEmail: duplicateEmail ?? this.duplicateEmail,
      duplicateUsername: duplicateUsername ?? this.duplicateUsername,
      existing: existing ?? this.existing,
    );
  }
}

/// Models the User Login event for a new device (un-recognized)
class UserLoginNewDeviceEvent {
  final String? applicationId;
  final String? authenticationType;
  final String? connectorId;
  final String? identityProviderId;
  final String? identityProviderName;
  final String? ipAddress;

  UserLoginNewDeviceEvent(
      {this.applicationId,
      this.authenticationType,
      this.connectorId,
      this.identityProviderId,
      this.identityProviderName,
      this.ipAddress});

  factory UserLoginNewDeviceEvent.fromJson(Map<String, Object?> json) {
    return UserLoginNewDeviceEvent(
      applicationId: json[r'applicationId'] as String?,
      authenticationType: json[r'authenticationType'] as String?,
      connectorId: json[r'connectorId'] as String?,
      identityProviderId: json[r'identityProviderId'] as String?,
      identityProviderName: json[r'identityProviderName'] as String?,
      ipAddress: json[r'ipAddress'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var authenticationType = this.authenticationType;
    var connectorId = this.connectorId;
    var identityProviderId = this.identityProviderId;
    var identityProviderName = this.identityProviderName;
    var ipAddress = this.ipAddress;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (authenticationType != null) {
      json[r'authenticationType'] = authenticationType;
    }
    if (connectorId != null) {
      json[r'connectorId'] = connectorId;
    }
    if (identityProviderId != null) {
      json[r'identityProviderId'] = identityProviderId;
    }
    if (identityProviderName != null) {
      json[r'identityProviderName'] = identityProviderName;
    }
    if (ipAddress != null) {
      json[r'ipAddress'] = ipAddress;
    }
    return json;
  }

  UserLoginNewDeviceEvent copyWith(
      {String? applicationId,
      String? authenticationType,
      String? connectorId,
      String? identityProviderId,
      String? identityProviderName,
      String? ipAddress}) {
    return UserLoginNewDeviceEvent(
      applicationId: applicationId ?? this.applicationId,
      authenticationType: authenticationType ?? this.authenticationType,
      connectorId: connectorId ?? this.connectorId,
      identityProviderId: identityProviderId ?? this.identityProviderId,
      identityProviderName: identityProviderName ?? this.identityProviderName,
      ipAddress: ipAddress ?? this.ipAddress,
    );
  }
}

/// Models the User Login Success Event.
class UserLoginSuccessEvent {
  final String? applicationId;
  final String? authenticationType;
  final String? connectorId;
  final String? identityProviderId;
  final String? identityProviderName;
  final String? ipAddress;
  final User? user;

  UserLoginSuccessEvent(
      {this.applicationId,
      this.authenticationType,
      this.connectorId,
      this.identityProviderId,
      this.identityProviderName,
      this.ipAddress,
      this.user});

  factory UserLoginSuccessEvent.fromJson(Map<String, Object?> json) {
    return UserLoginSuccessEvent(
      applicationId: json[r'applicationId'] as String?,
      authenticationType: json[r'authenticationType'] as String?,
      connectorId: json[r'connectorId'] as String?,
      identityProviderId: json[r'identityProviderId'] as String?,
      identityProviderName: json[r'identityProviderName'] as String?,
      ipAddress: json[r'ipAddress'] as String?,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var authenticationType = this.authenticationType;
    var connectorId = this.connectorId;
    var identityProviderId = this.identityProviderId;
    var identityProviderName = this.identityProviderName;
    var ipAddress = this.ipAddress;
    var user = this.user;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (authenticationType != null) {
      json[r'authenticationType'] = authenticationType;
    }
    if (connectorId != null) {
      json[r'connectorId'] = connectorId;
    }
    if (identityProviderId != null) {
      json[r'identityProviderId'] = identityProviderId;
    }
    if (identityProviderName != null) {
      json[r'identityProviderName'] = identityProviderName;
    }
    if (ipAddress != null) {
      json[r'ipAddress'] = ipAddress;
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserLoginSuccessEvent copyWith(
      {String? applicationId,
      String? authenticationType,
      String? connectorId,
      String? identityProviderId,
      String? identityProviderName,
      String? ipAddress,
      User? user}) {
    return UserLoginSuccessEvent(
      applicationId: applicationId ?? this.applicationId,
      authenticationType: authenticationType ?? this.authenticationType,
      connectorId: connectorId ?? this.connectorId,
      identityProviderId: identityProviderId ?? this.identityProviderId,
      identityProviderName: identityProviderName ?? this.identityProviderName,
      ipAddress: ipAddress ?? this.ipAddress,
      user: user ?? this.user,
    );
  }
}

/// Models the User Login event that is suspicious.
class UserLoginSuspiciousEvent {
  final List<dynamic> threatsDetected;
  final String? applicationId;
  final String? authenticationType;
  final String? connectorId;
  final String? identityProviderId;
  final String? identityProviderName;
  final String? ipAddress;

  UserLoginSuspiciousEvent(
      {List<dynamic>? threatsDetected,
      this.applicationId,
      this.authenticationType,
      this.connectorId,
      this.identityProviderId,
      this.identityProviderName,
      this.ipAddress})
      : threatsDetected = threatsDetected ?? [];

  factory UserLoginSuspiciousEvent.fromJson(Map<String, Object?> json) {
    return UserLoginSuspiciousEvent(
      threatsDetected: (json[r'threatsDetected'] as List<Object?>?)
              ?.map((i) => i)
              .toList() ??
          [],
      applicationId: json[r'applicationId'] as String?,
      authenticationType: json[r'authenticationType'] as String?,
      connectorId: json[r'connectorId'] as String?,
      identityProviderId: json[r'identityProviderId'] as String?,
      identityProviderName: json[r'identityProviderName'] as String?,
      ipAddress: json[r'ipAddress'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var threatsDetected = this.threatsDetected;
    var applicationId = this.applicationId;
    var authenticationType = this.authenticationType;
    var connectorId = this.connectorId;
    var identityProviderId = this.identityProviderId;
    var identityProviderName = this.identityProviderName;
    var ipAddress = this.ipAddress;

    final json = <String, Object?>{};
    json[r'threatsDetected'] = threatsDetected;
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (authenticationType != null) {
      json[r'authenticationType'] = authenticationType;
    }
    if (connectorId != null) {
      json[r'connectorId'] = connectorId;
    }
    if (identityProviderId != null) {
      json[r'identityProviderId'] = identityProviderId;
    }
    if (identityProviderName != null) {
      json[r'identityProviderName'] = identityProviderName;
    }
    if (ipAddress != null) {
      json[r'ipAddress'] = ipAddress;
    }
    return json;
  }

  UserLoginSuspiciousEvent copyWith(
      {List<dynamic>? threatsDetected,
      String? applicationId,
      String? authenticationType,
      String? connectorId,
      String? identityProviderId,
      String? identityProviderName,
      String? ipAddress}) {
    return UserLoginSuspiciousEvent(
      threatsDetected: threatsDetected ?? this.threatsDetected,
      applicationId: applicationId ?? this.applicationId,
      authenticationType: authenticationType ?? this.authenticationType,
      connectorId: connectorId ?? this.connectorId,
      identityProviderId: identityProviderId ?? this.identityProviderId,
      identityProviderName: identityProviderName ?? this.identityProviderName,
      ipAddress: ipAddress ?? this.ipAddress,
    );
  }
}

/// Models the User Password Breach Event.
class UserPasswordBreachEvent {
  final User? user;

  UserPasswordBreachEvent({this.user});

  factory UserPasswordBreachEvent.fromJson(Map<String, Object?> json) {
    return UserPasswordBreachEvent(
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var user = this.user;

    final json = <String, Object?>{};
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserPasswordBreachEvent copyWith({User? user}) {
    return UserPasswordBreachEvent(
      user: user ?? this.user,
    );
  }
}

/// Models the User Password Reset Send Event.
class UserPasswordResetSendEvent {
  final User? user;

  UserPasswordResetSendEvent({this.user});

  factory UserPasswordResetSendEvent.fromJson(Map<String, Object?> json) {
    return UserPasswordResetSendEvent(
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var user = this.user;

    final json = <String, Object?>{};
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserPasswordResetSendEvent copyWith({User? user}) {
    return UserPasswordResetSendEvent(
      user: user ?? this.user,
    );
  }
}

/// Models the User Password Reset Start Event.
class UserPasswordResetStartEvent {
  final User? user;

  UserPasswordResetStartEvent({this.user});

  factory UserPasswordResetStartEvent.fromJson(Map<String, Object?> json) {
    return UserPasswordResetStartEvent(
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var user = this.user;

    final json = <String, Object?>{};
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserPasswordResetStartEvent copyWith({User? user}) {
    return UserPasswordResetStartEvent(
      user: user ?? this.user,
    );
  }
}

/// Models the User Password Reset Success Event.
class UserPasswordResetSuccessEvent {
  final User? user;

  UserPasswordResetSuccessEvent({this.user});

  factory UserPasswordResetSuccessEvent.fromJson(Map<String, Object?> json) {
    return UserPasswordResetSuccessEvent(
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var user = this.user;

    final json = <String, Object?>{};
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserPasswordResetSuccessEvent copyWith({User? user}) {
    return UserPasswordResetSuccessEvent(
      user: user ?? this.user,
    );
  }
}

/// Models the User Password Update Event.
class UserPasswordUpdateEvent {
  final User? user;

  UserPasswordUpdateEvent({this.user});

  factory UserPasswordUpdateEvent.fromJson(Map<String, Object?> json) {
    return UserPasswordUpdateEvent(
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var user = this.user;

    final json = <String, Object?>{};
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserPasswordUpdateEvent copyWith({User? user}) {
    return UserPasswordUpdateEvent(
      user: user ?? this.user,
    );
  }
}

/// Models the User Reactivate Event.
class UserReactivateEvent {
  final User? user;

  UserReactivateEvent({this.user});

  factory UserReactivateEvent.fromJson(Map<String, Object?> json) {
    return UserReactivateEvent(
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var user = this.user;

    final json = <String, Object?>{};
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserReactivateEvent copyWith({User? user}) {
    return UserReactivateEvent(
      user: user ?? this.user,
    );
  }
}

/// User registration information for a single application.
class UserRegistration {
  final Map<String, dynamic>? data;
  final List<Locale> preferredLanguages;
  final Map<String, dynamic>? tokens;
  final String? applicationId;
  final String? authenticationToken;
  final String? cleanSpeakId;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastLoginInstant;
  final ZonedDateTime? lastUpdateInstant;
  final List<dynamic> roles;
  final ZoneId? timezone;
  final String? username;
  final ContentStatus? usernameStatus;
  final bool verified;
  final ZonedDateTime? verifiedInstant;

  UserRegistration(
      {this.data,
      List<Locale>? preferredLanguages,
      this.tokens,
      this.applicationId,
      this.authenticationToken,
      this.cleanSpeakId,
      this.id,
      this.insertInstant,
      this.lastLoginInstant,
      this.lastUpdateInstant,
      List<dynamic>? roles,
      this.timezone,
      this.username,
      this.usernameStatus,
      bool? verified,
      this.verifiedInstant})
      : preferredLanguages = preferredLanguages ?? [],
        roles = roles ?? [],
        verified = verified ?? false;

  factory UserRegistration.fromJson(Map<String, Object?> json) {
    return UserRegistration(
      data: json[r'data'] as Map<String, Object?>?,
      preferredLanguages: (json[r'preferredLanguages'] as List<Object?>?)
              ?.map((i) => (i as Locale? ?? '') as Locale)
              .toList() ??
          [],
      tokens: json[r'tokens'] as Map<String, Object?>?,
      applicationId: json[r'applicationId'] as String?,
      authenticationToken: json[r'authenticationToken'] as String?,
      cleanSpeakId: json[r'cleanSpeakId'] as String?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastLoginInstant:
          (json[r'lastLoginInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      roles: (json[r'roles'] as List<Object?>?)?.map((i) => i).toList() ?? [],
      timezone: json[r'timezone'] as ZoneId?,
      username: json[r'username'] as String?,
      usernameStatus: json[r'usernameStatus'] != null
          ? ContentStatus.fromValue(json[r'usernameStatus']! as String)
          : null,
      verified: json[r'verified'] as bool? ?? false,
      verifiedInstant:
          (json[r'verifiedInstant'] as num?)?.toInt() as ZonedDateTime?,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var preferredLanguages = this.preferredLanguages;
    var tokens = this.tokens;
    var applicationId = this.applicationId;
    var authenticationToken = this.authenticationToken;
    var cleanSpeakId = this.cleanSpeakId;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastLoginInstant = this.lastLoginInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var roles = this.roles;
    var timezone = this.timezone;
    var username = this.username;
    var usernameStatus = this.usernameStatus;
    var verified = this.verified;
    var verifiedInstant = this.verifiedInstant;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'preferredLanguages'] =
        preferredLanguages.map((i) => i.toJson()).toList();
    if (tokens != null) {
      json[r'tokens'] = tokens;
    }
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (authenticationToken != null) {
      json[r'authenticationToken'] = authenticationToken;
    }
    if (cleanSpeakId != null) {
      json[r'cleanSpeakId'] = cleanSpeakId;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastLoginInstant != null) {
      json[r'lastLoginInstant'] = lastLoginInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    json[r'roles'] = roles;
    if (timezone != null) {
      json[r'timezone'] = timezone.toJson();
    }
    if (username != null) {
      json[r'username'] = username;
    }
    if (usernameStatus != null) {
      json[r'usernameStatus'] = usernameStatus.value;
    }
    json[r'verified'] = verified;
    if (verifiedInstant != null) {
      json[r'verifiedInstant'] = verifiedInstant.toJson();
    }
    return json;
  }

  UserRegistration copyWith(
      {Map<String, dynamic>? data,
      List<Locale>? preferredLanguages,
      Map<String, dynamic>? tokens,
      String? applicationId,
      String? authenticationToken,
      String? cleanSpeakId,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastLoginInstant,
      ZonedDateTime? lastUpdateInstant,
      List<dynamic>? roles,
      ZoneId? timezone,
      String? username,
      ContentStatus? usernameStatus,
      bool? verified,
      ZonedDateTime? verifiedInstant}) {
    return UserRegistration(
      data: data ?? this.data,
      preferredLanguages: preferredLanguages ?? this.preferredLanguages,
      tokens: tokens ?? this.tokens,
      applicationId: applicationId ?? this.applicationId,
      authenticationToken: authenticationToken ?? this.authenticationToken,
      cleanSpeakId: cleanSpeakId ?? this.cleanSpeakId,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastLoginInstant: lastLoginInstant ?? this.lastLoginInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      roles: roles ?? this.roles,
      timezone: timezone ?? this.timezone,
      username: username ?? this.username,
      usernameStatus: usernameStatus ?? this.usernameStatus,
      verified: verified ?? this.verified,
      verifiedInstant: verifiedInstant ?? this.verifiedInstant,
    );
  }
}

/// Models the User Created Registration Event.  <p>  This is different than the
/// user.registration.create event in that it will be sent after the user has
/// been created. This event cannot be made  transactional.
class UserRegistrationCreateCompleteEvent {
  final String? applicationId;
  final UserRegistration? registration;
  final User? user;

  UserRegistrationCreateCompleteEvent(
      {this.applicationId, this.registration, this.user});

  factory UserRegistrationCreateCompleteEvent.fromJson(
      Map<String, Object?> json) {
    return UserRegistrationCreateCompleteEvent(
      applicationId: json[r'applicationId'] as String?,
      registration: json[r'registration'] != null
          ? UserRegistration.fromJson(
              json[r'registration']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var registration = this.registration;
    var user = this.user;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (registration != null) {
      json[r'registration'] = registration.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserRegistrationCreateCompleteEvent copyWith(
      {String? applicationId, UserRegistration? registration, User? user}) {
    return UserRegistrationCreateCompleteEvent(
      applicationId: applicationId ?? this.applicationId,
      registration: registration ?? this.registration,
      user: user ?? this.user,
    );
  }
}

/// Models the User Create Registration Event.
class UserRegistrationCreateEvent {
  final String? applicationId;
  final UserRegistration? registration;
  final User? user;

  UserRegistrationCreateEvent(
      {this.applicationId, this.registration, this.user});

  factory UserRegistrationCreateEvent.fromJson(Map<String, Object?> json) {
    return UserRegistrationCreateEvent(
      applicationId: json[r'applicationId'] as String?,
      registration: json[r'registration'] != null
          ? UserRegistration.fromJson(
              json[r'registration']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var registration = this.registration;
    var user = this.user;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (registration != null) {
      json[r'registration'] = registration.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserRegistrationCreateEvent copyWith(
      {String? applicationId, UserRegistration? registration, User? user}) {
    return UserRegistrationCreateEvent(
      applicationId: applicationId ?? this.applicationId,
      registration: registration ?? this.registration,
      user: user ?? this.user,
    );
  }
}

/// Models the User Deleted Registration Event.  <p>  This is different than
/// user.registration.delete in that it is sent after the TX has been committed.
/// This event cannot be transactional.
class UserRegistrationDeleteCompleteEvent {
  final String? applicationId;
  final UserRegistration? registration;
  final User? user;

  UserRegistrationDeleteCompleteEvent(
      {this.applicationId, this.registration, this.user});

  factory UserRegistrationDeleteCompleteEvent.fromJson(
      Map<String, Object?> json) {
    return UserRegistrationDeleteCompleteEvent(
      applicationId: json[r'applicationId'] as String?,
      registration: json[r'registration'] != null
          ? UserRegistration.fromJson(
              json[r'registration']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var registration = this.registration;
    var user = this.user;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (registration != null) {
      json[r'registration'] = registration.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserRegistrationDeleteCompleteEvent copyWith(
      {String? applicationId, UserRegistration? registration, User? user}) {
    return UserRegistrationDeleteCompleteEvent(
      applicationId: applicationId ?? this.applicationId,
      registration: registration ?? this.registration,
      user: user ?? this.user,
    );
  }
}

/// Models the User Delete Registration Event.
class UserRegistrationDeleteEvent {
  final String? applicationId;
  final UserRegistration? registration;
  final User? user;

  UserRegistrationDeleteEvent(
      {this.applicationId, this.registration, this.user});

  factory UserRegistrationDeleteEvent.fromJson(Map<String, Object?> json) {
    return UserRegistrationDeleteEvent(
      applicationId: json[r'applicationId'] as String?,
      registration: json[r'registration'] != null
          ? UserRegistration.fromJson(
              json[r'registration']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var registration = this.registration;
    var user = this.user;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (registration != null) {
      json[r'registration'] = registration.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserRegistrationDeleteEvent copyWith(
      {String? applicationId, UserRegistration? registration, User? user}) {
    return UserRegistrationDeleteEvent(
      applicationId: applicationId ?? this.applicationId,
      registration: registration ?? this.registration,
      user: user ?? this.user,
    );
  }
}

/// Models the User Update Registration Event.  <p>  This is different than
/// user.registration.update in that it is sent after this event completes, this
/// cannot be transactional.
class UserRegistrationUpdateCompleteEvent {
  final String? applicationId;
  final UserRegistration? original;
  final UserRegistration? registration;
  final User? user;

  UserRegistrationUpdateCompleteEvent(
      {this.applicationId, this.original, this.registration, this.user});

  factory UserRegistrationUpdateCompleteEvent.fromJson(
      Map<String, Object?> json) {
    return UserRegistrationUpdateCompleteEvent(
      applicationId: json[r'applicationId'] as String?,
      original: json[r'original'] != null
          ? UserRegistration.fromJson(
              json[r'original']! as Map<String, Object?>)
          : null,
      registration: json[r'registration'] != null
          ? UserRegistration.fromJson(
              json[r'registration']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var original = this.original;
    var registration = this.registration;
    var user = this.user;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (original != null) {
      json[r'original'] = original.toJson();
    }
    if (registration != null) {
      json[r'registration'] = registration.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserRegistrationUpdateCompleteEvent copyWith(
      {String? applicationId,
      UserRegistration? original,
      UserRegistration? registration,
      User? user}) {
    return UserRegistrationUpdateCompleteEvent(
      applicationId: applicationId ?? this.applicationId,
      original: original ?? this.original,
      registration: registration ?? this.registration,
      user: user ?? this.user,
    );
  }
}

/// Models the User Update Registration Event.
class UserRegistrationUpdateEvent {
  final String? applicationId;
  final UserRegistration? original;
  final UserRegistration? registration;
  final User? user;

  UserRegistrationUpdateEvent(
      {this.applicationId, this.original, this.registration, this.user});

  factory UserRegistrationUpdateEvent.fromJson(Map<String, Object?> json) {
    return UserRegistrationUpdateEvent(
      applicationId: json[r'applicationId'] as String?,
      original: json[r'original'] != null
          ? UserRegistration.fromJson(
              json[r'original']! as Map<String, Object?>)
          : null,
      registration: json[r'registration'] != null
          ? UserRegistration.fromJson(
              json[r'registration']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var original = this.original;
    var registration = this.registration;
    var user = this.user;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (original != null) {
      json[r'original'] = original.toJson();
    }
    if (registration != null) {
      json[r'registration'] = registration.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserRegistrationUpdateEvent copyWith(
      {String? applicationId,
      UserRegistration? original,
      UserRegistration? registration,
      User? user}) {
    return UserRegistrationUpdateEvent(
      applicationId: applicationId ?? this.applicationId,
      original: original ?? this.original,
      registration: registration ?? this.registration,
      user: user ?? this.user,
    );
  }
}

/// Models the User Registration Verified Event.
class UserRegistrationVerifiedEvent {
  final String? applicationId;
  final UserRegistration? registration;
  final User? user;

  UserRegistrationVerifiedEvent(
      {this.applicationId, this.registration, this.user});

  factory UserRegistrationVerifiedEvent.fromJson(Map<String, Object?> json) {
    return UserRegistrationVerifiedEvent(
      applicationId: json[r'applicationId'] as String?,
      registration: json[r'registration'] != null
          ? UserRegistration.fromJson(
              json[r'registration']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var registration = this.registration;
    var user = this.user;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (registration != null) {
      json[r'registration'] = registration.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserRegistrationVerifiedEvent copyWith(
      {String? applicationId, UserRegistration? registration, User? user}) {
    return UserRegistrationVerifiedEvent(
      applicationId: applicationId ?? this.applicationId,
      registration: registration ?? this.registration,
      user: user ?? this.user,
    );
  }
}

/// User API request object.
class UserRequest {
  final String? applicationId;
  final String? currentPassword;
  final bool disableDomainBlock;
  final bool sendSetPasswordEmail;
  final bool skipVerification;
  final User? user;
  final EventInfo? eventInfo;

  UserRequest(
      {this.applicationId,
      this.currentPassword,
      bool? disableDomainBlock,
      bool? sendSetPasswordEmail,
      bool? skipVerification,
      this.user,
      this.eventInfo})
      : disableDomainBlock = disableDomainBlock ?? false,
        sendSetPasswordEmail = sendSetPasswordEmail ?? false,
        skipVerification = skipVerification ?? false;

  factory UserRequest.fromJson(Map<String, Object?> json) {
    return UserRequest(
      applicationId: json[r'applicationId'] as String?,
      currentPassword: json[r'currentPassword'] as String?,
      disableDomainBlock: json[r'disableDomainBlock'] as bool? ?? false,
      sendSetPasswordEmail: json[r'sendSetPasswordEmail'] as bool? ?? false,
      skipVerification: json[r'skipVerification'] as bool? ?? false,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var currentPassword = this.currentPassword;
    var disableDomainBlock = this.disableDomainBlock;
    var sendSetPasswordEmail = this.sendSetPasswordEmail;
    var skipVerification = this.skipVerification;
    var user = this.user;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (currentPassword != null) {
      json[r'currentPassword'] = currentPassword;
    }
    json[r'disableDomainBlock'] = disableDomainBlock;
    json[r'sendSetPasswordEmail'] = sendSetPasswordEmail;
    json[r'skipVerification'] = skipVerification;
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  UserRequest copyWith(
      {String? applicationId,
      String? currentPassword,
      bool? disableDomainBlock,
      bool? sendSetPasswordEmail,
      bool? skipVerification,
      User? user,
      EventInfo? eventInfo}) {
    return UserRequest(
      applicationId: applicationId ?? this.applicationId,
      currentPassword: currentPassword ?? this.currentPassword,
      disableDomainBlock: disableDomainBlock ?? this.disableDomainBlock,
      sendSetPasswordEmail: sendSetPasswordEmail ?? this.sendSetPasswordEmail,
      skipVerification: skipVerification ?? this.skipVerification,
      user: user ?? this.user,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

/// User API response object.
class UserResponse {
  final String? emailVerificationId;
  final String? emailVerificationOneTimeCode;
  final Map<String, dynamic>? registrationVerificationIds;
  final Map<String, dynamic>? registrationVerificationOneTimeCodes;
  final String? token;
  final ZonedDateTime? tokenExpirationInstant;
  final User? user;

  UserResponse(
      {this.emailVerificationId,
      this.emailVerificationOneTimeCode,
      this.registrationVerificationIds,
      this.registrationVerificationOneTimeCodes,
      this.token,
      this.tokenExpirationInstant,
      this.user});

  factory UserResponse.fromJson(Map<String, Object?> json) {
    return UserResponse(
      emailVerificationId: json[r'emailVerificationId'] as String?,
      emailVerificationOneTimeCode:
          json[r'emailVerificationOneTimeCode'] as String?,
      registrationVerificationIds:
          json[r'registrationVerificationIds'] as Map<String, Object?>?,
      registrationVerificationOneTimeCodes:
          json[r'registrationVerificationOneTimeCodes']
              as Map<String, Object?>?,
      token: json[r'token'] as String?,
      tokenExpirationInstant:
          (json[r'tokenExpirationInstant'] as num?)?.toInt() as ZonedDateTime?,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var emailVerificationId = this.emailVerificationId;
    var emailVerificationOneTimeCode = this.emailVerificationOneTimeCode;
    var registrationVerificationIds = this.registrationVerificationIds;
    var registrationVerificationOneTimeCodes =
        this.registrationVerificationOneTimeCodes;
    var token = this.token;
    var tokenExpirationInstant = this.tokenExpirationInstant;
    var user = this.user;

    final json = <String, Object?>{};
    if (emailVerificationId != null) {
      json[r'emailVerificationId'] = emailVerificationId;
    }
    if (emailVerificationOneTimeCode != null) {
      json[r'emailVerificationOneTimeCode'] = emailVerificationOneTimeCode;
    }
    if (registrationVerificationIds != null) {
      json[r'registrationVerificationIds'] = registrationVerificationIds;
    }
    if (registrationVerificationOneTimeCodes != null) {
      json[r'registrationVerificationOneTimeCodes'] =
          registrationVerificationOneTimeCodes;
    }
    if (token != null) {
      json[r'token'] = token;
    }
    if (tokenExpirationInstant != null) {
      json[r'tokenExpirationInstant'] = tokenExpirationInstant.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserResponse copyWith(
      {String? emailVerificationId,
      String? emailVerificationOneTimeCode,
      Map<String, dynamic>? registrationVerificationIds,
      Map<String, dynamic>? registrationVerificationOneTimeCodes,
      String? token,
      ZonedDateTime? tokenExpirationInstant,
      User? user}) {
    return UserResponse(
      emailVerificationId: emailVerificationId ?? this.emailVerificationId,
      emailVerificationOneTimeCode:
          emailVerificationOneTimeCode ?? this.emailVerificationOneTimeCode,
      registrationVerificationIds:
          registrationVerificationIds ?? this.registrationVerificationIds,
      registrationVerificationOneTimeCodes:
          registrationVerificationOneTimeCodes ??
              this.registrationVerificationOneTimeCodes,
      token: token ?? this.token,
      tokenExpirationInstant:
          tokenExpirationInstant ?? this.tokenExpirationInstant,
      user: user ?? this.user,
    );
  }
}

/// This class is the user query. It provides a build pattern as well as public
/// fields for use on forms and in actions.
class UserSearchCriteria {
  final bool accurateTotal;
  final List<String> ids;
  final String? nextResults;
  final String? query;
  final String? queryString;
  final List<SortField> sortFields;

  UserSearchCriteria(
      {bool? accurateTotal,
      List<String>? ids,
      this.nextResults,
      this.query,
      this.queryString,
      List<SortField>? sortFields})
      : accurateTotal = accurateTotal ?? false,
        ids = ids ?? [],
        sortFields = sortFields ?? [];

  factory UserSearchCriteria.fromJson(Map<String, Object?> json) {
    return UserSearchCriteria(
      accurateTotal: json[r'accurateTotal'] as bool? ?? false,
      ids: (json[r'ids'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      nextResults: json[r'nextResults'] as String?,
      query: json[r'query'] as String?,
      queryString: json[r'queryString'] as String?,
      sortFields: (json[r'sortFields'] as List<Object?>?)
              ?.map((i) =>
                  SortField.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var accurateTotal = this.accurateTotal;
    var ids = this.ids;
    var nextResults = this.nextResults;
    var query = this.query;
    var queryString = this.queryString;
    var sortFields = this.sortFields;

    final json = <String, Object?>{};
    json[r'accurateTotal'] = accurateTotal;
    json[r'ids'] = ids;
    if (nextResults != null) {
      json[r'nextResults'] = nextResults;
    }
    if (query != null) {
      json[r'query'] = query;
    }
    if (queryString != null) {
      json[r'queryString'] = queryString;
    }
    json[r'sortFields'] = sortFields.map((i) => i.toJson()).toList();
    return json;
  }

  UserSearchCriteria copyWith(
      {bool? accurateTotal,
      List<String>? ids,
      String? nextResults,
      String? query,
      String? queryString,
      List<SortField>? sortFields}) {
    return UserSearchCriteria(
      accurateTotal: accurateTotal ?? this.accurateTotal,
      ids: ids ?? this.ids,
      nextResults: nextResults ?? this.nextResults,
      query: query ?? this.query,
      queryString: queryString ?? this.queryString,
      sortFields: sortFields ?? this.sortFields,
    );
  }
}

class UserTwoFactorConfiguration {
  final List<TwoFactorMethod> methods;
  final List<String> recoveryCodes;

  UserTwoFactorConfiguration(
      {List<TwoFactorMethod>? methods, List<String>? recoveryCodes})
      : methods = methods ?? [],
        recoveryCodes = recoveryCodes ?? [];

  factory UserTwoFactorConfiguration.fromJson(Map<String, Object?> json) {
    return UserTwoFactorConfiguration(
      methods: (json[r'methods'] as List<Object?>?)
              ?.map((i) => TwoFactorMethod.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      recoveryCodes: (json[r'recoveryCodes'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var methods = this.methods;
    var recoveryCodes = this.recoveryCodes;

    final json = <String, Object?>{};
    json[r'methods'] = methods.map((i) => i.toJson()).toList();
    json[r'recoveryCodes'] = recoveryCodes;
    return json;
  }

  UserTwoFactorConfiguration copyWith(
      {List<TwoFactorMethod>? methods, List<String>? recoveryCodes}) {
    return UserTwoFactorConfiguration(
      methods: methods ?? this.methods,
      recoveryCodes: recoveryCodes ?? this.recoveryCodes,
    );
  }
}

/// Model a user event when a two-factor method has been removed.
class UserTwoFactorMethodAddEvent {
  final TwoFactorMethod? method;
  final User? user;

  UserTwoFactorMethodAddEvent({this.method, this.user});

  factory UserTwoFactorMethodAddEvent.fromJson(Map<String, Object?> json) {
    return UserTwoFactorMethodAddEvent(
      method: json[r'method'] != null
          ? TwoFactorMethod.fromJson(json[r'method']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var method = this.method;
    var user = this.user;

    final json = <String, Object?>{};
    if (method != null) {
      json[r'method'] = method.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserTwoFactorMethodAddEvent copyWith({TwoFactorMethod? method, User? user}) {
    return UserTwoFactorMethodAddEvent(
      method: method ?? this.method,
      user: user ?? this.user,
    );
  }
}

/// Model a user event when a two-factor method has been added.
class UserTwoFactorMethodRemoveEvent {
  final TwoFactorMethod? method;
  final User? user;

  UserTwoFactorMethodRemoveEvent({this.method, this.user});

  factory UserTwoFactorMethodRemoveEvent.fromJson(Map<String, Object?> json) {
    return UserTwoFactorMethodRemoveEvent(
      method: json[r'method'] != null
          ? TwoFactorMethod.fromJson(json[r'method']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var method = this.method;
    var user = this.user;

    final json = <String, Object?>{};
    if (method != null) {
      json[r'method'] = method.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserTwoFactorMethodRemoveEvent copyWith(
      {TwoFactorMethod? method, User? user}) {
    return UserTwoFactorMethodRemoveEvent(
      method: method ?? this.method,
      user: user ?? this.user,
    );
  }
}

/// Models the User Update Event once it is completed. This cannot be
/// transactional.
class UserUpdateCompleteEvent {
  final User? original;
  final User? user;

  UserUpdateCompleteEvent({this.original, this.user});

  factory UserUpdateCompleteEvent.fromJson(Map<String, Object?> json) {
    return UserUpdateCompleteEvent(
      original: json[r'original'] != null
          ? User.fromJson(json[r'original']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var original = this.original;
    var user = this.user;

    final json = <String, Object?>{};
    if (original != null) {
      json[r'original'] = original.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserUpdateCompleteEvent copyWith({User? original, User? user}) {
    return UserUpdateCompleteEvent(
      original: original ?? this.original,
      user: user ?? this.user,
    );
  }
}

/// Models the User Update Event.
class UserUpdateEvent {
  final User? original;
  final User? user;

  UserUpdateEvent({this.original, this.user});

  factory UserUpdateEvent.fromJson(Map<String, Object?> json) {
    return UserUpdateEvent(
      original: json[r'original'] != null
          ? User.fromJson(json[r'original']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var original = this.original;
    var user = this.user;

    final json = <String, Object?>{};
    if (original != null) {
      json[r'original'] = original.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  UserUpdateEvent copyWith({User? original, User? user}) {
    return UserUpdateEvent(
      original: original ?? this.original,
      user: user ?? this.user,
    );
  }
}

class UserinfoResponse {
  UserinfoResponse();

  factory UserinfoResponse.fromJson(Map<String, Object?> json) {
    return UserinfoResponse();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class UsernameModeration {
  final String? applicationId;
  final bool enabled;

  UsernameModeration({this.applicationId, bool? enabled})
      : enabled = enabled ?? false;

  factory UsernameModeration.fromJson(Map<String, Object?> json) {
    return UsernameModeration(
      applicationId: json[r'applicationId'] as String?,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  UsernameModeration copyWith({String? applicationId, bool? enabled}) {
    return UsernameModeration(
      applicationId: applicationId ?? this.applicationId,
      enabled: enabled ?? this.enabled,
    );
  }
}

class ValidateResponse {
  final JWT? jwt;

  ValidateResponse({this.jwt});

  factory ValidateResponse.fromJson(Map<String, Object?> json) {
    return ValidateResponse(
      jwt: json[r'jwt'] != null
          ? JWT.fromJson(json[r'jwt']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var jwt = this.jwt;

    final json = <String, Object?>{};
    if (jwt != null) {
      json[r'jwt'] = jwt.toJson();
    }
    return json;
  }

  ValidateResponse copyWith({JWT? jwt}) {
    return ValidateResponse(
      jwt: jwt ?? this.jwt,
    );
  }
}

class VerifyEmailRequest {
  final String? oneTimeCode;
  final String? userId;
  final String? verificationId;
  final EventInfo? eventInfo;

  VerifyEmailRequest(
      {this.oneTimeCode, this.userId, this.verificationId, this.eventInfo});

  factory VerifyEmailRequest.fromJson(Map<String, Object?> json) {
    return VerifyEmailRequest(
      oneTimeCode: json[r'oneTimeCode'] as String?,
      userId: json[r'userId'] as String?,
      verificationId: json[r'verificationId'] as String?,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var oneTimeCode = this.oneTimeCode;
    var userId = this.userId;
    var verificationId = this.verificationId;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (oneTimeCode != null) {
      json[r'oneTimeCode'] = oneTimeCode;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    if (verificationId != null) {
      json[r'verificationId'] = verificationId;
    }
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  VerifyEmailRequest copyWith(
      {String? oneTimeCode,
      String? userId,
      String? verificationId,
      EventInfo? eventInfo}) {
    return VerifyEmailRequest(
      oneTimeCode: oneTimeCode ?? this.oneTimeCode,
      userId: userId ?? this.userId,
      verificationId: verificationId ?? this.verificationId,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

class VerifyEmailResponse {
  final String? oneTimeCode;
  final String? verificationId;

  VerifyEmailResponse({this.oneTimeCode, this.verificationId});

  factory VerifyEmailResponse.fromJson(Map<String, Object?> json) {
    return VerifyEmailResponse(
      oneTimeCode: json[r'oneTimeCode'] as String?,
      verificationId: json[r'verificationId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var oneTimeCode = this.oneTimeCode;
    var verificationId = this.verificationId;

    final json = <String, Object?>{};
    if (oneTimeCode != null) {
      json[r'oneTimeCode'] = oneTimeCode;
    }
    if (verificationId != null) {
      json[r'verificationId'] = verificationId;
    }
    return json;
  }

  VerifyEmailResponse copyWith({String? oneTimeCode, String? verificationId}) {
    return VerifyEmailResponse(
      oneTimeCode: oneTimeCode ?? this.oneTimeCode,
      verificationId: verificationId ?? this.verificationId,
    );
  }
}

class VerifyRegistrationRequest {
  final String? oneTimeCode;
  final String? verificationId;
  final EventInfo? eventInfo;

  VerifyRegistrationRequest(
      {this.oneTimeCode, this.verificationId, this.eventInfo});

  factory VerifyRegistrationRequest.fromJson(Map<String, Object?> json) {
    return VerifyRegistrationRequest(
      oneTimeCode: json[r'oneTimeCode'] as String?,
      verificationId: json[r'verificationId'] as String?,
      eventInfo: json[r'eventInfo'] != null
          ? EventInfo.fromJson(json[r'eventInfo']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var oneTimeCode = this.oneTimeCode;
    var verificationId = this.verificationId;
    var eventInfo = this.eventInfo;

    final json = <String, Object?>{};
    if (oneTimeCode != null) {
      json[r'oneTimeCode'] = oneTimeCode;
    }
    if (verificationId != null) {
      json[r'verificationId'] = verificationId;
    }
    if (eventInfo != null) {
      json[r'eventInfo'] = eventInfo.toJson();
    }
    return json;
  }

  VerifyRegistrationRequest copyWith(
      {String? oneTimeCode, String? verificationId, EventInfo? eventInfo}) {
    return VerifyRegistrationRequest(
      oneTimeCode: oneTimeCode ?? this.oneTimeCode,
      verificationId: verificationId ?? this.verificationId,
      eventInfo: eventInfo ?? this.eventInfo,
    );
  }
}

class VerifyRegistrationResponse {
  final String? oneTimeCode;
  final String? verificationId;

  VerifyRegistrationResponse({this.oneTimeCode, this.verificationId});

  factory VerifyRegistrationResponse.fromJson(Map<String, Object?> json) {
    return VerifyRegistrationResponse(
      oneTimeCode: json[r'oneTimeCode'] as String?,
      verificationId: json[r'verificationId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var oneTimeCode = this.oneTimeCode;
    var verificationId = this.verificationId;

    final json = <String, Object?>{};
    if (oneTimeCode != null) {
      json[r'oneTimeCode'] = oneTimeCode;
    }
    if (verificationId != null) {
      json[r'verificationId'] = verificationId;
    }
    return json;
  }

  VerifyRegistrationResponse copyWith(
      {String? oneTimeCode, String? verificationId}) {
    return VerifyRegistrationResponse(
      oneTimeCode: oneTimeCode ?? this.oneTimeCode,
      verificationId: verificationId ?? this.verificationId,
    );
  }
}

class VersionResponse {
  final String? version;

  VersionResponse({this.version});

  factory VersionResponse.fromJson(Map<String, Object?> json) {
    return VersionResponse(
      version: json[r'version'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var version = this.version;

    final json = <String, Object?>{};
    if (version != null) {
      json[r'version'] = version;
    }
    return json;
  }

  VersionResponse copyWith({String? version}) {
    return VersionResponse(
      version: version ?? this.version,
    );
  }
}

/// API response for completing WebAuthn assertion
class WebAuthnAssertResponse {
  final WebAuthnCredential? credential;

  WebAuthnAssertResponse({this.credential});

  factory WebAuthnAssertResponse.fromJson(Map<String, Object?> json) {
    return WebAuthnAssertResponse(
      credential: json[r'credential'] != null
          ? WebAuthnCredential.fromJson(
              json[r'credential']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var credential = this.credential;

    final json = <String, Object?>{};
    if (credential != null) {
      json[r'credential'] = credential.toJson();
    }
    return json;
  }

  WebAuthnAssertResponse copyWith({WebAuthnCredential? credential}) {
    return WebAuthnAssertResponse(
      credential: credential ?? this.credential,
    );
  }
}

/// The <i>authenticator's<i> response for the authentication ceremony in its
/// encoded format
class WebAuthnAuthenticatorAuthenticationResponse {
  final String? authenticatorData;
  final String? clientDataJson;
  final String? signature;
  final String? userHandle;

  WebAuthnAuthenticatorAuthenticationResponse(
      {this.authenticatorData,
      this.clientDataJson,
      this.signature,
      this.userHandle});

  factory WebAuthnAuthenticatorAuthenticationResponse.fromJson(
      Map<String, Object?> json) {
    return WebAuthnAuthenticatorAuthenticationResponse(
      authenticatorData: json[r'authenticatorData'] as String?,
      clientDataJson: json[r'clientDataJSON'] as String?,
      signature: json[r'signature'] as String?,
      userHandle: json[r'userHandle'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var authenticatorData = this.authenticatorData;
    var clientDataJson = this.clientDataJson;
    var signature = this.signature;
    var userHandle = this.userHandle;

    final json = <String, Object?>{};
    if (authenticatorData != null) {
      json[r'authenticatorData'] = authenticatorData;
    }
    if (clientDataJson != null) {
      json[r'clientDataJSON'] = clientDataJson;
    }
    if (signature != null) {
      json[r'signature'] = signature;
    }
    if (userHandle != null) {
      json[r'userHandle'] = userHandle;
    }
    return json;
  }

  WebAuthnAuthenticatorAuthenticationResponse copyWith(
      {String? authenticatorData,
      String? clientDataJson,
      String? signature,
      String? userHandle}) {
    return WebAuthnAuthenticatorAuthenticationResponse(
      authenticatorData: authenticatorData ?? this.authenticatorData,
      clientDataJson: clientDataJson ?? this.clientDataJson,
      signature: signature ?? this.signature,
      userHandle: userHandle ?? this.userHandle,
    );
  }
}

/// The <i>authenticator's<i> response for the registration ceremony in its
/// encoded format
class WebAuthnAuthenticatorRegistrationResponse {
  final String? attestationObject;
  final String? clientDataJson;

  WebAuthnAuthenticatorRegistrationResponse(
      {this.attestationObject, this.clientDataJson});

  factory WebAuthnAuthenticatorRegistrationResponse.fromJson(
      Map<String, Object?> json) {
    return WebAuthnAuthenticatorRegistrationResponse(
      attestationObject: json[r'attestationObject'] as String?,
      clientDataJson: json[r'clientDataJSON'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var attestationObject = this.attestationObject;
    var clientDataJson = this.clientDataJson;

    final json = <String, Object?>{};
    if (attestationObject != null) {
      json[r'attestationObject'] = attestationObject;
    }
    if (clientDataJson != null) {
      json[r'clientDataJSON'] = clientDataJson;
    }
    return json;
  }

  WebAuthnAuthenticatorRegistrationResponse copyWith(
      {String? attestationObject, String? clientDataJson}) {
    return WebAuthnAuthenticatorRegistrationResponse(
      attestationObject: attestationObject ?? this.attestationObject,
      clientDataJson: clientDataJson ?? this.clientDataJson,
    );
  }
}

/// A User's WebAuthnCredential. Contains all data required to complete WebAuthn
/// authentication ceremonies.
class WebAuthnCredential {
  final CoseAlgorithmIdentifier? algorithm;
  final AttestationType? attestationType;
  final bool authenticatorSupportsUserVerification;
  final String? credentialId;
  final Map<String, dynamic>? data;
  final bool discoverable;
  final String? displayName;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUseInstant;
  final String? name;
  final String? publicKey;
  final String? relyingPartyId;
  final int? signCount;
  final String? tenantId;
  final List<String> transports;
  final String? userAgent;
  final String? userId;

  WebAuthnCredential(
      {this.algorithm,
      this.attestationType,
      bool? authenticatorSupportsUserVerification,
      this.credentialId,
      this.data,
      bool? discoverable,
      this.displayName,
      this.id,
      this.insertInstant,
      this.lastUseInstant,
      this.name,
      this.publicKey,
      this.relyingPartyId,
      this.signCount,
      this.tenantId,
      List<String>? transports,
      this.userAgent,
      this.userId})
      : authenticatorSupportsUserVerification =
            authenticatorSupportsUserVerification ?? false,
        discoverable = discoverable ?? false,
        transports = transports ?? [];

  factory WebAuthnCredential.fromJson(Map<String, Object?> json) {
    return WebAuthnCredential(
      algorithm: json[r'algorithm'] != null
          ? CoseAlgorithmIdentifier.fromValue(json[r'algorithm']! as String)
          : null,
      attestationType: json[r'attestationType'] != null
          ? AttestationType.fromValue(json[r'attestationType']! as String)
          : null,
      authenticatorSupportsUserVerification:
          json[r'authenticatorSupportsUserVerification'] as bool? ?? false,
      credentialId: json[r'credentialId'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      discoverable: json[r'discoverable'] as bool? ?? false,
      displayName: json[r'displayName'] as String?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUseInstant:
          (json[r'lastUseInstant'] as num?)?.toInt() as ZonedDateTime?,
      name: json[r'name'] as String?,
      publicKey: json[r'publicKey'] as String?,
      relyingPartyId: json[r'relyingPartyId'] as String?,
      signCount: (json[r'signCount'] as num?)?.toInt(),
      tenantId: json[r'tenantId'] as String?,
      transports: (json[r'transports'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      userAgent: json[r'userAgent'] as String?,
      userId: json[r'userId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var algorithm = this.algorithm;
    var attestationType = this.attestationType;
    var authenticatorSupportsUserVerification =
        this.authenticatorSupportsUserVerification;
    var credentialId = this.credentialId;
    var data = this.data;
    var discoverable = this.discoverable;
    var displayName = this.displayName;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUseInstant = this.lastUseInstant;
    var name = this.name;
    var publicKey = this.publicKey;
    var relyingPartyId = this.relyingPartyId;
    var signCount = this.signCount;
    var tenantId = this.tenantId;
    var transports = this.transports;
    var userAgent = this.userAgent;
    var userId = this.userId;

    final json = <String, Object?>{};
    if (algorithm != null) {
      json[r'algorithm'] = algorithm.value;
    }
    if (attestationType != null) {
      json[r'attestationType'] = attestationType.value;
    }
    json[r'authenticatorSupportsUserVerification'] =
        authenticatorSupportsUserVerification;
    if (credentialId != null) {
      json[r'credentialId'] = credentialId;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'discoverable'] = discoverable;
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUseInstant != null) {
      json[r'lastUseInstant'] = lastUseInstant.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (publicKey != null) {
      json[r'publicKey'] = publicKey;
    }
    if (relyingPartyId != null) {
      json[r'relyingPartyId'] = relyingPartyId;
    }
    if (signCount != null) {
      json[r'signCount'] = signCount;
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    json[r'transports'] = transports;
    if (userAgent != null) {
      json[r'userAgent'] = userAgent;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    return json;
  }

  WebAuthnCredential copyWith(
      {CoseAlgorithmIdentifier? algorithm,
      AttestationType? attestationType,
      bool? authenticatorSupportsUserVerification,
      String? credentialId,
      Map<String, dynamic>? data,
      bool? discoverable,
      String? displayName,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUseInstant,
      String? name,
      String? publicKey,
      String? relyingPartyId,
      int? signCount,
      String? tenantId,
      List<String>? transports,
      String? userAgent,
      String? userId}) {
    return WebAuthnCredential(
      algorithm: algorithm ?? this.algorithm,
      attestationType: attestationType ?? this.attestationType,
      authenticatorSupportsUserVerification:
          authenticatorSupportsUserVerification ??
              this.authenticatorSupportsUserVerification,
      credentialId: credentialId ?? this.credentialId,
      data: data ?? this.data,
      discoverable: discoverable ?? this.discoverable,
      displayName: displayName ?? this.displayName,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUseInstant: lastUseInstant ?? this.lastUseInstant,
      name: name ?? this.name,
      publicKey: publicKey ?? this.publicKey,
      relyingPartyId: relyingPartyId ?? this.relyingPartyId,
      signCount: signCount ?? this.signCount,
      tenantId: tenantId ?? this.tenantId,
      transports: transports ?? this.transports,
      userAgent: userAgent ?? this.userAgent,
      userId: userId ?? this.userId,
    );
  }
}

/// API request to import an existing WebAuthn credential(s)
class WebAuthnCredentialImportRequest {
  final List<WebAuthnCredential> credentials;
  final bool validateDbConstraints;

  WebAuthnCredentialImportRequest(
      {List<WebAuthnCredential>? credentials, bool? validateDbConstraints})
      : credentials = credentials ?? [],
        validateDbConstraints = validateDbConstraints ?? false;

  factory WebAuthnCredentialImportRequest.fromJson(Map<String, Object?> json) {
    return WebAuthnCredentialImportRequest(
      credentials: (json[r'credentials'] as List<Object?>?)
              ?.map((i) => WebAuthnCredential.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      validateDbConstraints: json[r'validateDbConstraints'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var credentials = this.credentials;
    var validateDbConstraints = this.validateDbConstraints;

    final json = <String, Object?>{};
    json[r'credentials'] = credentials.map((i) => i.toJson()).toList();
    json[r'validateDbConstraints'] = validateDbConstraints;
    return json;
  }

  WebAuthnCredentialImportRequest copyWith(
      {List<WebAuthnCredential>? credentials, bool? validateDbConstraints}) {
    return WebAuthnCredentialImportRequest(
      credentials: credentials ?? this.credentials,
      validateDbConstraints:
          validateDbConstraints ?? this.validateDbConstraints,
    );
  }
}

/// WebAuthn Credential API response
class WebAuthnCredentialResponse {
  final WebAuthnCredential? credential;
  final List<WebAuthnCredential> credentials;

  WebAuthnCredentialResponse(
      {this.credential, List<WebAuthnCredential>? credentials})
      : credentials = credentials ?? [];

  factory WebAuthnCredentialResponse.fromJson(Map<String, Object?> json) {
    return WebAuthnCredentialResponse(
      credential: json[r'credential'] != null
          ? WebAuthnCredential.fromJson(
              json[r'credential']! as Map<String, Object?>)
          : null,
      credentials: (json[r'credentials'] as List<Object?>?)
              ?.map((i) => WebAuthnCredential.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var credential = this.credential;
    var credentials = this.credentials;

    final json = <String, Object?>{};
    if (credential != null) {
      json[r'credential'] = credential.toJson();
    }
    json[r'credentials'] = credentials.map((i) => i.toJson()).toList();
    return json;
  }

  WebAuthnCredentialResponse copyWith(
      {WebAuthnCredential? credential, List<WebAuthnCredential>? credentials}) {
    return WebAuthnCredentialResponse(
      credential: credential ?? this.credential,
      credentials: credentials ?? this.credentials,
    );
  }
}

/// Contains extension output for requested extensions during a WebAuthn
/// ceremony
class WebAuthnExtensionsClientOutputs {
  final CredentialPropertiesOutput? credProps;

  WebAuthnExtensionsClientOutputs({this.credProps});

  factory WebAuthnExtensionsClientOutputs.fromJson(Map<String, Object?> json) {
    return WebAuthnExtensionsClientOutputs(
      credProps: json[r'credProps'] != null
          ? CredentialPropertiesOutput.fromJson(
              json[r'credProps']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var credProps = this.credProps;

    final json = <String, Object?>{};
    if (credProps != null) {
      json[r'credProps'] = credProps.toJson();
    }
    return json;
  }

  WebAuthnExtensionsClientOutputs copyWith(
      {CredentialPropertiesOutput? credProps}) {
    return WebAuthnExtensionsClientOutputs(
      credProps: credProps ?? this.credProps,
    );
  }
}

/// Request to complete the WebAuthn registration ceremony
class WebAuthnLoginRequest {
  final WebAuthnPublicKeyAuthenticationRequest? credential;
  final String? origin;
  final String? rpId;
  final String? twoFactorTrustId;
  final String? applicationId;
  final String? ipAddress;
  final MetaData? metaData;
  final bool newDevice;
  final bool noJwt;

  WebAuthnLoginRequest(
      {this.credential,
      this.origin,
      this.rpId,
      this.twoFactorTrustId,
      this.applicationId,
      this.ipAddress,
      this.metaData,
      bool? newDevice,
      bool? noJwt})
      : newDevice = newDevice ?? false,
        noJwt = noJwt ?? false;

  factory WebAuthnLoginRequest.fromJson(Map<String, Object?> json) {
    return WebAuthnLoginRequest(
      credential: json[r'credential'] != null
          ? WebAuthnPublicKeyAuthenticationRequest.fromJson(
              json[r'credential']! as Map<String, Object?>)
          : null,
      origin: json[r'origin'] as String?,
      rpId: json[r'rpId'] as String?,
      twoFactorTrustId: json[r'twoFactorTrustId'] as String?,
      applicationId: json[r'applicationId'] as String?,
      ipAddress: json[r'ipAddress'] as String?,
      metaData: json[r'metaData'] != null
          ? MetaData.fromJson(json[r'metaData']! as Map<String, Object?>)
          : null,
      newDevice: json[r'newDevice'] as bool? ?? false,
      noJwt: json[r'noJWT'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var credential = this.credential;
    var origin = this.origin;
    var rpId = this.rpId;
    var twoFactorTrustId = this.twoFactorTrustId;
    var applicationId = this.applicationId;
    var ipAddress = this.ipAddress;
    var metaData = this.metaData;
    var newDevice = this.newDevice;
    var noJwt = this.noJwt;

    final json = <String, Object?>{};
    if (credential != null) {
      json[r'credential'] = credential.toJson();
    }
    if (origin != null) {
      json[r'origin'] = origin;
    }
    if (rpId != null) {
      json[r'rpId'] = rpId;
    }
    if (twoFactorTrustId != null) {
      json[r'twoFactorTrustId'] = twoFactorTrustId;
    }
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (ipAddress != null) {
      json[r'ipAddress'] = ipAddress;
    }
    if (metaData != null) {
      json[r'metaData'] = metaData.toJson();
    }
    json[r'newDevice'] = newDevice;
    json[r'noJWT'] = noJwt;
    return json;
  }

  WebAuthnLoginRequest copyWith(
      {WebAuthnPublicKeyAuthenticationRequest? credential,
      String? origin,
      String? rpId,
      String? twoFactorTrustId,
      String? applicationId,
      String? ipAddress,
      MetaData? metaData,
      bool? newDevice,
      bool? noJwt}) {
    return WebAuthnLoginRequest(
      credential: credential ?? this.credential,
      origin: origin ?? this.origin,
      rpId: rpId ?? this.rpId,
      twoFactorTrustId: twoFactorTrustId ?? this.twoFactorTrustId,
      applicationId: applicationId ?? this.applicationId,
      ipAddress: ipAddress ?? this.ipAddress,
      metaData: metaData ?? this.metaData,
      newDevice: newDevice ?? this.newDevice,
      noJwt: noJwt ?? this.noJwt,
    );
  }
}

/// Request to authenticate with WebAuthn
class WebAuthnPublicKeyAuthenticationRequest {
  final WebAuthnExtensionsClientOutputs? clientExtensionResults;
  final String? id;
  final String? rpId;
  final WebAuthnAuthenticatorAuthenticationResponse? response;
  final String? type;

  WebAuthnPublicKeyAuthenticationRequest(
      {this.clientExtensionResults,
      this.id,
      this.rpId,
      this.response,
      this.type});

  factory WebAuthnPublicKeyAuthenticationRequest.fromJson(
      Map<String, Object?> json) {
    return WebAuthnPublicKeyAuthenticationRequest(
      clientExtensionResults: json[r'clientExtensionResults'] != null
          ? WebAuthnExtensionsClientOutputs.fromJson(
              json[r'clientExtensionResults']! as Map<String, Object?>)
          : null,
      id: json[r'id'] as String?,
      rpId: json[r'rpId'] as String?,
      response: json[r'response'] != null
          ? WebAuthnAuthenticatorAuthenticationResponse.fromJson(
              json[r'response']! as Map<String, Object?>)
          : null,
      type: json[r'type'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var clientExtensionResults = this.clientExtensionResults;
    var id = this.id;
    var rpId = this.rpId;
    var response = this.response;
    var type = this.type;

    final json = <String, Object?>{};
    if (clientExtensionResults != null) {
      json[r'clientExtensionResults'] = clientExtensionResults.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (rpId != null) {
      json[r'rpId'] = rpId;
    }
    if (response != null) {
      json[r'response'] = response.toJson();
    }
    if (type != null) {
      json[r'type'] = type;
    }
    return json;
  }

  WebAuthnPublicKeyAuthenticationRequest copyWith(
      {WebAuthnExtensionsClientOutputs? clientExtensionResults,
      String? id,
      String? rpId,
      WebAuthnAuthenticatorAuthenticationResponse? response,
      String? type}) {
    return WebAuthnPublicKeyAuthenticationRequest(
      clientExtensionResults:
          clientExtensionResults ?? this.clientExtensionResults,
      id: id ?? this.id,
      rpId: rpId ?? this.rpId,
      response: response ?? this.response,
      type: type ?? this.type,
    );
  }
}

/// Request to register a new public key with WebAuthn
class WebAuthnPublicKeyRegistrationRequest {
  final WebAuthnExtensionsClientOutputs? clientExtensionResults;
  final String? id;
  final String? rpId;
  final WebAuthnAuthenticatorRegistrationResponse? response;
  final List<String> transports;
  final String? type;

  WebAuthnPublicKeyRegistrationRequest(
      {this.clientExtensionResults,
      this.id,
      this.rpId,
      this.response,
      List<String>? transports,
      this.type})
      : transports = transports ?? [];

  factory WebAuthnPublicKeyRegistrationRequest.fromJson(
      Map<String, Object?> json) {
    return WebAuthnPublicKeyRegistrationRequest(
      clientExtensionResults: json[r'clientExtensionResults'] != null
          ? WebAuthnExtensionsClientOutputs.fromJson(
              json[r'clientExtensionResults']! as Map<String, Object?>)
          : null,
      id: json[r'id'] as String?,
      rpId: json[r'rpId'] as String?,
      response: json[r'response'] != null
          ? WebAuthnAuthenticatorRegistrationResponse.fromJson(
              json[r'response']! as Map<String, Object?>)
          : null,
      transports: (json[r'transports'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      type: json[r'type'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var clientExtensionResults = this.clientExtensionResults;
    var id = this.id;
    var rpId = this.rpId;
    var response = this.response;
    var transports = this.transports;
    var type = this.type;

    final json = <String, Object?>{};
    if (clientExtensionResults != null) {
      json[r'clientExtensionResults'] = clientExtensionResults.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (rpId != null) {
      json[r'rpId'] = rpId;
    }
    if (response != null) {
      json[r'response'] = response.toJson();
    }
    json[r'transports'] = transports;
    if (type != null) {
      json[r'type'] = type;
    }
    return json;
  }

  WebAuthnPublicKeyRegistrationRequest copyWith(
      {WebAuthnExtensionsClientOutputs? clientExtensionResults,
      String? id,
      String? rpId,
      WebAuthnAuthenticatorRegistrationResponse? response,
      List<String>? transports,
      String? type}) {
    return WebAuthnPublicKeyRegistrationRequest(
      clientExtensionResults:
          clientExtensionResults ?? this.clientExtensionResults,
      id: id ?? this.id,
      rpId: rpId ?? this.rpId,
      response: response ?? this.response,
      transports: transports ?? this.transports,
      type: type ?? this.type,
    );
  }
}

/// Request to complete the WebAuthn registration ceremony for a new
/// credential,.
class WebAuthnRegisterCompleteRequest {
  final WebAuthnPublicKeyRegistrationRequest? credential;
  final String? origin;
  final String? rpId;
  final String? userId;

  WebAuthnRegisterCompleteRequest(
      {this.credential, this.origin, this.rpId, this.userId});

  factory WebAuthnRegisterCompleteRequest.fromJson(Map<String, Object?> json) {
    return WebAuthnRegisterCompleteRequest(
      credential: json[r'credential'] != null
          ? WebAuthnPublicKeyRegistrationRequest.fromJson(
              json[r'credential']! as Map<String, Object?>)
          : null,
      origin: json[r'origin'] as String?,
      rpId: json[r'rpId'] as String?,
      userId: json[r'userId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var credential = this.credential;
    var origin = this.origin;
    var rpId = this.rpId;
    var userId = this.userId;

    final json = <String, Object?>{};
    if (credential != null) {
      json[r'credential'] = credential.toJson();
    }
    if (origin != null) {
      json[r'origin'] = origin;
    }
    if (rpId != null) {
      json[r'rpId'] = rpId;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    return json;
  }

  WebAuthnRegisterCompleteRequest copyWith(
      {WebAuthnPublicKeyRegistrationRequest? credential,
      String? origin,
      String? rpId,
      String? userId}) {
    return WebAuthnRegisterCompleteRequest(
      credential: credential ?? this.credential,
      origin: origin ?? this.origin,
      rpId: rpId ?? this.rpId,
      userId: userId ?? this.userId,
    );
  }
}

/// API response for completing WebAuthn credential registration or assertion
class WebAuthnRegisterCompleteResponse {
  final WebAuthnCredential? credential;

  WebAuthnRegisterCompleteResponse({this.credential});

  factory WebAuthnRegisterCompleteResponse.fromJson(Map<String, Object?> json) {
    return WebAuthnRegisterCompleteResponse(
      credential: json[r'credential'] != null
          ? WebAuthnCredential.fromJson(
              json[r'credential']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var credential = this.credential;

    final json = <String, Object?>{};
    if (credential != null) {
      json[r'credential'] = credential.toJson();
    }
    return json;
  }

  WebAuthnRegisterCompleteResponse copyWith({WebAuthnCredential? credential}) {
    return WebAuthnRegisterCompleteResponse(
      credential: credential ?? this.credential,
    );
  }
}

/// API request to start a WebAuthn registration ceremony
class WebAuthnRegisterStartRequest {
  final String? displayName;
  final String? name;
  final String? userAgent;
  final String? userId;
  final WebAuthnWorkflow? workflow;

  WebAuthnRegisterStartRequest(
      {this.displayName,
      this.name,
      this.userAgent,
      this.userId,
      this.workflow});

  factory WebAuthnRegisterStartRequest.fromJson(Map<String, Object?> json) {
    return WebAuthnRegisterStartRequest(
      displayName: json[r'displayName'] as String?,
      name: json[r'name'] as String?,
      userAgent: json[r'userAgent'] as String?,
      userId: json[r'userId'] as String?,
      workflow: json[r'workflow'] != null
          ? WebAuthnWorkflow.fromValue(json[r'workflow']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var displayName = this.displayName;
    var name = this.name;
    var userAgent = this.userAgent;
    var userId = this.userId;
    var workflow = this.workflow;

    final json = <String, Object?>{};
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (userAgent != null) {
      json[r'userAgent'] = userAgent;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    if (workflow != null) {
      json[r'workflow'] = workflow.value;
    }
    return json;
  }

  WebAuthnRegisterStartRequest copyWith(
      {String? displayName,
      String? name,
      String? userAgent,
      String? userId,
      WebAuthnWorkflow? workflow}) {
    return WebAuthnRegisterStartRequest(
      displayName: displayName ?? this.displayName,
      name: name ?? this.name,
      userAgent: userAgent ?? this.userAgent,
      userId: userId ?? this.userId,
      workflow: workflow ?? this.workflow,
    );
  }
}

/// API response for starting a WebAuthn registration ceremony
class WebAuthnRegisterStartResponse {
  final PublicKeyCredentialCreationOptions? options;

  WebAuthnRegisterStartResponse({this.options});

  factory WebAuthnRegisterStartResponse.fromJson(Map<String, Object?> json) {
    return WebAuthnRegisterStartResponse(
      options: json[r'options'] != null
          ? PublicKeyCredentialCreationOptions.fromJson(
              json[r'options']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var options = this.options;

    final json = <String, Object?>{};
    if (options != null) {
      json[r'options'] = options.toJson();
    }
    return json;
  }

  WebAuthnRegisterStartResponse copyWith(
      {PublicKeyCredentialCreationOptions? options}) {
    return WebAuthnRegisterStartResponse(
      options: options ?? this.options,
    );
  }
}

/// Options to request extensions during credential registration
class WebAuthnRegistrationExtensionOptions {
  final bool credProps;

  WebAuthnRegistrationExtensionOptions({bool? credProps})
      : credProps = credProps ?? false;

  factory WebAuthnRegistrationExtensionOptions.fromJson(
      Map<String, Object?> json) {
    return WebAuthnRegistrationExtensionOptions(
      credProps: json[r'credProps'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var credProps = this.credProps;

    final json = <String, Object?>{};
    json[r'credProps'] = credProps;
    return json;
  }

  WebAuthnRegistrationExtensionOptions copyWith({bool? credProps}) {
    return WebAuthnRegistrationExtensionOptions(
      credProps: credProps ?? this.credProps,
    );
  }
}

/// API request to start a WebAuthn authentication ceremony
class WebAuthnStartRequest {
  final String? applicationId;
  final String? credentialId;
  final String? loginId;
  final Map<String, dynamic>? state;
  final String? userId;
  final WebAuthnWorkflow? workflow;

  WebAuthnStartRequest(
      {this.applicationId,
      this.credentialId,
      this.loginId,
      this.state,
      this.userId,
      this.workflow});

  factory WebAuthnStartRequest.fromJson(Map<String, Object?> json) {
    return WebAuthnStartRequest(
      applicationId: json[r'applicationId'] as String?,
      credentialId: json[r'credentialId'] as String?,
      loginId: json[r'loginId'] as String?,
      state: json[r'state'] as Map<String, Object?>?,
      userId: json[r'userId'] as String?,
      workflow: json[r'workflow'] != null
          ? WebAuthnWorkflow.fromValue(json[r'workflow']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var applicationId = this.applicationId;
    var credentialId = this.credentialId;
    var loginId = this.loginId;
    var state = this.state;
    var userId = this.userId;
    var workflow = this.workflow;

    final json = <String, Object?>{};
    if (applicationId != null) {
      json[r'applicationId'] = applicationId;
    }
    if (credentialId != null) {
      json[r'credentialId'] = credentialId;
    }
    if (loginId != null) {
      json[r'loginId'] = loginId;
    }
    if (state != null) {
      json[r'state'] = state;
    }
    if (userId != null) {
      json[r'userId'] = userId;
    }
    if (workflow != null) {
      json[r'workflow'] = workflow.value;
    }
    return json;
  }

  WebAuthnStartRequest copyWith(
      {String? applicationId,
      String? credentialId,
      String? loginId,
      Map<String, dynamic>? state,
      String? userId,
      WebAuthnWorkflow? workflow}) {
    return WebAuthnStartRequest(
      applicationId: applicationId ?? this.applicationId,
      credentialId: credentialId ?? this.credentialId,
      loginId: loginId ?? this.loginId,
      state: state ?? this.state,
      userId: userId ?? this.userId,
      workflow: workflow ?? this.workflow,
    );
  }
}

/// API response for starting a WebAuthn authentication ceremony
class WebAuthnStartResponse {
  final PublicKeyCredentialRequestOptions? options;

  WebAuthnStartResponse({this.options});

  factory WebAuthnStartResponse.fromJson(Map<String, Object?> json) {
    return WebAuthnStartResponse(
      options: json[r'options'] != null
          ? PublicKeyCredentialRequestOptions.fromJson(
              json[r'options']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var options = this.options;

    final json = <String, Object?>{};
    if (options != null) {
      json[r'options'] = options.toJson();
    }
    return json;
  }

  WebAuthnStartResponse copyWith({PublicKeyCredentialRequestOptions? options}) {
    return WebAuthnStartResponse(
      options: options ?? this.options,
    );
  }
}

/// A server where events are sent. This includes user action events and any
/// other events sent by FusionAuth.
class Webhook {
  final int? connectTimeout;
  final Map<String, dynamic>? data;
  final String? description;
  final Map<String, dynamic>? eventsEnabled;
  final bool global;
  final HTTPHeaders? headers;
  final String? httpAuthenticationPassword;
  final String? httpAuthenticationUsername;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastUpdateInstant;
  final int? readTimeout;
  final WebhookSignatureConfiguration? signatureConfiguration;
  final String? sslCertificate;
  final String? sslCertificateKeyId;
  final List<String> tenantIds;
  final String? url;

  Webhook(
      {this.connectTimeout,
      this.data,
      this.description,
      this.eventsEnabled,
      bool? global,
      this.headers,
      this.httpAuthenticationPassword,
      this.httpAuthenticationUsername,
      this.id,
      this.insertInstant,
      this.lastUpdateInstant,
      this.readTimeout,
      this.signatureConfiguration,
      this.sslCertificate,
      this.sslCertificateKeyId,
      List<String>? tenantIds,
      this.url})
      : global = global ?? false,
        tenantIds = tenantIds ?? [];

  factory Webhook.fromJson(Map<String, Object?> json) {
    return Webhook(
      connectTimeout: (json[r'connectTimeout'] as num?)?.toInt(),
      data: json[r'data'] as Map<String, Object?>?,
      description: json[r'description'] as String?,
      eventsEnabled: json[r'eventsEnabled'] as Map<String, Object?>?,
      global: json[r'global'] as bool? ?? false,
      headers: json[r'headers'] != null
          ? HTTPHeaders.fromJson(json[r'headers']! as Map<String, Object?>)
          : null,
      httpAuthenticationPassword:
          json[r'httpAuthenticationPassword'] as String?,
      httpAuthenticationUsername:
          json[r'httpAuthenticationUsername'] as String?,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      readTimeout: (json[r'readTimeout'] as num?)?.toInt(),
      signatureConfiguration: json[r'signatureConfiguration'] != null
          ? WebhookSignatureConfiguration.fromJson(
              json[r'signatureConfiguration']! as Map<String, Object?>)
          : null,
      sslCertificate: json[r'sslCertificate'] as String?,
      sslCertificateKeyId: json[r'sslCertificateKeyId'] as String?,
      tenantIds: (json[r'tenantIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      url: json[r'url'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var connectTimeout = this.connectTimeout;
    var data = this.data;
    var description = this.description;
    var eventsEnabled = this.eventsEnabled;
    var global = this.global;
    var headers = this.headers;
    var httpAuthenticationPassword = this.httpAuthenticationPassword;
    var httpAuthenticationUsername = this.httpAuthenticationUsername;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var readTimeout = this.readTimeout;
    var signatureConfiguration = this.signatureConfiguration;
    var sslCertificate = this.sslCertificate;
    var sslCertificateKeyId = this.sslCertificateKeyId;
    var tenantIds = this.tenantIds;
    var url = this.url;

    final json = <String, Object?>{};
    if (connectTimeout != null) {
      json[r'connectTimeout'] = connectTimeout;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (eventsEnabled != null) {
      json[r'eventsEnabled'] = eventsEnabled;
    }
    json[r'global'] = global;
    if (headers != null) {
      json[r'headers'] = headers.toJson();
    }
    if (httpAuthenticationPassword != null) {
      json[r'httpAuthenticationPassword'] = httpAuthenticationPassword;
    }
    if (httpAuthenticationUsername != null) {
      json[r'httpAuthenticationUsername'] = httpAuthenticationUsername;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (readTimeout != null) {
      json[r'readTimeout'] = readTimeout;
    }
    if (signatureConfiguration != null) {
      json[r'signatureConfiguration'] = signatureConfiguration.toJson();
    }
    if (sslCertificate != null) {
      json[r'sslCertificate'] = sslCertificate;
    }
    if (sslCertificateKeyId != null) {
      json[r'sslCertificateKeyId'] = sslCertificateKeyId;
    }
    json[r'tenantIds'] = tenantIds;
    if (url != null) {
      json[r'url'] = url;
    }
    return json;
  }

  Webhook copyWith(
      {int? connectTimeout,
      Map<String, dynamic>? data,
      String? description,
      Map<String, dynamic>? eventsEnabled,
      bool? global,
      HTTPHeaders? headers,
      String? httpAuthenticationPassword,
      String? httpAuthenticationUsername,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastUpdateInstant,
      int? readTimeout,
      WebhookSignatureConfiguration? signatureConfiguration,
      String? sslCertificate,
      String? sslCertificateKeyId,
      List<String>? tenantIds,
      String? url}) {
    return Webhook(
      connectTimeout: connectTimeout ?? this.connectTimeout,
      data: data ?? this.data,
      description: description ?? this.description,
      eventsEnabled: eventsEnabled ?? this.eventsEnabled,
      global: global ?? this.global,
      headers: headers ?? this.headers,
      httpAuthenticationPassword:
          httpAuthenticationPassword ?? this.httpAuthenticationPassword,
      httpAuthenticationUsername:
          httpAuthenticationUsername ?? this.httpAuthenticationUsername,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      readTimeout: readTimeout ?? this.readTimeout,
      signatureConfiguration:
          signatureConfiguration ?? this.signatureConfiguration,
      sslCertificate: sslCertificate ?? this.sslCertificate,
      sslCertificateKeyId: sslCertificateKeyId ?? this.sslCertificateKeyId,
      tenantIds: tenantIds ?? this.tenantIds,
      url: url ?? this.url,
    );
  }
}

/// A webhook call attempt log.
class WebhookAttemptLog {
  final Map<String, dynamic>? data;
  final ZonedDateTime? endInstant;
  final String? id;
  final ZonedDateTime? startInstant;
  final WebhookCallResponse? webhookCallResponse;
  final String? webhookEventLogId;
  final String? webhookId;
  final WebhookAttemptResult? attemptResult;

  WebhookAttemptLog(
      {this.data,
      this.endInstant,
      this.id,
      this.startInstant,
      this.webhookCallResponse,
      this.webhookEventLogId,
      this.webhookId,
      this.attemptResult});

  factory WebhookAttemptLog.fromJson(Map<String, Object?> json) {
    return WebhookAttemptLog(
      data: json[r'data'] as Map<String, Object?>?,
      endInstant: (json[r'endInstant'] as num?)?.toInt() as ZonedDateTime?,
      id: json[r'id'] as String?,
      startInstant: (json[r'startInstant'] as num?)?.toInt() as ZonedDateTime?,
      webhookCallResponse: json[r'webhookCallResponse'] != null
          ? WebhookCallResponse.fromJson(
              json[r'webhookCallResponse']! as Map<String, Object?>)
          : null,
      webhookEventLogId: json[r'webhookEventLogId'] as String?,
      webhookId: json[r'webhookId'] as String?,
      attemptResult: json[r'attemptResult'] != null
          ? WebhookAttemptResult.fromValue(json[r'attemptResult']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var data = this.data;
    var endInstant = this.endInstant;
    var id = this.id;
    var startInstant = this.startInstant;
    var webhookCallResponse = this.webhookCallResponse;
    var webhookEventLogId = this.webhookEventLogId;
    var webhookId = this.webhookId;
    var attemptResult = this.attemptResult;

    final json = <String, Object?>{};
    if (data != null) {
      json[r'data'] = data;
    }
    if (endInstant != null) {
      json[r'endInstant'] = endInstant.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (startInstant != null) {
      json[r'startInstant'] = startInstant.toJson();
    }
    if (webhookCallResponse != null) {
      json[r'webhookCallResponse'] = webhookCallResponse.toJson();
    }
    if (webhookEventLogId != null) {
      json[r'webhookEventLogId'] = webhookEventLogId;
    }
    if (webhookId != null) {
      json[r'webhookId'] = webhookId;
    }
    if (attemptResult != null) {
      json[r'attemptResult'] = attemptResult.value;
    }
    return json;
  }

  WebhookAttemptLog copyWith(
      {Map<String, dynamic>? data,
      ZonedDateTime? endInstant,
      String? id,
      ZonedDateTime? startInstant,
      WebhookCallResponse? webhookCallResponse,
      String? webhookEventLogId,
      String? webhookId,
      WebhookAttemptResult? attemptResult}) {
    return WebhookAttemptLog(
      data: data ?? this.data,
      endInstant: endInstant ?? this.endInstant,
      id: id ?? this.id,
      startInstant: startInstant ?? this.startInstant,
      webhookCallResponse: webhookCallResponse ?? this.webhookCallResponse,
      webhookEventLogId: webhookEventLogId ?? this.webhookEventLogId,
      webhookId: webhookId ?? this.webhookId,
      attemptResult: attemptResult ?? this.attemptResult,
    );
  }
}

/// Webhook attempt log response.
class WebhookAttemptLogResponse {
  final WebhookAttemptLog? webhookAttemptLog;

  WebhookAttemptLogResponse({this.webhookAttemptLog});

  factory WebhookAttemptLogResponse.fromJson(Map<String, Object?> json) {
    return WebhookAttemptLogResponse(
      webhookAttemptLog: json[r'webhookAttemptLog'] != null
          ? WebhookAttemptLog.fromJson(
              json[r'webhookAttemptLog']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var webhookAttemptLog = this.webhookAttemptLog;

    final json = <String, Object?>{};
    if (webhookAttemptLog != null) {
      json[r'webhookAttemptLog'] = webhookAttemptLog.toJson();
    }
    return json;
  }

  WebhookAttemptLogResponse copyWith({WebhookAttemptLog? webhookAttemptLog}) {
    return WebhookAttemptLogResponse(
      webhookAttemptLog: webhookAttemptLog ?? this.webhookAttemptLog,
    );
  }
}

/// A webhook call response.
class WebhookCallResponse {
  final String? exception;
  final int? statusCode;
  final String? url;

  WebhookCallResponse({this.exception, this.statusCode, this.url});

  factory WebhookCallResponse.fromJson(Map<String, Object?> json) {
    return WebhookCallResponse(
      exception: json[r'exception'] as String?,
      statusCode: (json[r'statusCode'] as num?)?.toInt(),
      url: json[r'url'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var exception = this.exception;
    var statusCode = this.statusCode;
    var url = this.url;

    final json = <String, Object?>{};
    if (exception != null) {
      json[r'exception'] = exception;
    }
    if (statusCode != null) {
      json[r'statusCode'] = statusCode;
    }
    if (url != null) {
      json[r'url'] = url;
    }
    return json;
  }

  WebhookCallResponse copyWith(
      {String? exception, int? statusCode, String? url}) {
    return WebhookCallResponse(
      exception: exception ?? this.exception,
      statusCode: statusCode ?? this.statusCode,
      url: url ?? this.url,
    );
  }
}

class WebhookEventLog {
  final List<WebhookAttemptLog> attempts;
  final Map<String, dynamic>? data;
  final EventRequest? event;
  final WebhookEventResult? eventResult;
  final EventType? eventType;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ZonedDateTime? lastAttemptInstant;
  final ZonedDateTime? lastUpdateInstant;
  final String? linkedObjectId;
  final int? sequence;
  final int? failedAttempts;
  final int? successfulAttempts;

  WebhookEventLog(
      {List<WebhookAttemptLog>? attempts,
      this.data,
      this.event,
      this.eventResult,
      this.eventType,
      this.id,
      this.insertInstant,
      this.lastAttemptInstant,
      this.lastUpdateInstant,
      this.linkedObjectId,
      this.sequence,
      this.failedAttempts,
      this.successfulAttempts})
      : attempts = attempts ?? [];

  factory WebhookEventLog.fromJson(Map<String, Object?> json) {
    return WebhookEventLog(
      attempts: (json[r'attempts'] as List<Object?>?)
              ?.map((i) => WebhookAttemptLog.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      data: json[r'data'] as Map<String, Object?>?,
      event: json[r'event'] != null
          ? EventRequest.fromJson(json[r'event']! as Map<String, Object?>)
          : null,
      eventResult: json[r'eventResult'] != null
          ? WebhookEventResult.fromValue(json[r'eventResult']! as String)
          : null,
      eventType: json[r'eventType'] != null
          ? EventType.fromValue(json[r'eventType']! as String)
          : null,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastAttemptInstant:
          (json[r'lastAttemptInstant'] as num?)?.toInt() as ZonedDateTime?,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      linkedObjectId: json[r'linkedObjectId'] as String?,
      sequence: (json[r'sequence'] as num?)?.toInt(),
      failedAttempts: (json[r'failedAttempts'] as num?)?.toInt(),
      successfulAttempts: (json[r'successfulAttempts'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var attempts = this.attempts;
    var data = this.data;
    var event = this.event;
    var eventResult = this.eventResult;
    var eventType = this.eventType;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lastAttemptInstant = this.lastAttemptInstant;
    var lastUpdateInstant = this.lastUpdateInstant;
    var linkedObjectId = this.linkedObjectId;
    var sequence = this.sequence;
    var failedAttempts = this.failedAttempts;
    var successfulAttempts = this.successfulAttempts;

    final json = <String, Object?>{};
    json[r'attempts'] = attempts.map((i) => i.toJson()).toList();
    if (data != null) {
      json[r'data'] = data;
    }
    if (event != null) {
      json[r'event'] = event.toJson();
    }
    if (eventResult != null) {
      json[r'eventResult'] = eventResult.value;
    }
    if (eventType != null) {
      json[r'eventType'] = eventType.value;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lastAttemptInstant != null) {
      json[r'lastAttemptInstant'] = lastAttemptInstant.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (linkedObjectId != null) {
      json[r'linkedObjectId'] = linkedObjectId;
    }
    if (sequence != null) {
      json[r'sequence'] = sequence;
    }
    if (failedAttempts != null) {
      json[r'failedAttempts'] = failedAttempts;
    }
    if (successfulAttempts != null) {
      json[r'successfulAttempts'] = successfulAttempts;
    }
    return json;
  }

  WebhookEventLog copyWith(
      {List<WebhookAttemptLog>? attempts,
      Map<String, dynamic>? data,
      EventRequest? event,
      WebhookEventResult? eventResult,
      EventType? eventType,
      String? id,
      ZonedDateTime? insertInstant,
      ZonedDateTime? lastAttemptInstant,
      ZonedDateTime? lastUpdateInstant,
      String? linkedObjectId,
      int? sequence,
      int? failedAttempts,
      int? successfulAttempts}) {
    return WebhookEventLog(
      attempts: attempts ?? this.attempts,
      data: data ?? this.data,
      event: event ?? this.event,
      eventResult: eventResult ?? this.eventResult,
      eventType: eventType ?? this.eventType,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lastAttemptInstant: lastAttemptInstant ?? this.lastAttemptInstant,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      linkedObjectId: linkedObjectId ?? this.linkedObjectId,
      sequence: sequence ?? this.sequence,
      failedAttempts: failedAttempts ?? this.failedAttempts,
      successfulAttempts: successfulAttempts ?? this.successfulAttempts,
    );
  }
}

/// The system configuration for Webhook Event Log data.
class WebhookEventLogConfiguration {
  final DeleteConfiguration? delete;

  WebhookEventLogConfiguration({this.delete});

  factory WebhookEventLogConfiguration.fromJson(Map<String, Object?> json) {
    return WebhookEventLogConfiguration(
      delete: json[r'delete'] != null
          ? DeleteConfiguration.fromJson(
              json[r'delete']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var delete = this.delete;

    final json = <String, Object?>{};
    if (delete != null) {
      json[r'delete'] = delete.toJson();
    }
    return json;
  }

  WebhookEventLogConfiguration copyWith({DeleteConfiguration? delete}) {
    return WebhookEventLogConfiguration(
      delete: delete ?? this.delete,
    );
  }
}

/// Webhook event log response.
class WebhookEventLogResponse {
  final WebhookEventLog? webhookEventLog;

  WebhookEventLogResponse({this.webhookEventLog});

  factory WebhookEventLogResponse.fromJson(Map<String, Object?> json) {
    return WebhookEventLogResponse(
      webhookEventLog: json[r'webhookEventLog'] != null
          ? WebhookEventLog.fromJson(
              json[r'webhookEventLog']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var webhookEventLog = this.webhookEventLog;

    final json = <String, Object?>{};
    if (webhookEventLog != null) {
      json[r'webhookEventLog'] = webhookEventLog.toJson();
    }
    return json;
  }

  WebhookEventLogResponse copyWith({WebhookEventLog? webhookEventLog}) {
    return WebhookEventLogResponse(
      webhookEventLog: webhookEventLog ?? this.webhookEventLog,
    );
  }
}

/// Search criteria for the webhook event log.
class WebhookEventLogSearchCriteria {
  final ZonedDateTime? end;
  final String? event;
  final WebhookEventResult? eventResult;
  final EventType? eventType;
  final ZonedDateTime? start;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  WebhookEventLogSearchCriteria(
      {this.end,
      this.event,
      this.eventResult,
      this.eventType,
      this.start,
      this.numberOfResults,
      this.orderBy,
      this.startRow});

  factory WebhookEventLogSearchCriteria.fromJson(Map<String, Object?> json) {
    return WebhookEventLogSearchCriteria(
      end: (json[r'end'] as num?)?.toInt() as ZonedDateTime?,
      event: json[r'event'] as String?,
      eventResult: json[r'eventResult'] != null
          ? WebhookEventResult.fromValue(json[r'eventResult']! as String)
          : null,
      eventType: json[r'eventType'] != null
          ? EventType.fromValue(json[r'eventType']! as String)
          : null,
      start: (json[r'start'] as num?)?.toInt() as ZonedDateTime?,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var end = this.end;
    var event = this.event;
    var eventResult = this.eventResult;
    var eventType = this.eventType;
    var start = this.start;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (end != null) {
      json[r'end'] = end.toJson();
    }
    if (event != null) {
      json[r'event'] = event;
    }
    if (eventResult != null) {
      json[r'eventResult'] = eventResult.value;
    }
    if (eventType != null) {
      json[r'eventType'] = eventType.value;
    }
    if (start != null) {
      json[r'start'] = start.toJson();
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  WebhookEventLogSearchCriteria copyWith(
      {ZonedDateTime? end,
      String? event,
      WebhookEventResult? eventResult,
      EventType? eventType,
      ZonedDateTime? start,
      int? numberOfResults,
      String? orderBy,
      int? startRow}) {
    return WebhookEventLogSearchCriteria(
      end: end ?? this.end,
      event: event ?? this.event,
      eventResult: eventResult ?? this.eventResult,
      eventType: eventType ?? this.eventType,
      start: start ?? this.start,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Webhook event log search request.
class WebhookEventLogSearchRequest {
  final WebhookEventLogSearchCriteria? search;

  WebhookEventLogSearchRequest({this.search});

  factory WebhookEventLogSearchRequest.fromJson(Map<String, Object?> json) {
    return WebhookEventLogSearchRequest(
      search: json[r'search'] != null
          ? WebhookEventLogSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  WebhookEventLogSearchRequest copyWith(
      {WebhookEventLogSearchCriteria? search}) {
    return WebhookEventLogSearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Webhook event log search response.
class WebhookEventLogSearchResponse {
  final int? total;
  final List<WebhookEventLog> webhookEventLogs;

  WebhookEventLogSearchResponse(
      {this.total, List<WebhookEventLog>? webhookEventLogs})
      : webhookEventLogs = webhookEventLogs ?? [];

  factory WebhookEventLogSearchResponse.fromJson(Map<String, Object?> json) {
    return WebhookEventLogSearchResponse(
      total: (json[r'total'] as num?)?.toInt(),
      webhookEventLogs: (json[r'webhookEventLogs'] as List<Object?>?)
              ?.map((i) => WebhookEventLog.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var total = this.total;
    var webhookEventLogs = this.webhookEventLogs;

    final json = <String, Object?>{};
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'webhookEventLogs'] =
        webhookEventLogs.map((i) => i.toJson()).toList();
    return json;
  }

  WebhookEventLogSearchResponse copyWith(
      {int? total, List<WebhookEventLog>? webhookEventLogs}) {
    return WebhookEventLogSearchResponse(
      total: total ?? this.total,
      webhookEventLogs: webhookEventLogs ?? this.webhookEventLogs,
    );
  }
}

/// Webhook API request object.
class WebhookRequest {
  final Webhook? webhook;

  WebhookRequest({this.webhook});

  factory WebhookRequest.fromJson(Map<String, Object?> json) {
    return WebhookRequest(
      webhook: json[r'webhook'] != null
          ? Webhook.fromJson(json[r'webhook']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var webhook = this.webhook;

    final json = <String, Object?>{};
    if (webhook != null) {
      json[r'webhook'] = webhook.toJson();
    }
    return json;
  }

  WebhookRequest copyWith({Webhook? webhook}) {
    return WebhookRequest(
      webhook: webhook ?? this.webhook,
    );
  }
}

/// Webhook API response object.
class WebhookResponse {
  final Webhook? webhook;
  final List<Webhook> webhooks;

  WebhookResponse({this.webhook, List<Webhook>? webhooks})
      : webhooks = webhooks ?? [];

  factory WebhookResponse.fromJson(Map<String, Object?> json) {
    return WebhookResponse(
      webhook: json[r'webhook'] != null
          ? Webhook.fromJson(json[r'webhook']! as Map<String, Object?>)
          : null,
      webhooks: (json[r'webhooks'] as List<Object?>?)
              ?.map((i) =>
                  Webhook.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var webhook = this.webhook;
    var webhooks = this.webhooks;

    final json = <String, Object?>{};
    if (webhook != null) {
      json[r'webhook'] = webhook.toJson();
    }
    json[r'webhooks'] = webhooks.map((i) => i.toJson()).toList();
    return json;
  }

  WebhookResponse copyWith({Webhook? webhook, List<Webhook>? webhooks}) {
    return WebhookResponse(
      webhook: webhook ?? this.webhook,
      webhooks: webhooks ?? this.webhooks,
    );
  }
}

/// Search criteria for webhooks.
class WebhookSearchCriteria {
  final String? description;
  final String? tenantId;
  final String? url;
  final int? numberOfResults;
  final String? orderBy;
  final int? startRow;

  WebhookSearchCriteria(
      {this.description,
      this.tenantId,
      this.url,
      this.numberOfResults,
      this.orderBy,
      this.startRow});

  factory WebhookSearchCriteria.fromJson(Map<String, Object?> json) {
    return WebhookSearchCriteria(
      description: json[r'description'] as String?,
      tenantId: json[r'tenantId'] as String?,
      url: json[r'url'] as String?,
      numberOfResults: (json[r'numberOfResults'] as num?)?.toInt(),
      orderBy: json[r'orderBy'] as String?,
      startRow: (json[r'startRow'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var tenantId = this.tenantId;
    var url = this.url;
    var numberOfResults = this.numberOfResults;
    var orderBy = this.orderBy;
    var startRow = this.startRow;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (tenantId != null) {
      json[r'tenantId'] = tenantId;
    }
    if (url != null) {
      json[r'url'] = url;
    }
    if (numberOfResults != null) {
      json[r'numberOfResults'] = numberOfResults;
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy;
    }
    if (startRow != null) {
      json[r'startRow'] = startRow;
    }
    return json;
  }

  WebhookSearchCriteria copyWith(
      {String? description,
      String? tenantId,
      String? url,
      int? numberOfResults,
      String? orderBy,
      int? startRow}) {
    return WebhookSearchCriteria(
      description: description ?? this.description,
      tenantId: tenantId ?? this.tenantId,
      url: url ?? this.url,
      numberOfResults: numberOfResults ?? this.numberOfResults,
      orderBy: orderBy ?? this.orderBy,
      startRow: startRow ?? this.startRow,
    );
  }
}

/// Search request for webhooks
class WebhookSearchRequest {
  final WebhookSearchCriteria? search;

  WebhookSearchRequest({this.search});

  factory WebhookSearchRequest.fromJson(Map<String, Object?> json) {
    return WebhookSearchRequest(
      search: json[r'search'] != null
          ? WebhookSearchCriteria.fromJson(
              json[r'search']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var search = this.search;

    final json = <String, Object?>{};
    if (search != null) {
      json[r'search'] = search.toJson();
    }
    return json;
  }

  WebhookSearchRequest copyWith({WebhookSearchCriteria? search}) {
    return WebhookSearchRequest(
      search: search ?? this.search,
    );
  }
}

/// Webhook search response
class WebhookSearchResponse {
  final int? total;
  final List<Webhook> webhooks;

  WebhookSearchResponse({this.total, List<Webhook>? webhooks})
      : webhooks = webhooks ?? [];

  factory WebhookSearchResponse.fromJson(Map<String, Object?> json) {
    return WebhookSearchResponse(
      total: (json[r'total'] as num?)?.toInt(),
      webhooks: (json[r'webhooks'] as List<Object?>?)
              ?.map((i) =>
                  Webhook.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var total = this.total;
    var webhooks = this.webhooks;

    final json = <String, Object?>{};
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'webhooks'] = webhooks.map((i) => i.toJson()).toList();
    return json;
  }

  WebhookSearchResponse copyWith({int? total, List<Webhook>? webhooks}) {
    return WebhookSearchResponse(
      total: total ?? this.total,
      webhooks: webhooks ?? this.webhooks,
    );
  }
}

/// Configuration for signing webhooks.
class WebhookSignatureConfiguration {
  final String? signingKeyId;
  final bool enabled;

  WebhookSignatureConfiguration({this.signingKeyId, bool? enabled})
      : enabled = enabled ?? false;

  factory WebhookSignatureConfiguration.fromJson(Map<String, Object?> json) {
    return WebhookSignatureConfiguration(
      signingKeyId: json[r'signingKeyId'] as String?,
      enabled: json[r'enabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var signingKeyId = this.signingKeyId;
    var enabled = this.enabled;

    final json = <String, Object?>{};
    if (signingKeyId != null) {
      json[r'signingKeyId'] = signingKeyId;
    }
    json[r'enabled'] = enabled;
    return json;
  }

  WebhookSignatureConfiguration copyWith(
      {String? signingKeyId, bool? enabled}) {
    return WebhookSignatureConfiguration(
      signingKeyId: signingKeyId ?? this.signingKeyId,
      enabled: enabled ?? this.enabled,
    );
  }
}

class XboxApplicationConfiguration {
  final String? buttonText;
  final String? clientId;
  final String? clientSecret;
  final String? scope;
  final Map<String, dynamic>? data;
  final bool createRegistration;

  XboxApplicationConfiguration(
      {this.buttonText,
      this.clientId,
      this.clientSecret,
      this.scope,
      this.data,
      bool? createRegistration})
      : createRegistration = createRegistration ?? false;

  factory XboxApplicationConfiguration.fromJson(Map<String, Object?> json) {
    return XboxApplicationConfiguration(
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      scope: json[r'scope'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      createRegistration: json[r'createRegistration'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var scope = this.scope;
    var data = this.data;
    var createRegistration = this.createRegistration;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    json[r'createRegistration'] = createRegistration;
    return json;
  }

  XboxApplicationConfiguration copyWith(
      {String? buttonText,
      String? clientId,
      String? clientSecret,
      String? scope,
      Map<String, dynamic>? data,
      bool? createRegistration}) {
    return XboxApplicationConfiguration(
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      scope: scope ?? this.scope,
      data: data ?? this.data,
      createRegistration: createRegistration ?? this.createRegistration,
    );
  }
}

/// Xbox gaming login provider.
class XboxIdentityProvider {
  final String? buttonText;
  final String? clientId;
  final String? clientSecret;
  final String? scope;
  final Map<String, dynamic>? data;
  final Map<String, dynamic>? applicationConfiguration;
  final bool debug;
  final String? id;
  final ZonedDateTime? insertInstant;
  final ProviderLambdaConfiguration? lambdaConfiguration;
  final ZonedDateTime? lastUpdateInstant;
  final IdentityProviderLinkingStrategy? linkingStrategy;
  final String? name;
  final Map<String, dynamic>? tenantConfiguration;
  final IdentityProviderType? type;

  XboxIdentityProvider(
      {this.buttonText,
      this.clientId,
      this.clientSecret,
      this.scope,
      this.data,
      this.applicationConfiguration,
      bool? debug,
      this.id,
      this.insertInstant,
      this.lambdaConfiguration,
      this.lastUpdateInstant,
      this.linkingStrategy,
      this.name,
      this.tenantConfiguration,
      this.type})
      : debug = debug ?? false;

  factory XboxIdentityProvider.fromJson(Map<String, Object?> json) {
    return XboxIdentityProvider(
      buttonText: json[r'buttonText'] as String?,
      clientId: json[r'client_id'] as String?,
      clientSecret: json[r'client_secret'] as String?,
      scope: json[r'scope'] as String?,
      data: json[r'data'] as Map<String, Object?>?,
      applicationConfiguration:
          json[r'applicationConfiguration'] as Map<String, Object?>?,
      debug: json[r'debug'] as bool? ?? false,
      id: json[r'id'] as String?,
      insertInstant:
          (json[r'insertInstant'] as num?)?.toInt() as ZonedDateTime?,
      lambdaConfiguration: json[r'lambdaConfiguration'] != null
          ? ProviderLambdaConfiguration.fromJson(
              json[r'lambdaConfiguration']! as Map<String, Object?>)
          : null,
      lastUpdateInstant:
          (json[r'lastUpdateInstant'] as num?)?.toInt() as ZonedDateTime?,
      linkingStrategy: json[r'linkingStrategy'] != null
          ? IdentityProviderLinkingStrategy.fromValue(
              json[r'linkingStrategy']! as String)
          : null,
      name: json[r'name'] as String?,
      tenantConfiguration:
          json[r'tenantConfiguration'] as Map<String, Object?>?,
      type: json[r'type'] != null
          ? IdentityProviderType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var buttonText = this.buttonText;
    var clientId = this.clientId;
    var clientSecret = this.clientSecret;
    var scope = this.scope;
    var data = this.data;
    var applicationConfiguration = this.applicationConfiguration;
    var debug = this.debug;
    var id = this.id;
    var insertInstant = this.insertInstant;
    var lambdaConfiguration = this.lambdaConfiguration;
    var lastUpdateInstant = this.lastUpdateInstant;
    var linkingStrategy = this.linkingStrategy;
    var name = this.name;
    var tenantConfiguration = this.tenantConfiguration;
    var type = this.type;

    final json = <String, Object?>{};
    if (buttonText != null) {
      json[r'buttonText'] = buttonText;
    }
    if (clientId != null) {
      json[r'client_id'] = clientId;
    }
    if (clientSecret != null) {
      json[r'client_secret'] = clientSecret;
    }
    if (scope != null) {
      json[r'scope'] = scope;
    }
    if (data != null) {
      json[r'data'] = data;
    }
    if (applicationConfiguration != null) {
      json[r'applicationConfiguration'] = applicationConfiguration;
    }
    json[r'debug'] = debug;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insertInstant != null) {
      json[r'insertInstant'] = insertInstant.toJson();
    }
    if (lambdaConfiguration != null) {
      json[r'lambdaConfiguration'] = lambdaConfiguration.toJson();
    }
    if (lastUpdateInstant != null) {
      json[r'lastUpdateInstant'] = lastUpdateInstant.toJson();
    }
    if (linkingStrategy != null) {
      json[r'linkingStrategy'] = linkingStrategy.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (tenantConfiguration != null) {
      json[r'tenantConfiguration'] = tenantConfiguration;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  XboxIdentityProvider copyWith(
      {String? buttonText,
      String? clientId,
      String? clientSecret,
      String? scope,
      Map<String, dynamic>? data,
      Map<String, dynamic>? applicationConfiguration,
      bool? debug,
      String? id,
      ZonedDateTime? insertInstant,
      ProviderLambdaConfiguration? lambdaConfiguration,
      ZonedDateTime? lastUpdateInstant,
      IdentityProviderLinkingStrategy? linkingStrategy,
      String? name,
      Map<String, dynamic>? tenantConfiguration,
      IdentityProviderType? type}) {
    return XboxIdentityProvider(
      buttonText: buttonText ?? this.buttonText,
      clientId: clientId ?? this.clientId,
      clientSecret: clientSecret ?? this.clientSecret,
      scope: scope ?? this.scope,
      data: data ?? this.data,
      applicationConfiguration:
          applicationConfiguration ?? this.applicationConfiguration,
      debug: debug ?? this.debug,
      id: id ?? this.id,
      insertInstant: insertInstant ?? this.insertInstant,
      lambdaConfiguration: lambdaConfiguration ?? this.lambdaConfiguration,
      lastUpdateInstant: lastUpdateInstant ?? this.lastUpdateInstant,
      linkingStrategy: linkingStrategy ?? this.linkingStrategy,
      name: name ?? this.name,
      tenantConfiguration: tenantConfiguration ?? this.tenantConfiguration,
      type: type ?? this.type,
    );
  }
}

extension type LocalDate(String value) {
  LocalDate.fromJson(this.value);
  String toJson() => value;
}

extension type Locale(String value) {
  Locale.fromJson(this.value);
  String toJson() => value;
}

extension type ZoneId(String value) {
  ZoneId.fromJson(this.value);
  String toJson() => value;
}

extension type ZonedDateTime(int value) {
  ZonedDateTime.fromJson(this.value);
  int toJson() => value;
}
